<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TUSAŞ | Laminate Stacking Optimizer</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;600&display=swap"
    rel="stylesheet" />
  <link rel="stylesheet" href="/static/css/app.css" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
            mono: ['JetBrains Mono', 'ui-monospace', 'SFMono-Regular'],
          },
          colors: {
            space: {
              900: '#0f172a',
              800: '#111827',
              700: '#1f2937',
            },
            /* Aerospace Blue (kurumsal) */
            electric: '#1d4ed8',
          },
        },
      },
    };
  </script>
</head>

<body class="bg-transparent text-slate-900 font-sans min-h-screen antialiased overflow-hidden">
  <div class="h-screen flex overflow-hidden">
    <!-- Sidebar: sabit kalir, scroll'da altinda bosluk kalmaz -->
    <aside id="control-panel"
      class="w-80 flex-shrink-0 sticky top-0 h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-800 border-r border-slate-900/40 p-6 flex flex-col gap-4 overflow-y-auto transition-all duration-300">

      <!-- Header with Toggle Button -->
      <!-- Sticky Toggle Button Container -->
      <div class="sticky top-0 -mt-6 -mr-6 pt-4 pr-4 flex justify-end z-50 pointer-events-none">
        <button id="panel-toggle-btn"
          class="pointer-events-auto bg-slate-800/40 hover:bg-slate-700 text-white p-2 rounded-lg transition-all duration-300 border border-slate-600/30 backdrop-blur-md shadow-lg hover:opacity-100"
          title="Paneli Gizle">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7" />
          </svg>
        </button>
      </div>

      <script>
        // Scroll ile buton opaklığını ayarla
        document.getElementById('control-panel')?.addEventListener('scroll', function () {
          const btn = document.getElementById('panel-toggle-btn');
          if (this.scrollTop > 10) {
            btn.classList.add('opacity-60');
          } else {
            btn.classList.remove('opacity-60');
          }
        });
      </script>

      <!-- Header without Button -->
      <div class="flex items-start justify-between gap-2 pb-3 -mt-10 pt-6 -mx-6 px-6 mb-4 border-b border-slate-800/50">
        <div class="flex-1 pr-12">
          <p class="text-xs uppercase tracking-[0.28em] text-slate-400">Control Panel</p>
          <h1 class="text-xl font-semibold mt-1 text-white">Multi-Zone Optimizer</h1>
          <p class="text-sm text-slate-300 mt-2">Birden fazla zone için uyumlu katman dizilimleri.</p>
        </div>
      </div>

      <!-- Bölge sayısı -->
      <div class="bg-slate-800/50 rounded-lg p-3 border border-slate-700/50">
        <label class="text-sm text-slate-200 font-medium block mb-2">
          Bölge sayısı
        </label>
        <select id="zone-count-select"
          class="w-full bg-white/90 border border-slate-300/70 rounded-md px-3 py-2 text-sm text-slate-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
          <option value="2">2 Zone</option>
          <option value="3" selected>3 Zone</option>
          <option value="4">4 Zone</option>
          <option value="5">5 Zone</option>
          <option value="6">6 Zone</option>
          <option value="7">7 Zone</option>
          <option value="8">8 Zone</option>
        </select>
        <p class="text-xs text-slate-400 mt-1.5">Her zone içinde çöp kutusu ile silebilir, alttan bölge ekleyebilirsiniz
          (en az 2).</p>
      </div>

      <!-- Zone Inputs Container (dinamik olarak doldurulacak) -->
      <form id="multizone-form" class="flex flex-col gap-3">
        <div id="zone-inputs-container" class="flex flex-col gap-3">
          <!-- Zone inputs will be dynamically generated here -->
        </div>

        <div class="flex justify-center">
          <button type="button" id="zone-add-btn"
            class="px-4 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-500 text-white text-sm font-medium focus:outline-none focus:ring-2 focus:ring-emerald-400 flex items-center gap-2"
            title="Bölge ekle"><span>+</span> Bölge Ekle</button>
        </div>

        <!-- ML Surrogate Toggle -->
        <div class="flex items-center gap-2 px-2 py-1.5 rounded-lg bg-slate-800/50 border border-slate-700/50 mt-2">
          <label class="relative inline-flex items-center cursor-pointer">
            <input type="checkbox" id="ml-surrogate-toggle" class="sr-only peer">
            <div class="w-8 h-4 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-violet-600"></div>
          </label>
          <span class="text-xs text-slate-300">ML Hizlandirma</span>
          <span id="ml-status-badge" class="ml-auto text-[10px] px-1.5 py-0.5 rounded bg-slate-700 text-slate-400">Kontrol ediliyor...</span>
        </div>

        <div class="pt-2 pb-2">
          <button type="submit" id="optimize-all-btn" class="w-full button-with-icon"
            style="font-size:0.95rem; padding:8px 16px; margin:12px 0;">
            <span class="text">Optimize Et</span>
          </button>
        </div>
      </form>
      <!-- Tasarım Modu (şimdilik kaldırıldı) -->
    </aside>

    <!-- Main Content: sadece bu alan scroll olur -->
    <main class="flex-1 min-h-0 p-8 relative overflow-y-auto bg-transparent">
      <!-- Panel Open Button (hidden by default, shown when panel is closed) -->
      <button id="panel-open-btn"
        class="hidden fixed top-4 left-4 bg-slate-800 hover:bg-slate-700 text-white p-3 rounded-lg shadow-lg transition-all duration-300 z-50 border border-slate-700"
        title="Paneli Aç">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
      </button>

      <div id="loading-overlay"
        class="hidden absolute inset-0 bg-slate-900/20 backdrop-blur-sm flex flex-col items-center justify-center z-20">
        <div class="bg-white/90 border border-slate-300/60 rounded-xl p-8 max-w-md w-full shadow-xl backdrop-blur">
          <div class="flex items-center gap-3 mb-6">
            <div class="w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full animate-spin"></div>
            <div>
              <p class="text-sm font-semibold text-slate-900">Optimization in Progress</p>
              <p class="text-xs text-slate-600" id="loading-status">Initializing...</p>
            </div>
          </div>

          <div class="space-y-2">
            <div class="flex items-center gap-2 text-xs">
              <div id="rule-1-icon" class="w-4 h-4 flex items-center justify-center">⏳</div>
              <span class="text-slate-700">Rule 1: Checking Symmetry...</span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <div id="rule-2-icon" class="w-4 h-4 flex items-center justify-center">⏳</div>
              <span class="text-slate-700">Rule 2: Validating Balance...</span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <div id="rule-3-icon" class="w-4 h-4 flex items-center justify-center">⏳</div>
              <span class="text-slate-700">Rule 3: Checking Adjacency...</span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <div id="rule-4-icon" class="w-4 h-4 flex items-center justify-center">⏳</div>
              <span class="text-slate-700">Rule 4: Checking External Plies...</span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <div id="rule-5-icon" class="w-4 h-4 flex items-center justify-center">⏳</div>
              <span class="text-slate-700">Rule 5: Analyzing Distribution...</span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <div id="rule-6-icon" class="w-4 h-4 flex items-center justify-center">⏳</div>
              <span class="text-slate-700">Rule 6: Checking Grouping...</span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <div id="rule-7-icon" class="w-4 h-4 flex items-center justify-center">⏳</div>
              <span class="text-slate-700">Rule 7: Evaluating Buckling...</span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <div id="rule-8-icon" class="w-4 h-4 flex items-center justify-center">⏳</div>
              <span class="text-slate-700">Rule 8: Checking Lateral Bending...</span>
            </div>
          </div>

          <div class="mt-6 pt-4 border-t border-slate-200">
            <div class="w-full bg-slate-100 rounded-full h-2 overflow-hidden border border-slate-200">
              <div id="loading-progress" class="h-full bg-blue-600 transition-all duration-300" style="width: 0%"></div>
            </div>
            <p class="text-xs text-slate-600 mt-2 text-center" id="loading-progress-text">0%</p>
          </div>
        </div>
      </div>

      <div class="flex items-center justify-between mb-6">
        <div>
          <p class="text-xs uppercase tracking-[0.28em] text-slate-500">Mission Control</p>
          <h2 class="text-2xl font-semibold text-slate-900">Laminate Stacking Dashboard</h2>
        </div>
        <div class="text-right text-sm text-slate-600 font-mono" id="run-meta">Ready</div>
      </div>

      <!-- 2D Panel Designer (empty state replaced) -->
      <div id="empty-state"
        class="bg-white/70 backdrop-blur border border-slate-300/60 rounded-xl shadow-sm overflow-hidden">
        <!-- Toolbar -->
        <div class="flex items-center gap-2 px-4 py-2 border-b border-slate-200 bg-slate-50/80">
          <p class="text-sm font-semibold text-slate-800 mr-3">Panel Designer</p>
          <div class="w-px h-5 bg-slate-300"></div>
          <button id="pd-tool-select" class="pd-tool-btn px-2 py-1 text-xs rounded bg-slate-800 text-white"
            title="Sec / Tasi">
            <svg class="w-4 h-4 inline" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122M5.98 11.95l-2.121 2.122" />
            </svg>
            Sec
          </button>
          <button id="pd-tool-draw" class="pd-tool-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700"
            title="Dikdortgen Ciz">
            <svg class="w-4 h-4 inline" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <rect x="3" y="3" width="18" height="18" rx="2" />
            </svg>
            Bolge Ciz
          </button>
          <button id="pd-tool-delete" class="pd-tool-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700"
            title="Secili Bolgeyi Sil">
            <svg class="w-4 h-4 inline" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
            Sil
          </button>
          <div class="w-px h-5 bg-slate-300"></div>
          <button id="pd-undo-btn"
            class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-400 cursor-not-allowed transition"
            title="Geri Al (Ctrl+Z)" disabled>
            <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M3 10h10a5 5 0 015 5v2M3 10l4-4M3 10l4 4" />
            </svg>
          </button>
          <button id="pd-redo-btn"
            class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-400 cursor-not-allowed transition"
            title="Yinele (Ctrl+Y)" disabled>
            <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M21 10H11a5 5 0 00-5 5v2M21 10l-4-4M21 10l-4 4" />
            </svg>
          </button>
          <div class="w-px h-5 bg-slate-300"></div>
          <button id="pd-clear-all"
            class="px-2 py-1 text-xs rounded bg-rose-100 text-rose-700 hover:bg-rose-200 transition"
            title="Tumunu Temizle">Temizle</button>
          <div class="w-px h-5 bg-slate-300"></div>
          <button id="pd-export-btn"
            class="px-2 py-1 text-xs rounded bg-emerald-100 text-emerald-700 hover:bg-emerald-200 transition flex items-center gap-1"
            title="JSON Disa Aktar">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5 5-5M12 15V3" />
            </svg>
            Kaydet
          </button>
          <button id="pd-import-btn"
            class="px-2 py-1 text-xs rounded bg-blue-100 text-blue-700 hover:bg-blue-200 transition flex items-center gap-1"
            title="JSON Ice Aktar">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M17 8l-5-5-5 5M12 3v12" />
            </svg>
            Yukle
          </button>
          <input type="file" id="pd-import-file" accept=".json" class="hidden" />
          <div class="flex-1"></div>
          <span id="pd-region-count" class="text-xs text-slate-500">0 / 20 bolge</span>
          <button id="pd-optimize-btn" class="ml-2 button-with-icon"
            style="font-size:0.85rem; padding:6px 14px; margin:0;" disabled>
            Optimize Et
          </button>
        </div>
        <!-- Canvas area -->
        <div class="relative" style="height: calc(70vh - 44px);">
          <canvas id="pd-canvas" class="w-full h-full cursor-crosshair" style="display:block;"></canvas>
          <!-- Region edit popup (appears when region is selected) -->
          <div id="pd-region-popup"
            class="absolute hidden z-20 bg-white border border-slate-300 rounded-lg shadow-xl p-3 w-64"
            style="top:10px; right:10px;">
            <div class="flex items-center justify-between mb-2">
              <span id="pd-popup-title" class="text-sm font-semibold text-slate-800">Bolge C1</span>
              <button id="pd-popup-close"
                class="text-slate-400 hover:text-slate-600 text-lg leading-none">&times;</button>
            </div>
            <div class="grid grid-cols-2 gap-2 text-xs">
              <div>
                <label class="text-slate-600 block mb-0.5">0°</label>
                <input type="number" id="pd-ply-0" min="0" max="200" value="0"
                  class="w-full border border-slate-300 rounded px-2 py-1 text-sm focus:ring-1 focus:ring-blue-400" />
              </div>
              <div>
                <label class="text-slate-600 block mb-0.5">90°</label>
                <input type="number" id="pd-ply-90" min="0" max="200" value="0"
                  class="w-full border border-slate-300 rounded px-2 py-1 text-sm focus:ring-1 focus:ring-blue-400" />
              </div>
              <div>
                <label class="text-slate-600 block mb-0.5">+45°</label>
                <input type="number" id="pd-ply-45" min="0" max="200" value="0"
                  class="w-full border border-slate-300 rounded px-2 py-1 text-sm focus:ring-1 focus:ring-blue-400" />
              </div>
              <div>
                <label class="text-slate-600 block mb-0.5">-45°</label>
                <input type="number" id="pd-ply--45" min="0" max="200" value="0"
                  class="w-full border border-slate-300 rounded px-2 py-1 text-sm focus:ring-1 focus:ring-blue-400" />
              </div>
            </div>
            <div class="mt-2 pt-2 border-t border-slate-200 flex justify-between items-center">
              <span id="pd-popup-total" class="text-xs text-slate-500">Toplam: 0 ply</span>
              <button id="pd-popup-apply"
                class="px-2 py-1 text-xs rounded bg-blue-600 text-white hover:bg-blue-700">Uygula</button>
            </div>
          </div>
          <!-- Hint overlay when no regions -->
          <div id="pd-hint" class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none">
            <div class="text-slate-400 text-center">
              <svg class="w-12 h-12 mx-auto mb-2 text-slate-300" fill="none" stroke="currentColor" stroke-width="1.5"
                viewBox="0 0 24 24">
                <rect x="3" y="3" width="18" height="18" rx="2" />
                <path stroke-linecap="round" d="M12 8v8M8 12h8" />
              </svg>
              <p class="text-sm font-medium">"Bolge Ciz" butonuna bas ve panel uzerine dikdortgen ciz</p>
              <p class="text-xs mt-1">Her bolge bir zone olacak. Cizimden sonra ply degerlerini gir.</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Kural Oranlari paneli (Panel Designer altinda, daha buyuk + kisa aciklamalar) -->
      <div id="rule-weights-panel" class="bg-white/70 backdrop-blur border border-slate-300/60 rounded-xl shadow-sm overflow-hidden mt-4">
        <button id="rule-weights-toggle" type="button"
          class="w-full flex items-center justify-between px-6 py-4 text-left font-semibold text-slate-800 hover:bg-slate-100/80 transition border-b border-slate-200">
          <span class="text-base">Kural Oranlari (Puanlar)</span>
          <svg id="rule-weights-chevron" class="w-5 h-5 text-slate-500 transition-transform" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/>
          </svg>
        </button>
        <div id="rule-weights-content" class="px-6 py-5 hidden">
          <p class="text-sm text-slate-600 mb-5 max-w-2xl">Optimizasyon skorunda her kuralin agirligini ayarlayin. Toplam 100 civari tutulursa skor 0–100 araliginda kalir.</p>
          <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-5">
            <div class="bg-slate-50/80 border border-slate-200 rounded-lg p-4">
              <label class="text-sm font-medium text-slate-800 block mb-1">R1 — Simetri</label>
              <p class="text-xs text-slate-600 mb-2">Ic gerilmeleri dengeler, egilme/carpilma riskini azaltir.</p>
              <input type="number" id="rule-weight-R1" min="0" max="100" step="0.5" class="rule-weight-input w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-400"/>
            </div>
            <div class="bg-slate-50/80 border border-slate-200 rounded-lg p-4">
              <label class="text-sm font-medium text-slate-800 block mb-1">R2 — Denge</label>
              <p class="text-xs text-slate-600 mb-2">+45° / -45° dengesi; kuplaj ve burulmayi azaltir.</p>
              <input type="number" id="rule-weight-R2" min="0" max="100" step="0.5" class="rule-weight-input w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-400"/>
            </div>
            <div class="bg-slate-50/80 border border-slate-200 rounded-lg p-4">
              <label class="text-sm font-medium text-slate-800 block mb-1">R3 — Yuzde & Komsuluk</label>
              <p class="text-xs text-slate-600 mb-2">Aci yuzdeleri ve komsuluk; rijitlik ve hasar dayanimi.</p>
              <input type="number" id="rule-weight-R3" min="0" max="100" step="0.5" class="rule-weight-input w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-400"/>
            </div>
            <div class="bg-slate-50/80 border border-slate-200 rounded-lg p-4">
              <label class="text-sm font-medium text-slate-800 block mb-1">R4 — Dis Katmanlar</label>
              <p class="text-xs text-slate-600 mb-2">Yuzeyde uygun aci; darbe ve hasar toleransi.</p>
              <input type="number" id="rule-weight-R4" min="0" max="100" step="0.5" class="rule-weight-input w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-400"/>
            </div>
            <div class="bg-slate-50/80 border border-slate-200 rounded-lg p-4">
              <label class="text-sm font-medium text-slate-800 block mb-1">R5 — Dagilim</label>
              <p class="text-xs text-slate-600 mb-2">Acilari homojen dagitma; lokal zayifliklari azaltir.</p>
              <input type="number" id="rule-weight-R5" min="0" max="100" step="0.5" class="rule-weight-input w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-400"/>
            </div>
            <div class="bg-slate-50/80 border border-slate-200 rounded-lg p-4">
              <label class="text-sm font-medium text-slate-800 block mb-1">R6 — Gruplama</label>
              <p class="text-xs text-slate-600 mb-2">Ayni acidan cok katman yan yana olmasin; delaminasyon riski.</p>
              <input type="number" id="rule-weight-R6" min="0" max="100" step="0.5" class="rule-weight-input w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-400"/>
            </div>
            <div class="bg-slate-50/80 border border-slate-200 rounded-lg p-4">
              <label class="text-sm font-medium text-slate-800 block mb-1">R7 — Burkulma</label>
              <p class="text-xs text-slate-600 mb-2">±45° katkisi ile burkulma davranisini iyilestirir.</p>
              <input type="number" id="rule-weight-R7" min="0" max="100" step="0.5" class="rule-weight-input w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-400"/>
            </div>
            <div class="bg-slate-50/80 border border-slate-200 rounded-lg p-4">
              <label class="text-sm font-medium text-slate-800 block mb-1">R8 — Lateral Egilme</label>
              <p class="text-xs text-slate-600 mb-2">90° katmanlarin konumu; lateral egilme rijitligi.</p>
              <input type="number" id="rule-weight-R8" min="0" max="100" step="0.5" class="rule-weight-input w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-400"/>
            </div>
          </div>
          <div class="flex items-center justify-between gap-4 pt-2 flex-wrap">
            <div class="flex items-center gap-4 flex-wrap">
              <button id="rule-weights-reset" type="button" class="px-4 py-2.5 text-sm rounded-lg bg-amber-100 text-amber-800 hover:bg-amber-200 transition font-medium">Varsayilana Sifirla</button>
              <span id="rule-weights-sum" class="text-sm text-slate-600 font-medium">Toplam: 100</span>
            </div>
            <button id="rule-weights-optimize-btn" type="button" class="button-with-icon px-4 py-2.5 text-sm rounded-lg bg-slate-800 hover:bg-slate-700 text-white font-medium transition shadow-sm">
              Optimize Et
            </button>
          </div>
        </div>
      </div>

      <div id="results" class="hidden space-y-6 animate-[fadeIn_0.6s_ease]">
        <!-- Back to designer -->
        <button id="back-to-designer"
          class="flex items-center gap-2 text-sm text-blue-600 hover:text-blue-800 transition font-medium">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
          </svg>
          Panel Designer'a Don
        </button>
        <!-- Zone Score Cards -->
        <div id="zone-score-cards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          <!-- JS ile doldurulacak -->
        </div>
        <div class="text-xs text-slate-500 -mt-2" id="stats-meta-row">
          <span id="stats-meta"></span>
        </div>

        <!-- Gizli uyumluluk elemanlari -->
        <div class="hidden" aria-hidden="true">
          <span id="fitness-score">--</span>
          <span id="symmetry-penalty">--</span>
          <span id="balance-score">--</span>
          <span id="fitness-hint"></span>
          <span id="symmetry-hint"></span>
          <span id="balance-hint"></span>
          <div id="penalty-list"></div>
          <div id="summary-runtime">--</div>
          <div id="summary-params">--</div>
          <div id="summary-master">--</div>
          <div id="summary-dropoff">--</div>
        </div>

        <!-- Zone Detail Modal -->
        <div id="zone-detail-modal" class="fixed inset-0 z-50 hidden">
          <div class="absolute inset-0 bg-black/50 backdrop-blur-sm" id="zone-modal-backdrop"></div>
          <div class="absolute inset-0 flex items-center justify-center p-4">
            <div
              class="bg-white rounded-2xl shadow-2xl w-full max-w-5xl max-h-[90vh] overflow-hidden flex flex-col relative">
              <div
                class="flex items-center justify-between px-6 py-4 border-b border-slate-200 bg-gradient-to-r from-slate-800 to-slate-700">
                <div>
                  <h3 id="zone-modal-title" class="text-lg font-bold text-white">Zone 1</h3>
                  <p id="zone-modal-subtitle" class="text-sm text-slate-300 mt-0.5">34 ply · Fitness: 95.7 / 100</p>
                </div>
                <button id="zone-modal-close"
                  class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-white/20 text-slate-300 hover:text-white transition text-xl">&times;</button>
              </div>
              <div class="flex-1 overflow-y-auto p-6">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  <!-- Penalty Breakdown -->
                  <div>
                    <p class="text-sm font-semibold text-slate-900 mb-1">Penalty Breakdown</p>
                    <p class="text-xs text-slate-500 mb-3">Ceza puanları ve gerekçeleri (örn. simetri bozulması, aşırı
                      grup, dış katmanda 45° eksikliği).</p>
                    <div id="zone-modal-penalties" class="space-y-2 text-sm"></div>
                  </div>
                  <!-- Kuralların Amacı -->
                  <div>
                    <p class="text-sm font-semibold text-slate-900 mb-1 uppercase tracking-wide">Kuralların Amacı</p>
                    <p class="text-xs text-slate-500 mb-3">Her kuralın "ne işe yaradığı" (mühendislik gerekçesi).</p>
                    <div class="space-y-2 text-sm">
                      <div class="bg-slate-50/70 border border-slate-200 rounded-lg p-3">
                        <div class="font-semibold text-slate-900">R1 — Symmetry (Simetri)</div>
                        <div class="text-slate-700 mt-1 text-xs leading-relaxed">İç gerilmeleri dengeler,
                          eğilme/çarpılma riskini azaltır ve üretim sonrası stabiliteyi artırır.</div>
                      </div>
                      <div class="bg-slate-50/70 border border-slate-200 rounded-lg p-3">
                        <div class="font-semibold text-slate-900">R2 — Balance (Denge)</div>
                        <div class="text-slate-700 mt-1 text-xs leading-relaxed">+45° ve −45° dengesini sağlayarak
                          kuplaj (twist/bend coupling) etkilerini ve istenmeyen burulmayı azaltır.</div>
                      </div>
                      <div class="bg-slate-50/70 border border-slate-200 rounded-lg p-3">
                        <div class="font-semibold text-slate-900">R3 — Percentage / Adjacency (Yüzde & Komşuluk)</div>
                        <div class="text-slate-700 mt-1 text-xs leading-relaxed">Açı yüzdeleriyle rijitlik/taşıma
                          dengesi kurar; komşuluk kontrolüyle ani yön değişimlerini azaltıp hasar dayanımını
                          iyileştirir.</div>
                      </div>
                      <div class="bg-slate-50/70 border border-slate-200 rounded-lg p-3">
                        <div class="font-semibold text-slate-900">R4 — External Plies (Dış Katmanlar)</div>
                        <div class="text-slate-700 mt-1 text-xs leading-relaxed">Yüzeyde uygun açı seçimiyle darbe/hasar
                          toleransı artar ve dış kabukta daha güvenli bir "skin" davranışı sağlanır.</div>
                      </div>
                      <div class="bg-slate-50/70 border border-slate-200 rounded-lg p-3">
                        <div class="font-semibold text-slate-900">R5 — Distribution (Dağılım)</div>
                        <div class="text-slate-700 mt-1 text-xs leading-relaxed">Açıları laminat boyunca homojen
                          dağıtarak lokal zayıflıkları ve performans dalgalanmalarını azaltır.</div>
                      </div>
                      <div class="bg-slate-50/70 border border-slate-200 rounded-lg p-3">
                        <div class="font-semibold text-slate-900">R6 — Grouping / Contiguity (Gruplama)</div>
                        <div class="text-slate-700 mt-1 text-xs leading-relaxed">Aynı açıdan çok sayıda katmanı yan yana
                          getirmeyerek delaminasyon, çatlak ilerlemesi ve üretim risklerini düşürür.</div>
                      </div>
                      <div class="bg-slate-50/70 border border-slate-200 rounded-lg p-3">
                        <div class="font-semibold text-slate-900">R7 — Buckling (Burkulma)</div>
                        <div class="text-slate-700 mt-1 text-xs leading-relaxed">Uç/ince bölgelerde ±45° katkısı ile
                          burkulma davranışını iyileştirir; özellikle yük transferi ve stabilite için kritiktir.</div>
                      </div>
                      <div class="bg-slate-50/70 border border-slate-200 rounded-lg p-3">
                        <div class="font-semibold text-slate-900">R8 — Lateral Bending (Lateral Eğilme)</div>
                        <div class="text-slate-700 mt-1 text-xs leading-relaxed">90° katmanların konumu ile lateral
                          eğilme rijitliği yönetilir; katmanların orta düzleme yakınlığı/uzaklığı performansı etkiler.
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- 3D Composite Panel Views -->
        <div id="view3d-card"
          class="bg-white/70 backdrop-blur border border-slate-300/60 rounded-xl p-4 shadow-sm hidden">
          <!-- Header + Tab buttons -->
          <div class="flex items-center justify-between mb-3">
            <div class="flex items-center gap-3">
              <div class="flex bg-slate-200 rounded-lg p-0.5">
                <button id="tab-stacking"
                  class="view3d-tab px-3 py-1.5 text-xs font-semibold rounded-md text-slate-600 hover:bg-slate-300 transition-all">Stacking
                  View</button>
                <button id="tab-panel3d"
                  class="view3d-tab px-3 py-1.5 text-xs font-semibold rounded-md bg-slate-800 text-white transition-all">Panel
                  3D</button>
              </div>
              <div>
                <p id="view3d-title" class="text-sm font-semibold text-slate-900">Panel 3D — Zone Map</p>
                <p id="view3d-subtitle" class="text-xs text-slate-600 mt-0.5">2D ciziminizin 3D modeli | Her zone kalinligina gore yukseklik alir</p>
              </div>
            </div>
            <div id="view3d-legend" class="flex gap-3 text-xs items-center"></div>
          </div>

          <!-- === STACKING VIEW controls + canvas === -->
          <div id="stacking-pane" class="hidden">
            <div class="flex items-center gap-2 mb-3 flex-wrap">
              <div class="flex gap-1">
                <button data-cam="iso"
                  class="view3d-cam-btn px-2 py-1 text-xs rounded bg-slate-800 text-white hover:bg-slate-700 transition">Izometrik</button>
                <button data-cam="top"
                  class="view3d-cam-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition">Ust</button>
                <button data-cam="front"
                  class="view3d-cam-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition">On</button>
                <button data-cam="side"
                  class="view3d-cam-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition">Yan</button>
              </div>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <div class="flex items-center gap-2">
                <label class="text-xs text-slate-600 whitespace-nowrap">Exploded View:</label>
                <input id="exploded-slider" type="range" min="0" max="100" value="0"
                  class="w-28 h-1 accent-blue-600 cursor-pointer" />
                <span id="exploded-value" class="text-xs text-slate-500 w-8">0%</span>
              </div>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <button id="export-png-btn"
                class="px-2 py-1 text-xs rounded bg-blue-600 text-white hover:bg-blue-700 transition flex items-center gap-1">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5 5-5M12 15V3" />
                </svg>
                PNG
              </button>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <button id="stacking-autorotate-btn"
                class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1"
                title="Otomatik Dondur">
                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                Don
              </button>
              <button id="stacking-wireframe-btn"
                class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1"
                title="Wireframe / X-Ray">
                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 3v18m6-18v18M3 9h18M3 15h18" />
                </svg>
                X-Ray
              </button>
              <button id="stacking-reset-isolation-btn"
                class="px-2 py-1 text-xs rounded bg-amber-100 text-amber-700 hover:bg-amber-200 transition hidden"
                title="Tum Katmanlari Goster">
                Tumunu Goster
              </button>
              <div class="ml-auto flex items-center gap-2">
                <button id="stacking-to-p3-btn"
                  class="fullscreen-switch-btn hidden px-3 py-1 text-xs font-bold rounded bg-amber-600 text-white hover:bg-amber-700 transition items-center gap-2 border border-amber-500 shadow-lg">
                  <span>Panel 3D &rarr;</span>
                </button>
                <button id="stacking-fullscreen-btn"
                  class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition"
                  title="Tam Ekran">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round"
                      d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5" />
                  </svg>
                </button>
              </div>
            </div>
            <div id="view3d-container" class="w-full rounded-lg overflow-hidden border border-slate-200 relative"
              style="height:480px;">
              <div id="view3d-tooltip"
                class="absolute pointer-events-none hidden z-10 bg-slate-900/90 text-white text-xs rounded-lg px-3 py-2 shadow-lg backdrop-blur"
                style="max-width:260px;"></div>
              <!-- Stats Overlay (Glassmorphism) -->
              <div id="stacking-stats-overlay"
                class="absolute top-3 right-3 z-10 bg-slate-900/80 backdrop-blur-md border border-slate-700/50 rounded-lg px-3 py-2 text-xs text-slate-200 shadow-lg hidden"
                style="min-width:140px;">
                <div
                  class="font-semibold text-white mb-1 text-[11px] uppercase tracking-wide border-b border-slate-700/50 pb-1">
                  Stacking Stats</div>
                <div id="stats-zone-count" class="flex justify-between"><span class="text-slate-400">Zone
                    Sayisi:</span><span class="font-mono text-cyan-400 font-bold">—</span></div>
                <div id="stats-max-ply" class="flex justify-between"><span class="text-slate-400">Max Ply:</span><span
                    class="font-mono text-cyan-400 font-bold">—</span></div>
                <div id="stats-thickness" class="flex justify-between"><span
                    class="text-slate-400">Kalınlık:</span><span class="font-mono text-cyan-400 font-bold">—</span>
                </div>
              </div>
            </div>
          </div>

          <!-- === PANEL 3D (Zone Map) controls + canvas === -->
          <div id="panel3d-pane">
            <div class="flex items-center gap-2 mb-3 flex-wrap">
              <div class="flex gap-1">
                <button data-p3cam="iso"
                  class="panel3d-cam-btn px-2 py-1 text-xs rounded bg-slate-800 text-white hover:bg-slate-700 transition">Izometrik</button>
                <button data-p3cam="top"
                  class="panel3d-cam-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition">Ust</button>
                <button data-p3cam="front"
                  class="panel3d-cam-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition">On</button>
                <button data-p3cam="side"
                  class="panel3d-cam-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition">Yan</button>
              </div>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <div class="flex items-center gap-2">
                <label class="text-xs text-slate-600 whitespace-nowrap">Katman Ayir:</label>
                <input id="panel3d-explode-slider" type="range" min="0" max="100" value="0"
                  class="w-28 h-1 accent-indigo-600 cursor-pointer" />
                <span id="panel3d-explode-value" class="text-xs text-slate-500 w-8">0%</span>
              </div>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <button id="p3-wing-mode-btn"
                class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1"
                title="Kanat Gorunumu / Duz Panel">
                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Wing
              </button>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <button id="export-panel3d-png"
                class="px-2 py-1 text-xs rounded bg-indigo-600 text-white hover:bg-indigo-700 transition flex items-center gap-1">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5 5-5M12 15V3" />
                </svg>
                PNG
              </button>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <button id="p3-autorotate-btn"
                class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1"
                title="Otomatik Dondur">
                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                Don
              </button>
              <button id="p3-wireframe-btn"
                class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1"
                title="Wireframe / X-Ray">
                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 3v18m6-18v18M3 9h18M3 15h18" />
                </svg>
                X-Ray
              </button>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <!-- Tema Toggle: Açık / Koyu -->
              <button id="p3-theme-btn"
                class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1"
                title="Açık / Koyu Tema">
                <!-- Güneş ikonu (açık tema = aktif değil → güneşe tıkla = geç) -->
                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <circle cx="12" cy="12" r="5"/>
                  <line x1="12" y1="1" x2="12" y2="3" stroke-linecap="round"/>
                  <line x1="12" y1="21" x2="12" y2="23" stroke-linecap="round"/>
                  <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" stroke-linecap="round"/>
                  <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" stroke-linecap="round"/>
                  <line x1="1" y1="12" x2="3" y2="12" stroke-linecap="round"/>
                  <line x1="21" y1="12" x2="23" y2="12" stroke-linecap="round"/>
                  <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" stroke-linecap="round"/>
                  <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" stroke-linecap="round"/>
                </svg>
                Açık
              </button>
              <div class="ml-auto flex items-center gap-2">
                <button id="p3-to-stacking-btn"
                  class="fullscreen-switch-btn hidden px-3 py-1 text-xs font-bold rounded bg-amber-600 text-white hover:bg-amber-700 transition items-center gap-2 border border-amber-500 shadow-lg">
                  <span>&larr; Stacking View</span>
                </button>
                <button id="p3-fullscreen-btn"
                  class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition"
                  title="Tam Ekran">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round"
                      d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5" />
                  </svg>
                </button>
              </div>
            </div>
            <div id="panel3d-container" class="w-full rounded-lg overflow-hidden border border-slate-200 relative"
              style="height:480px;">
              <div id="panel3d-tooltip"
                class="absolute pointer-events-none hidden z-10 bg-slate-900/90 text-white text-xs rounded-lg px-3 py-2 shadow-lg backdrop-blur border border-slate-700/50"
                style="max-width:260px;"></div>
              <!-- Stats Overlay (Glassmorphism) -->
              <div id="p3-stats-overlay"
                class="absolute top-3 right-3 z-10 bg-slate-900/80 backdrop-blur-md border border-slate-700/50 rounded-lg px-3 py-2 text-xs text-slate-200 shadow-lg hidden"
                style="min-width:140px;">
                <div
                  class="font-semibold text-white mb-1 text-[11px] uppercase tracking-wide border-b border-slate-700/50 pb-1">
                  Zone Bilgisi</div>
                <div id="p3-stats-zones" class="flex justify-between"><span class="text-slate-400">Zone:</span><span
                    class="font-mono text-cyan-400 font-bold">—</span></div>
                <div id="p3-stats-ply" class="flex justify-between"><span class="text-slate-400">Max Ply:</span><span
                    class="font-mono text-cyan-400 font-bold">—</span></div>
                <div id="p3-stats-thick" class="flex justify-between"><span class="text-slate-400">Kalınlık:</span><span
                    class="font-mono text-cyan-400 font-bold">—</span></div>
                <div id="p3-stats-fps" class="flex justify-between border-t border-slate-700/50 pt-1 mt-1"><span
                    class="text-slate-400">FPS:</span><span class="font-mono text-green-400 font-bold">—</span></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Cross-Section View Card -->
        <div id="cross-section-card"
          class="bg-white/70 backdrop-blur border border-slate-300/60 rounded-xl p-5 shadow-sm hidden">
          <div class="flex items-center justify-between mb-4">
            <div>
              <h3 class="text-sm font-bold text-slate-900 flex items-center gap-2">
                <svg class="w-4 h-4 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
                Cross-Section View (Kesit Görünümü)
              </h3>
              <p class="text-xs text-slate-600 mt-1">Her katmanın kalınlık ve pozisyonunu 2D olarak gösterir</p>
            </div>
            <div class="flex gap-2">
              <select id="cross-section-zone-selector"
                class="text-xs px-2 py-1 border border-slate-300 rounded bg-white">
                <option value="0">Zone 1</option>
              </select>
              <button id="cross-section-export-svg"
                class="px-2 py-1 text-xs rounded bg-indigo-600 text-white hover:bg-indigo-700 transition">
                SVG
              </button>
              <button id="cross-section-export-png"
                class="px-2 py-1 text-xs rounded bg-indigo-600 text-white hover:bg-indigo-700 transition">
                PNG
              </button>
            </div>
          </div>
          <div class="bg-slate-50 rounded-lg p-3 border border-slate-200">
            <canvas id="cross-section-canvas" class="w-full" style="max-height: 500px;"></canvas>
            <div id="cross-section-tooltip"
              class="hidden absolute bg-slate-900 text-white text-xs px-3 py-2 rounded shadow-lg pointer-events-none z-10">
            </div>
          </div>
          <div class="mt-3 text-xs text-slate-600 flex items-center gap-4">
            <span><strong>Total:</strong> <span id="cross-section-total">—</span></span>
            <span><strong>Thickness:</strong> <span id="cross-section-thickness">—</span></span>
            <span class="text-slate-400">Hover for details</span>
          </div>
        </div>

        <!-- Ply Coverage Map Card -->
        <div id="ply-coverage-card"
          class="bg-white/70 backdrop-blur border border-slate-300/60 rounded-xl p-5 shadow-sm hidden">
          <div class="flex items-center justify-between mb-4">
            <div>
              <h3 class="text-sm font-bold text-slate-900 flex items-center gap-2">
                <svg class="w-4 h-4 text-emerald-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
                Ply Coverage Map (Katman Kapsama Haritası)
              </h3>
              <p class="text-xs text-slate-600 mt-1">Zone'lara göre hangi katmanların var/yok olduğunu gösterir</p>
            </div>
          </div>
          <div class="bg-slate-50 rounded-lg p-3 border border-slate-200 overflow-x-auto">
            <div id="ply-coverage-container" class="min-w-max"></div>
          </div>
          <div class="mt-3 flex items-center gap-3 text-xs">
            <span class="flex items-center gap-1">
              <span class="w-3 h-3 rounded bg-emerald-500"></span> Ply exists
            </span>
            <span class="flex items-center gap-1">
              <span class="w-3 h-3 rounded bg-slate-300"></span> Ply dropped
            </span>
            <span class="text-slate-400 ml-auto">Click column to highlight</span>
          </div>
        </div>

        <!-- Laminate Map -->
        <div class="bg-white/70 backdrop-blur border border-slate-300/60 rounded-xl p-4 shadow-sm">
          <div class="flex items-center justify-between mb-4">
            <div>
              <p class="text-sm font-semibold text-slate-900">Laminate Map (Drop-Off)</p>
              <p class="text-xs text-slate-600 mt-1">Katmanları sürükle-bırak ile taşıyabilirsiniz</p>
            </div>
            <div class="flex gap-2 text-xs text-slate-600 items-center">
              <!-- Yatay / Dikey Toggle -->
              <div id="laminate-view-toggle" class="flex rounded-lg border border-slate-300 overflow-hidden shadow-sm">
                <button id="view-horizontal-btn" class="px-2.5 py-1.5 text-xs font-semibold transition flex items-center gap-1 bg-white text-slate-500 hover:bg-slate-50" title="Yatay Görünüm">
                  <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"/></svg>
                  Yatay
                </button>
                <button id="view-vertical-btn" class="px-2.5 py-1.5 text-xs font-semibold transition flex items-center gap-1 bg-slate-800 text-white" title="Dikey Görünüm">
                  <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 4v16M12 4v16M18 4v16"/></svg>
                  Dikey
                </button>
              </div>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <button id="export-excel-btn"
                class="px-3 py-1.5 text-xs rounded-lg bg-emerald-600 text-white hover:bg-emerald-700 transition flex items-center gap-1.5 font-semibold shadow-sm">
                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5 5-5M12 15V3" />
                </svg>
                Excel'e Aktar
              </button>
              <button id="export-pdf-btn"
                class="px-3 py-1.5 text-xs rounded-lg bg-red-600 text-white hover:bg-red-700 transition flex items-center gap-1.5 font-semibold shadow-sm">
                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                </svg>
                PDF Rapor
              </button>
              <div class="w-px h-5 bg-slate-300 mx-1"></div>
              <span class="flex items-center gap-1"><span class="w-3 h-3 bg-emerald-500 inline-block"></span>0°</span>
              <span class="flex items-center gap-1"><span class="w-3 h-3 bg-sky-500 inline-block"></span>90°</span>
              <span class="flex items-center gap-1"><span class="w-3 h-3 bg-rose-500 inline-block"></span>+45°</span>
              <span class="flex items-center gap-1"><span class="w-3 h-3 bg-amber-500 inline-block"></span>-45°</span>
              <span class="flex items-center gap-1 ml-2 border-l border-slate-200 pl-2"><span
                  class="w-[3px] h-4 bg-amber-500 inline-block shadow-[0_0_6px_rgba(245,158,11,0.35)]"></span>Simetri
                Ekseni</span>
            </div>
          </div>
          <div id="laminate-map" class="mt-4 flex flex-col gap-3"></div>

          <!-- İyileştirme Önerileri Bloğu -->
          <div id="improvement-suggestions" class="hidden mt-6"></div>

          <!-- Zone Management Panel -->
          <div id="zone-management-section" class="mt-6 pt-6 border-t border-slate-200 hidden">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-bold text-slate-900">Zone Yönetimi (Şematik Tasarım)</h3>
              <button id="init-root-zone-btn" class="button-with-icon btn-slate">
                <span class="text">Root Zone'u Başlat</span>
              </button>
            </div>

            <!-- Zone Diagram -->
            <div id="zone-diagram"
              class="bg-slate-200/30 border border-slate-300/60 rounded-lg p-6 mb-4 min-h-[400px] shadow-sm backdrop-blur">
              <div class="text-slate-500 text-center py-20">
                Zone diyagramı burada görüntülenecek
              </div>
            </div>

            <!-- Zone Birleştir -->
            <div class="bg-white/70 backdrop-blur border border-slate-300/60 rounded-lg p-4 shadow-sm mb-4">
              <h4 class="text-sm font-semibold text-slate-800 mb-3">Zone Birleştir</h4>
              <div class="space-y-3">
                <div>
                  <label class="text-xs text-slate-600 block mb-1">Birleştirilecek Zone'lar (Çoklu Seçim)</label>
                  <select id="merge-zones-select" multiple
                    class="w-full bg-white border border-slate-300 rounded-md px-3 py-2 text-sm text-slate-900 min-h-[80px] focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    <option value="">Zone seçiniz...</option>
                  </select>
                  <button id="create-zone-merge-btn" class="w-full button-with-icon btn-purple">
                    <span class="text">Birleştirme ile Zone Oluştur</span>
                  </button>
                </div>
              </div>
            </div>

            <!-- zone-list ID'si JS için gerekli; UI'de gizli tutuyoruz -->
            <div id="zone-list" class="hidden"></div>
          </div>

          <!-- Drop-Off bolumu kaldirild, gizli elemanlar JS uyumlulugu icin korunuyor -->
          <div class="hidden">
            <span id="current-ply-count">--</span>
            <select id="dropoff-source-zone-select">
              <option value="master"></option>
            </select>
            <div id="plan-schematic"></div>
            <input type="number" id="dropoff-angle-0" />
            <input type="number" id="dropoff-angle-90" />
            <input type="number" id="dropoff-angle-45" />
            <input type="number" id="dropoff-angle-m45" />
            <button id="apply-dropoff-angle-btn"></button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // API base URL: her zaman relative (aynı sunucuda Flask çalışıyor)
    const API_BASE = '';

    // Multi-zone elements
    const zoneCountSelect = document.getElementById('zone-count-select');
    const zoneInputsContainer = document.getElementById('zone-inputs-container');
    const multizoneForm = document.getElementById('multizone-form');

    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingStatus = document.getElementById('loading-status');
    const loadingProgress = document.getElementById('loading-progress');
    const loadingProgressText = document.getElementById('loading-progress-text');
    const emptyState = document.getElementById('empty-state');
    const resultsSection = document.getElementById('results');
    const fitnessScoreEl = document.getElementById('fitness-score');
    const symmetryPenaltyEl = document.getElementById('symmetry-penalty');
    const balanceScoreEl = document.getElementById('balance-score');
    const fitnessHintEl = document.getElementById('fitness-hint');
    const symmetryHintEl = document.getElementById('symmetry-hint');
    const balanceHintEl = document.getElementById('balance-hint');
    const penaltyListEl = document.getElementById('penalty-list');
    const statsMetaEl = document.getElementById('stats-meta');
    const runMetaEl = document.getElementById('run-meta');
    const laminateMapEl = document.getElementById('laminate-map');
    const summaryParamsEl = document.getElementById('summary-params');
    const summaryMasterEl = document.getElementById('summary-master');
    const summaryDropEl = document.getElementById('summary-dropoff');
    const summaryRuntimeEl = document.getElementById('summary-runtime');
    const dropoffTargetInput = document.getElementById('dropoff-target-input');
    const applyDropoffBtn = document.getElementById('apply-dropoff-btn');
    const currentPlyCountEl = document.getElementById('current-ply-count');
    let chartInstance = null;
    let progressInterval = null;
    let currentMasterSequence = null;
    let originalMasterSequence = null;
    let currentPlyCounts = null;
    let dropOffResults = [];
    let multiZoneResults = null; // Multi-zone sonuçları için

    // ========== PANEL DESIGNER (2D Region Editor) ==========
    const pdCanvas = document.getElementById('pd-canvas');
    const pdCtx = pdCanvas ? pdCanvas.getContext('2d') : null;
    const pdRegionPopup = document.getElementById('pd-region-popup');
    const pdHint = document.getElementById('pd-hint');
    const pdRegionCount = document.getElementById('pd-region-count');
    const pdOptimizeBtn = document.getElementById('pd-optimize-btn');

    const PD_COLORS = [
      '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16',
      '#f97316', '#6366f1', '#14b8a6', '#e11d48', '#a855f7', '#0ea5e9', '#eab308', '#d946ef',
      '#22c55e', '#f43f5e', '#2563eb', '#78716c'
    ];
    let pdRegions = []; // { id, x, y, w, h, color, label, plyCounts: {0,90,45,-45} }
    let pdNextId = 1;
    let pdTool = 'select'; // 'select' | 'draw' | 'delete'
    let pdSelectedIdx = -1;
    let pdDrawing = false;
    let pdDrawStart = null;
    let pdDragging = false;
    let pdDragOffset = null;
    let pdDropOffTree = null;  // Optimize sonrası: {childIdx: parentIdx, ...}
    window._disconnectedZones = null; // Bağlantısız zone index'leri

    // ===== Komşuluk (Adjacency) Hesaplama =====
    function rectsAdjacent(r1, r2, threshold) {
      const x1 = r1.x, y1 = r1.y, x1b = r1.x + r1.w, y1b = r1.y + r1.h;
      const x2 = r2.x, y2 = r2.y, x2b = r2.x + r2.w, y2b = r2.y + r2.h;
      const hOverlap = Math.max(0, Math.min(x1b, x2b) - Math.max(x1, x2));
      const vOverlap = Math.max(0, Math.min(y1b, y2b) - Math.max(y1, y2));
      const hGap = Math.max(x1, x2) - Math.min(x1b, x2b);
      if (vOverlap > 0 && hGap >= 0 && hGap <= threshold) return true;
      const vGap = Math.max(y1, y2) - Math.min(y1b, y2b);
      if (hOverlap > 0 && vGap >= 0 && vGap <= threshold) return true;
      return false;
    }
    function computeNeighborPairs(regions, threshold) {
      const pairs = [];
      for (let i = 0; i < regions.length; i++) {
        for (let j = i + 1; j < regions.length; j++) {
          if (rectsAdjacent(regions[i], regions[j], threshold)) pairs.push([i, j]);
        }
      }
      return pairs;
    }

    // Undo/Redo stacks
    const pdUndoStack = [];
    const pdRedoStack = [];
    const PD_MAX_UNDO = 50;

    // Kural oranlari (backend ile ayni varsayilanlar)
    const DEFAULT_RULE_WEIGHTS = { R1: 18, R2: 12, R3: 13, R4: 12, R5: 14, R6: 20.5, R7: 3.5, R8: 7 };

    function getRuleWeights() {
      const out = {};
      ['R1','R2','R3','R4','R5','R6','R7','R8'].forEach(key => {
        const el = document.getElementById('rule-weight-' + key);
        const v = el ? parseFloat(el.value) : NaN;
        out[key] = isNaN(v) || v < 0 ? DEFAULT_RULE_WEIGHTS[key] : v;
      });
      return out;
    }

    function setRuleWeightsToDefaults() {
      ['R1','R2','R3','R4','R5','R6','R7','R8'].forEach(key => {
        const el = document.getElementById('rule-weight-' + key);
        if (el) el.value = DEFAULT_RULE_WEIGHTS[key];
      });
      updateRuleWeightsSum();
    }

    function updateRuleWeightsSum() {
      const sumEl = document.getElementById('rule-weights-sum');
      if (!sumEl) return;
      const w = getRuleWeights();
      const total = Object.values(w).reduce((a, b) => a + b, 0);
      sumEl.textContent = 'Toplam: ' + (Math.round(total * 10) / 10);
    }

    function pdInit() {
      if (!pdCanvas) return;
      pdResize();
      window.addEventListener('resize', pdResize);

      // Tool buttons
      document.getElementById('pd-tool-select')?.addEventListener('click', () => pdSetTool('select'));
      document.getElementById('pd-tool-draw')?.addEventListener('click', () => pdSetTool('draw'));
      document.getElementById('pd-tool-delete')?.addEventListener('click', () => pdDeleteSelected());
      document.getElementById('pd-clear-all')?.addEventListener('click', pdClearAll);
      document.getElementById('pd-export-btn')?.addEventListener('click', pdExportDesign);
      document.getElementById('pd-import-btn')?.addEventListener('click', () => document.getElementById('pd-import-file')?.click());
      document.getElementById('pd-import-file')?.addEventListener('change', pdImportDesign);
      document.getElementById('pd-undo-btn')?.addEventListener('click', pdUndo);
      document.getElementById('pd-redo-btn')?.addEventListener('click', pdRedo);
      document.getElementById('pd-popup-close')?.addEventListener('click', () => { pdRegionPopup.classList.add('hidden'); });

      // Keyboard shortcuts for undo/redo
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          pdUndo();
        } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
          e.preventDefault();
          pdRedo();
        }
      });
      document.getElementById('pd-popup-apply')?.addEventListener('click', pdApplyPopup);
      pdOptimizeBtn?.addEventListener('click', pdRunOptimize);

      // Kural oranlari paneli: ac/kapa, sifirla, toplam guncelle
      const rwToggle = document.getElementById('rule-weights-toggle');
      const rwContent = document.getElementById('rule-weights-content');
      const rwChevron = document.getElementById('rule-weights-chevron');
      if (rwToggle && rwContent) {
        rwToggle.addEventListener('click', () => {
          const isHidden = rwContent.classList.contains('hidden');
          rwContent.classList.toggle('hidden', !isHidden);
          if (rwChevron) rwChevron.style.transform = isHidden ? '' : 'rotate(-90deg)';
        });
      }
      document.getElementById('rule-weights-reset')?.addEventListener('click', setRuleWeightsToDefaults);
      document.getElementById('rule-weights-optimize-btn')?.addEventListener('click', () => {
        if (typeof pdRunOptimize === 'function') pdRunOptimize();
        else if (document.getElementById('pd-optimize-btn')) document.getElementById('pd-optimize-btn').click();
      });
      document.querySelectorAll('.rule-weight-input').forEach(inp => {
        inp.addEventListener('input', updateRuleWeightsSum);
      });
      setRuleWeightsToDefaults();
      if (rwChevron) rwChevron.style.transform = 'rotate(-90deg)';

      // Ply input live total
      ['pd-ply-0', 'pd-ply-90', 'pd-ply-45', 'pd-ply--45'].forEach(id => {
        document.getElementById(id)?.addEventListener('input', pdUpdatePopupTotal);
      });

      // Canvas events
      pdCanvas.addEventListener('pointerdown', pdOnPointerDown);
      pdCanvas.addEventListener('pointermove', pdOnPointerMove);
      pdCanvas.addEventListener('pointerup', pdOnPointerUp);

      pdRender();
    }

    function pdResize() {
      if (!pdCanvas) return;
      const parent = pdCanvas.parentElement;
      pdCanvas.width = parent.clientWidth;
      pdCanvas.height = parent.clientHeight;
      pdRender();
    }

    function pdSetTool(tool) {
      pdTool = tool;
      ['pd-tool-select', 'pd-tool-draw', 'pd-tool-delete'].forEach(id => {
        const btn = document.getElementById(id);
        if (!btn) return;
        const active = (id === 'pd-tool-' + tool);
        btn.className = 'pd-tool-btn px-2 py-1 text-xs rounded transition ' +
          (active ? 'bg-slate-800 text-white' : 'bg-slate-200 text-slate-700 hover:bg-slate-300');
      });
      pdCanvas.style.cursor = tool === 'draw' ? 'crosshair' : (tool === 'delete' ? 'not-allowed' : 'default');
    }

    function pdGetCanvasPos(e) {
      const rect = pdCanvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    function pdHitTest(pos) {
      // Return index of region under pos (last = topmost)
      for (let i = pdRegions.length - 1; i >= 0; i--) {
        const r = pdRegions[i];
        if (pos.x >= r.x && pos.x <= r.x + r.w && pos.y >= r.y && pos.y <= r.y + r.h) return i;
      }
      return -1;
    }

    function pdOnPointerDown(e) {
      const pos = pdGetCanvasPos(e);

      if (pdTool === 'draw') {
        if (pdRegions.length >= 20) { alert('Maksimum 20 bolge olusturulabilir.'); return; }
        pdDrawing = true;
        pdDrawStart = pos;
        pdCanvas.setPointerCapture(e.pointerId);
      } else if (pdTool === 'select') {
        const hit = pdHitTest(pos);
        if (hit >= 0) {
          pdSelectedIdx = hit;
          pdDragging = true;
          pdSaveState(); // Save state before drag
          pdDragOffset = { x: pos.x - pdRegions[hit].x, y: pos.y - pdRegions[hit].y };
          pdCanvas.setPointerCapture(e.pointerId);
          pdShowPopup(hit);
        } else {
          pdSelectedIdx = -1;
          pdRegionPopup.classList.add('hidden');
        }
        pdRender();
      } else if (pdTool === 'delete') {
        const hit = pdHitTest(pos);
        if (hit >= 0) {
          pdSaveState(); // Save state before delete
          pdRegions.splice(hit, 1);
          pdSelectedIdx = -1;
          pdRegionPopup.classList.add('hidden');
          pdUpdateUI();
          pdRender();
        }
      }
    }

    function pdOnPointerMove(e) {
      const pos = pdGetCanvasPos(e);

      if (pdTool === 'draw' && pdDrawing) {
        pdRender();
        // Draw preview rectangle (snapped to grid)
        const CELL = 40;
        const x = Math.round(Math.min(pos.x, pdDrawStart.x) / CELL) * CELL;
        const y = Math.round(Math.min(pos.y, pdDrawStart.y) / CELL) * CELL;
        const x2 = Math.round(Math.max(pos.x, pdDrawStart.x) / CELL) * CELL;
        const y2 = Math.round(Math.max(pos.y, pdDrawStart.y) / CELL) * CELL;
        const w = x2 - x;
        const h = y2 - y;
        pdCtx.save();
        pdCtx.strokeStyle = '#3b82f6';
        pdCtx.lineWidth = 2;
        pdCtx.setLineDash([6, 3]);
        pdCtx.strokeRect(x, y, w, h);
        pdCtx.fillStyle = 'rgba(59,130,246,0.08)';
        pdCtx.fillRect(x, y, w, h);
        pdCtx.restore();
      } else if (pdTool === 'select' && pdDragging && pdSelectedIdx >= 0) {
        const r = pdRegions[pdSelectedIdx];
        const CELL = 40;
        const rawX = pos.x - pdDragOffset.x;
        const rawY = pos.y - pdDragOffset.y;
        r.x = Math.round(Math.max(0, Math.min(rawX, pdCanvas.width - r.w)) / CELL) * CELL;
        r.y = Math.round(Math.max(0, Math.min(rawY, pdCanvas.height - r.h)) / CELL) * CELL;
        pdRender();
      }
    }

    function pdOnPointerUp(e) {
      if (pdTool === 'draw' && pdDrawing) {
        pdDrawing = false;
        const pos = pdGetCanvasPos(e);
        const CELL = 40;
        const x = Math.round(Math.min(pos.x, pdDrawStart.x) / CELL) * CELL;
        const y = Math.round(Math.min(pos.y, pdDrawStart.y) / CELL) * CELL;
        const x2 = Math.round(Math.max(pos.x, pdDrawStart.x) / CELL) * CELL;
        const y2 = Math.round(Math.max(pos.y, pdDrawStart.y) / CELL) * CELL;
        const w = x2 - x;
        const h = y2 - y;
        if (w > 20 && h > 20) {
          pdSaveState(); // Save state before adding region
          const color = PD_COLORS[(pdNextId - 1) % PD_COLORS.length];
          pdRegions.push({
            id: pdNextId,
            x, y, w, h, color,
            label: 'C' + pdNextId,
            plyCounts: { '0': 0, '90': 0, '45': 0, '-45': 0 }
          });
          pdSelectedIdx = pdRegions.length - 1;
          pdNextId++;
          pdUpdateUI();
          pdShowPopup(pdSelectedIdx);
          pdSetTool('select');
        }
        pdRender();
      }
      if (pdDragging) pdDragging = false;
    }

    function pdRender() {
      if (!pdCtx) return;
      const W = pdCanvas.width, H = pdCanvas.height;
      pdCtx.clearRect(0, 0, W, H);

      // Grid
      pdCtx.save();
      pdCtx.strokeStyle = '#e2e8f0';
      pdCtx.lineWidth = 0.5;
      for (let x = 0; x < W; x += 40) { pdCtx.beginPath(); pdCtx.moveTo(x, 0); pdCtx.lineTo(x, H); pdCtx.stroke(); }
      for (let y = 0; y < H; y += 40) { pdCtx.beginPath(); pdCtx.moveTo(0, y); pdCtx.lineTo(W, y); pdCtx.stroke(); }
      pdCtx.restore();

      // Regions
      pdRegions.forEach((r, i) => {
        const selected = (i === pdSelectedIdx);
        // Fill
        pdCtx.save();
        pdCtx.globalAlpha = 0.25;
        pdCtx.fillStyle = r.color;
        pdCtx.fillRect(r.x, r.y, r.w, r.h);
        pdCtx.restore();

        // Border
        pdCtx.save();
        pdCtx.strokeStyle = selected ? '#1d4ed8' : r.color;
        pdCtx.lineWidth = selected ? 3 : 2;
        if (selected) pdCtx.setLineDash([]);
        pdCtx.strokeRect(r.x, r.y, r.w, r.h);
        pdCtx.restore();

        // Label + ply info
        const total = Object.values(r.plyCounts).reduce((a, b) => a + b, 0);
        pdCtx.save();
        pdCtx.font = 'bold 14px Inter, system-ui, sans-serif';
        pdCtx.fillStyle = '#0f172a';
        pdCtx.textAlign = 'center';
        pdCtx.textBaseline = 'middle';
        const cx = r.x + r.w / 2, cy = r.y + r.h / 2;

        // Background pill for text
        const txt = r.label;
        const txt2 = total > 0 ? `${total} ply` : 'Ply gir';
        const tw = Math.max(pdCtx.measureText(txt).width, pdCtx.measureText(txt2).width) + 16;
        pdCtx.fillStyle = 'rgba(255,255,255,0.85)';
        pdCtx.beginPath();
        pdCtx.roundRect(cx - tw / 2, cy - 18, tw, 36, 6);
        pdCtx.fill();

        pdCtx.fillStyle = '#0f172a';
        pdCtx.font = 'bold 14px Inter, system-ui, sans-serif';
        pdCtx.fillText(txt, cx, cy - 6);
        pdCtx.font = '11px Inter, system-ui, sans-serif';
        pdCtx.fillStyle = total > 0 ? '#059669' : '#94a3b8';
        pdCtx.fillText(txt2, cx, cy + 10);
        pdCtx.restore();
      });

      // --- Komşuluk çizgileri (gri, kesikli) ---
      if (pdRegions.length >= 2) {
        const neighborPairs = computeNeighborPairs(pdRegions, 40);
        pdCtx.save();
        pdCtx.strokeStyle = '#94a3b8';
        pdCtx.lineWidth = 1.5;
        pdCtx.setLineDash([6, 4]);
        pdCtx.globalAlpha = 0.5;
        neighborPairs.forEach(([i, j]) => {
          const r1 = pdRegions[i], r2 = pdRegions[j];
          const cx1 = r1.x + r1.w / 2, cy1 = r1.y + r1.h / 2;
          const cx2 = r2.x + r2.w / 2, cy2 = r2.y + r2.h / 2;
          pdCtx.beginPath();
          pdCtx.moveTo(cx1, cy1);
          pdCtx.lineTo(cx2, cy2);
          pdCtx.stroke();
        });
        pdCtx.restore();
      }

      // --- Bağlantısız zone uyarısı (kırmızı kesikli border) ---
      if (pdRegions.length >= 2 && window._disconnectedZones && window._disconnectedZones.length > 0) {
        pdCtx.save();
        pdCtx.strokeStyle = '#ef4444';
        pdCtx.lineWidth = 3;
        pdCtx.setLineDash([8, 4]);
        window._disconnectedZones.forEach(idx => {
          if (idx < pdRegions.length) {
            const r = pdRegions[idx];
            pdCtx.strokeRect(r.x, r.y, r.w, r.h);
          }
        });
        pdCtx.restore();
      }

      // --- Drop-off hiyerarşi okları (yeşil, optimize sonrası) ---
      if (pdDropOffTree && Object.keys(pdDropOffTree).length > 0) {
        pdCtx.save();
        pdCtx.strokeStyle = '#059669';
        pdCtx.fillStyle = '#059669';
        pdCtx.lineWidth = 2.5;
        pdCtx.setLineDash([]);
        pdCtx.globalAlpha = 0.8;
        Object.entries(pdDropOffTree).forEach(([childStr, parentIdx]) => {
          const childIdx = parseInt(childStr);
          if (childIdx >= pdRegions.length || parentIdx >= pdRegions.length) return;
          const parent = pdRegions[parentIdx];
          const child = pdRegions[childIdx];
          const px = parent.x + parent.w / 2, py = parent.y + parent.h / 2;
          const cx = child.x + child.w / 2, cy = child.y + child.h / 2;
          // Çizgi
          pdCtx.beginPath();
          pdCtx.moveTo(px, py);
          pdCtx.lineTo(cx, cy);
          pdCtx.stroke();
          // Ok ucu
          const angle = Math.atan2(cy - py, cx - px);
          const arrowLen = 10;
          pdCtx.beginPath();
          pdCtx.moveTo(cx, cy);
          pdCtx.lineTo(cx - arrowLen * Math.cos(angle - 0.4), cy - arrowLen * Math.sin(angle - 0.4));
          pdCtx.lineTo(cx - arrowLen * Math.cos(angle + 0.4), cy - arrowLen * Math.sin(angle + 0.4));
          pdCtx.closePath();
          pdCtx.fill();
        });
        pdCtx.restore();
      }

      // Hint
      if (pdHint) pdHint.style.display = pdRegions.length === 0 ? 'flex' : 'none';
    }

    function pdUpdateUI() {
      if (pdRegionCount) pdRegionCount.textContent = `${pdRegions.length} / 20 bolge`;
      if (pdOptimizeBtn) pdOptimizeBtn.disabled = pdRegions.length < 2 || !pdRegions.some(r => Object.values(r.plyCounts).reduce((a, b) => a + b, 0) > 0);

      // Also sync zone-count-select and zone inputs to match regions
      pdSyncToZoneForm();
    }

    function pdShowPopup(idx) {
      if (idx < 0 || idx >= pdRegions.length) return;
      const r = pdRegions[idx];
      document.getElementById('pd-popup-title').textContent = `Bolge ${r.label}`;
      document.getElementById('pd-ply-0').value = r.plyCounts['0'] || 0;
      document.getElementById('pd-ply-90').value = r.plyCounts['90'] || 0;
      document.getElementById('pd-ply-45').value = r.plyCounts['45'] || 0;
      document.getElementById('pd-ply--45').value = r.plyCounts['-45'] || 0;
      pdUpdatePopupTotal();
      pdRegionPopup.classList.remove('hidden');

      // Position popup near region
      const r2 = pdRegions[idx];
      const canvasRect = pdCanvas.getBoundingClientRect();
      let px = r2.x + r2.w + 8;
      let py = r2.y;
      if (px + 260 > pdCanvas.width) px = Math.max(4, r2.x - 268);
      if (py + 200 > pdCanvas.height) py = Math.max(4, pdCanvas.height - 200);
      pdRegionPopup.style.left = px + 'px';
      pdRegionPopup.style.top = py + 'px';
    }

    function pdUpdatePopupTotal() {
      const t = [0, 90, 45, -45].reduce((s, a) => s + (parseInt(document.getElementById('pd-ply-' + a)?.value) || 0), 0);
      const el = document.getElementById('pd-popup-total');
      if (el) el.textContent = `Toplam: ${t} ply`;
    }

    function pdApplyPopup() {
      if (pdSelectedIdx < 0) return;
      pdSaveState(); // Save state before ply change
      const r = pdRegions[pdSelectedIdx];
      r.plyCounts['0'] = parseInt(document.getElementById('pd-ply-0').value) || 0;
      r.plyCounts['90'] = parseInt(document.getElementById('pd-ply-90').value) || 0;
      r.plyCounts['45'] = parseInt(document.getElementById('pd-ply-45').value) || 0;
      r.plyCounts['-45'] = parseInt(document.getElementById('pd-ply--45').value) || 0;
      pdRegionPopup.classList.add('hidden');
      pdUpdateUI();
      pdRender();
    }

    function pdDeleteSelected() {
      if (pdSelectedIdx >= 0) {
        pdSaveState(); // Save state before delete
        pdRegions.splice(pdSelectedIdx, 1);
        pdSelectedIdx = -1;
        pdRegionPopup.classList.add('hidden');
        pdUpdateUI();
        pdRender();
      }
    }

    function pdClearAll() {
      if (pdRegions.length === 0) return;
      if (!confirm('Tum bolgeler silinecek. Emin misiniz?')) return;
      pdSaveState(); // Save state before clear
      pdRegions = [];
      pdNextId = 1;
      pdSelectedIdx = -1;
      pdRegionPopup.classList.add('hidden');
      pdUpdateUI();
      pdRender();
    }

    // ========== UNDO / REDO ==========
    function pdSaveState() {
      pdUndoStack.push({
        regions: JSON.parse(JSON.stringify(pdRegions)),
        nextId: pdNextId
      });
      if (pdUndoStack.length > PD_MAX_UNDO) pdUndoStack.shift();
      pdRedoStack.length = 0; // Clear redo on new action
      pdUpdateUndoRedoButtons();
    }

    function pdUndo() {
      if (pdUndoStack.length === 0) return;
      // Save current state to redo
      pdRedoStack.push({
        regions: JSON.parse(JSON.stringify(pdRegions)),
        nextId: pdNextId
      });
      const state = pdUndoStack.pop();
      pdRegions = state.regions;
      pdNextId = state.nextId;
      pdSelectedIdx = -1;
      pdRegionPopup.classList.add('hidden');
      pdUpdateUI();
      pdRender();
      pdUpdateUndoRedoButtons();
    }

    function pdRedo() {
      if (pdRedoStack.length === 0) return;
      // Save current state to undo
      pdUndoStack.push({
        regions: JSON.parse(JSON.stringify(pdRegions)),
        nextId: pdNextId
      });
      const state = pdRedoStack.pop();
      pdRegions = state.regions;
      pdNextId = state.nextId;
      pdSelectedIdx = -1;
      pdRegionPopup.classList.add('hidden');
      pdUpdateUI();
      pdRender();
      pdUpdateUndoRedoButtons();
    }

    function pdUpdateUndoRedoButtons() {
      const undoBtn = document.getElementById('pd-undo-btn');
      const redoBtn = document.getElementById('pd-redo-btn');
      if (undoBtn) {
        undoBtn.disabled = pdUndoStack.length === 0;
        undoBtn.className = 'px-2 py-1 text-xs rounded transition ' +
          (pdUndoStack.length > 0 ? 'bg-slate-200 text-slate-700 hover:bg-slate-300 cursor-pointer' : 'bg-slate-200 text-slate-400 cursor-not-allowed');
      }
      if (redoBtn) {
        redoBtn.disabled = pdRedoStack.length === 0;
        redoBtn.className = 'px-2 py-1 text-xs rounded transition ' +
          (pdRedoStack.length > 0 ? 'bg-slate-200 text-slate-700 hover:bg-slate-300 cursor-pointer' : 'bg-slate-200 text-slate-400 cursor-not-allowed');
      }
    }

    // ========== JSON EXPORT / IMPORT ==========
    function pdExportDesign() {
      if (pdRegions.length === 0) {
        alert('Disa aktarilacak bolge yok. Once bolge cizin.');
        return;
      }
      const exportData = {
        version: 1,
        exportedAt: new Date().toISOString(),
        canvasSize: pdCanvas ? { width: pdCanvas.width, height: pdCanvas.height } : null,
        nextId: pdNextId,
        regions: pdRegions.map(r => ({
          id: r.id,
          label: r.label,
          x: Math.round(r.x * 100) / 100,
          y: Math.round(r.y * 100) / 100,
          w: Math.round(r.w * 100) / 100,
          h: Math.round(r.h * 100) / 100,
          color: r.color,
          plyCounts: { ...r.plyCounts }
        }))
      };
      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      a.download = `panel-design-${timestamp}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function pdImportDesign(e) {
      const file = e.target?.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          // Version check
          if (!data.version || data.version !== 1) {
            alert('Gecersiz dosya formati veya desteklenmeyen versiyon.');
            return;
          }
          if (!Array.isArray(data.regions) || data.regions.length === 0) {
            alert('Dosyada bolge verisi bulunamadi.');
            return;
          }
          if (data.regions.length > 20) {
            alert('Maksimum 20 bolge desteklenir. Dosyada ' + data.regions.length + ' bolge var.');
            return;
          }
          // Validate each region
          for (const r of data.regions) {
            if (typeof r.x !== 'number' || typeof r.y !== 'number' ||
              typeof r.w !== 'number' || typeof r.h !== 'number') {
              alert('Gecersiz bolge verisi: konum/boyut degerlerinde hata.');
              return;
            }
            if (!r.plyCounts || typeof r.plyCounts !== 'object') {
              alert('Gecersiz bolge verisi: plyCounts eksik.');
              return;
            }
          }
          // Scale regions if canvas size differs
          let scaleX = 1, scaleY = 1;
          if (data.canvasSize && pdCanvas) {
            scaleX = pdCanvas.width / data.canvasSize.width;
            scaleY = pdCanvas.height / data.canvasSize.height;
          }
          // Apply
          pdRegions = data.regions.map(r => ({
            id: r.id || pdNextId++,
            label: r.label || 'C' + (r.id || pdNextId),
            x: r.x * scaleX,
            y: r.y * scaleY,
            w: r.w * scaleX,
            h: r.h * scaleY,
            color: r.color || PD_COLORS[0],
            plyCounts: {
              '0': r.plyCounts['0'] || 0,
              '90': r.plyCounts['90'] || 0,
              '45': r.plyCounts['45'] || 0,
              '-45': r.plyCounts['-45'] || 0
            }
          }));
          pdNextId = data.nextId || (Math.max(0, ...pdRegions.map(r => r.id)) + 1);
          pdSelectedIdx = -1;
          pdRegionPopup.classList.add('hidden');
          pdUpdateUI();
          pdRender();
          // Show success notification
          if (runMetaEl) runMetaEl.textContent = `${pdRegions.length} bolge basariyla yuklendi.`;
        } catch (err) {
          console.error('Import error:', err);
          alert('JSON dosyasi okunamadi: ' + err.message);
        }
      };
      reader.readAsText(file);
      // Reset file input so same file can be re-imported
      e.target.value = '';
    }

    // Sync 2D panel regions to existing zone form (so existing submit handler works)
    function pdSyncToZoneForm() {
      const count = pdRegions.length;
      if (count === 0) return;
      // Update zone count select
      zoneCountSelect.value = Math.max(2, Math.min(8, count));
      generateZoneInputs(count);

      // Fill zone inputs
      pdRegions.forEach((r, i) => {
        ['0', '90', '45', '-45'].forEach(angle => {
          const inp = document.querySelector(`input[name="zone-${i}-${angle}"]`);
          if (inp) inp.value = r.plyCounts[angle] || 0;
        });
      });
    }

    // Panel Designer optimize button
    async function pdRunOptimize() {
      // Collect zones from regions
      const zones = pdRegions.map(r => ({
        '0': r.plyCounts['0'] || 0,
        '90': r.plyCounts['90'] || 0,
        '45': r.plyCounts['45'] || 0,
        '-45': r.plyCounts['-45'] || 0,
      }));

      // Collect bounds (2D konumlar) from regions
      const bounds = pdRegions.map(r => ({
        x: r.x, y: r.y, w: r.w, h: r.h
      }));

      // Validate
      for (let i = 0; i < zones.length; i++) {
        const total = Object.values(zones[i]).reduce((a, b) => a + b, 0);
        if (total <= 0) {
          alert(`Bolge ${pdRegions[i].label} bos! Ply degerlerini girin.`);
          return;
        }
      }
      if (zones.length < 2) {
        alert('En az 2 bolge gerekli.');
        return;
      }

      // Kural oranlari toplami 100 olmali
      const rule_weights = getRuleWeights();
      const weightsTotal = Object.values(rule_weights).reduce((a, b) => a + b, 0);
      if (Math.abs(weightsTotal - 100) > 0.01) {
        alert('Kural oranlari toplami 100 olmak zorundadir. Su an: ' + Math.round(weightsTotal * 10) / 10 + '. Oranlari duzeltip tekrar deneyin.');
        return;
      }

      // Loading Animation (Same as Control Panel)
      await showLoadingAnimation();
      loadingStatus.textContent = `${zones.length} zone optimizasyonu baslatiliyor...`;

      try {
        // Use the standard endpoint (not stream) to match Control Panel behavior
        const useSurrogate = document.getElementById('ml-surrogate-toggle')?.checked || false;
        const response = await fetch(`${API_BASE}/optimize_multi_zone`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ zones, bounds, panel_scale_mm: 300, rule_weights, use_surrogate: useSurrogate })
        });

        const data = await response.json();

        // Stop loading animation
        if (progressInterval) clearInterval(progressInterval);
        loadingProgress.style.width = '100%';
        loadingProgressText.textContent = '100%';
        loadingStatus.textContent = "Tamamlandi!";

        // Mark all rules as done
        for (let i = 1; i <= 8; i++) {
          updateRuleStatus(i, 'done');
        }

        await new Promise(r => setTimeout(r, 600));
        loadingOverlay.classList.add('hidden');

        if (data.disconnected_zones && data.disconnected_zones.length > 0) {
          window._disconnectedZones = data.disconnected_zones;
          pdDropOffTree = null;
          pdRender();
          const labels = data.disconnected_zones.map(i => pdRegions[i]?.label || `Zone ${i+1}`).join(', ');
          alert(`Baglantisiz zone'lar: ${labels}\nTum zone'lar birbirine komsu olmalidir.`);
          return;
        }

        if (data.feasibility_errors && data.feasibility_errors.length > 0) {
          const errLines = data.feasibility_errors.join('\n');
          alert(`Zone ply yapilandirmasi hatali!\n\n${errLines}\n\nHer zone, parent zone'undan her acida daha az veya esit ply icermelidir.`);
          return;
        }

        if (!data.success && data.error) {
          alert(`Optimizasyon hatasi: ${data.error}`);
          return;
        }

        // Store drop-off tree for 2D canvas overlay
        pdDropOffTree = data.drop_off_tree || null;
        window._disconnectedZones = null;
        pdRender();

        // Show results
        multiZoneResults = data;
        displayMultiZoneResults(data);

      } catch (err) {
        if (progressInterval) clearInterval(progressInterval);
        loadingOverlay.classList.add('hidden');
        alert(`Baglanti hatasi: ${err.message}`);
      }
    }

    // Back to designer button
    document.getElementById('back-to-designer')?.addEventListener('click', () => {
      pdDropOffTree = null;
      window._disconnectedZones = null;
      resultsSection.classList.add('hidden');
      if (emptyState) emptyState.style.display = '';
      const rwPanel = document.getElementById('rule-weights-panel');
      if (rwPanel) rwPanel.style.display = '';
      pdResize();
      pdRender();
    });

    // Initialize panel designer
    pdInit();

    // ========== MULTI-ZONE INPUT GENERATION ==========

    function generateZoneInputs(zoneCount) {
      zoneInputsContainer.innerHTML = '';

      // Varsayılan değerler (zone 1 en büyük, diğerleri küçülen)
      const defaultValues = [
        { '0': 12, '45': 8, '-45': 8, '90': 8 },  // 36 ply
        { '0': 10, '45': 8, '-45': 8, '90': 8 },  // 34 ply
        { '0': 8, '45': 6, '-45': 6, '90': 6 },  // 26 ply
        { '0': 6, '45': 6, '-45': 6, '90': 6 },  // 24 ply
        { '0': 6, '45': 4, '-45': 4, '90': 4 },  // 18 ply
        { '0': 4, '45': 4, '-45': 4, '90': 4 },  // 16 ply
        { '0': 4, '45': 2, '-45': 2, '90': 2 },  // 10 ply
        { '0': 2, '45': 2, '-45': 2, '90': 2 },  // 8 ply
      ];

      for (let i = 0; i < zoneCount; i++) {
        const defaults = defaultValues[i] || defaultValues[defaultValues.length - 1];
        const total = Object.values(defaults).reduce((a, b) => a + b, 0);

        const zoneDiv = document.createElement('div');
        zoneDiv.className = 'zone-card bg-slate-800/50 rounded-lg p-3 border border-slate-700/50';
        zoneDiv.dataset.zoneIndex = i;
        zoneDiv.innerHTML = `
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-semibold text-white zone-title">Zone ${i + 1}</span>
            <div class="flex items-center gap-2">
              <span class="text-xs text-slate-400 zone-total" data-zone="${i}">Toplam: ${total} ply</span>
              <button type="button" class="zone-remove-card-btn p-1 rounded text-slate-400 hover:text-red-400 hover:bg-red-400/10 focus:outline-none transition-colors" title="Bu bölgeyi çıkar"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>
            </div>
          </div>
          <div class="grid grid-cols-4 gap-2">
            <label class="text-xs text-slate-300">
              0°
              <input type="number" name="zone-${i}-0" value="${defaults['0']}" min="0"
                class="mt-1 w-full bg-white/90 border border-slate-300/70 rounded px-2 py-1.5 text-xs text-slate-900 focus:outline-none focus:ring-1 focus:ring-blue-500" />
            </label>
            <label class="text-xs text-slate-300">
              +45°
              <input type="number" name="zone-${i}-45" value="${defaults['45']}" min="0"
                class="mt-1 w-full bg-white/90 border border-slate-300/70 rounded px-2 py-1.5 text-xs text-slate-900 focus:outline-none focus:ring-1 focus:ring-blue-500" />
            </label>
            <label class="text-xs text-slate-300">
              -45°
              <input type="number" name="zone-${i}--45" value="${defaults['-45']}" min="0"
                class="mt-1 w-full bg-white/90 border border-slate-300/70 rounded px-2 py-1.5 text-xs text-slate-900 focus:outline-none focus:ring-1 focus:ring-blue-500" />
            </label>
            <label class="text-xs text-slate-300">
              90°
              <input type="number" name="zone-${i}-90" value="${defaults['90']}" min="0"
                class="mt-1 w-full bg-white/90 border border-slate-300/70 rounded px-2 py-1.5 text-xs text-slate-900 focus:outline-none focus:ring-1 focus:ring-blue-500" />
            </label>
          </div>
        `;
        zoneInputsContainer.appendChild(zoneDiv);

        const zoneIndex = i;
        zoneDiv.querySelectorAll('input').forEach(input => {
          input.addEventListener('input', () => updateZoneTotal(zoneIndex));
        });
        zoneDiv.querySelector('.zone-remove-card-btn').addEventListener('click', () => removeZoneCard(zoneDiv));
      }
      syncZoneCountSelect();
      updateZoneRemoveButtons();
    }

    function getZoneCards() {
      return Array.from(zoneInputsContainer.querySelectorAll('.zone-card'));
    }

    function syncZoneCountSelect() {
      const n = getZoneCards().length;
      zoneCountSelect.value = String(Math.max(2, Math.min(8, n)));
    }

    function updateZoneRemoveButtons() {
      const count = getZoneCards().length;
      getZoneCards().forEach(card => {
        const btn = card.querySelector('.zone-remove-card-btn');
        if (btn) btn.style.visibility = count > 2 ? 'visible' : 'hidden';
      });
    }

    function reindexZones() {
      const cards = getZoneCards();
      const angleKeys = ['0', '45', '-45', '90'];
      cards.forEach((card, i) => {
        card.dataset.zoneIndex = i;
        const title = card.querySelector('.zone-title');
        if (title) title.textContent = `Zone ${i + 1}`;
        const totalEl = card.querySelector('.zone-total');
        if (totalEl) totalEl.setAttribute('data-zone', String(i));
        const inputs = card.querySelectorAll('input[type="number"]');
        inputs.forEach((input, j) => {
          const key = angleKeys[j];
          const name = key === '-45' ? `zone-${i}--45` : `zone-${i}-${key}`;
          input.setAttribute('name', name);
        });
        updateZoneTotal(i);
      });
      syncZoneCountSelect();
      updateZoneRemoveButtons();
    }

    function addZone() {
      const cards = getZoneCards();
      if (cards.length >= 8) return;
      const defaultValues = [
        { '0': 12, '45': 8, '-45': 8, '90': 8 },
        { '0': 10, '45': 8, '-45': 8, '90': 8 },
        { '0': 8, '45': 6, '-45': 6, '90': 6 },
        { '0': 6, '45': 6, '-45': 6, '90': 6 },
        { '0': 6, '45': 4, '-45': 4, '90': 4 },
        { '0': 4, '45': 4, '-45': 4, '90': 4 },
        { '0': 4, '45': 2, '-45': 2, '90': 2 },
        { '0': 2, '45': 2, '-45': 2, '90': 2 },
      ];
      const i = cards.length;
      const defaults = defaultValues[i] || defaultValues[defaultValues.length - 1];
      const total = Object.values(defaults).reduce((a, b) => a + b, 0);

      const zoneDiv = document.createElement('div');
      zoneDiv.className = 'zone-card bg-slate-800/50 rounded-lg p-3 border border-slate-700/50';
      zoneDiv.dataset.zoneIndex = i;
      zoneDiv.innerHTML = `
        <div class="flex items-center justify-between mb-2">
          <span class="text-sm font-semibold text-white zone-title">Zone ${i + 1}</span>
          <div class="flex items-center gap-2">
            <span class="text-xs text-slate-400 zone-total" data-zone="${i}">Toplam: ${total} ply</span>
            <button type="button" class="zone-remove-card-btn p-1 rounded text-slate-400 hover:text-red-400 hover:bg-red-400/10 focus:outline-none transition-colors" title="Bu bölgeyi çıkar"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>
          </div>
        </div>
        <div class="grid grid-cols-4 gap-2">
          <label class="text-xs text-slate-300">
            0°
            <input type="number" name="zone-${i}-0" value="${defaults['0']}" min="0"
              class="mt-1 w-full bg-white/90 border border-slate-300/70 rounded px-2 py-1.5 text-xs text-slate-900 focus:outline-none focus:ring-1 focus:ring-blue-500" />
          </label>
          <label class="text-xs text-slate-300">
            +45°
            <input type="number" name="zone-${i}-45" value="${defaults['45']}" min="0"
              class="mt-1 w-full bg-white/90 border border-slate-300/70 rounded px-2 py-1.5 text-xs text-slate-900 focus:outline-none focus:ring-1 focus:ring-blue-500" />
          </label>
          <label class="text-xs text-slate-300">
            -45°
            <input type="number" name="zone-${i}--45" value="${defaults['-45']}" min="0"
              class="mt-1 w-full bg-white/90 border border-slate-300/70 rounded px-2 py-1.5 text-xs text-slate-900 focus:outline-none focus:ring-1 focus:ring-blue-500" />
          </label>
          <label class="text-xs text-slate-300">
            90°
            <input type="number" name="zone-${i}-90" value="${defaults['90']}" min="0"
              class="mt-1 w-full bg-white/90 border border-slate-300/70 rounded px-2 py-1.5 text-xs text-slate-900 focus:outline-none focus:ring-1 focus:ring-blue-500" />
          </label>
        </div>
      `;
      zoneInputsContainer.appendChild(zoneDiv);
      zoneDiv.querySelectorAll('input').forEach(input => {
        input.addEventListener('input', () => updateZoneTotal(getZoneCards().length - 1));
      });
      zoneDiv.querySelector('.zone-remove-card-btn').addEventListener('click', () => removeZoneCard(zoneDiv));
      reindexZones();
    }

    function removeZoneCard(card) {
      if (getZoneCards().length <= 2) return;
      card.remove();
      reindexZones();
    }

    function removeLastZone() {
      const cards = getZoneCards();
      if (cards.length <= 2) return;
      cards[cards.length - 1].remove();
      reindexZones();
    }

    function updateZoneTotal(zoneIndex) {
      const inputs = zoneInputsContainer.querySelectorAll(`input[name^="zone-${zoneIndex}-"]`);
      let total = 0;
      inputs.forEach(input => {
        total += parseInt(input.value) || 0;
      });
      const totalEl = zoneInputsContainer.querySelector(`.zone-total[data-zone="${zoneIndex}"]`);
      if (totalEl) {
        totalEl.textContent = `Toplam: ${total} ply`;
      }
    }

    function collectZoneData() {
      const cards = getZoneCards();
      const zones = [];
      for (let i = 0; i < cards.length; i++) {
        const card = cards[i];
        const inputs = card.querySelectorAll('input[type="number"]');
        const zone = {
          '0': parseInt(inputs[0].value) || 0,
          '45': parseInt(inputs[1].value) || 0,
          '-45': parseInt(inputs[2].value) || 0,
          '90': parseInt(inputs[3].value) || 0,
        };
        zones.push(zone);
      }
      return zones;
    }

    // Zone sayısı değiştiğinde input'ları yeniden oluştur (dropdown ile)
    zoneCountSelect.addEventListener('change', () => {
      generateZoneInputs(parseInt(zoneCountSelect.value));
    });

    document.getElementById('zone-add-btn').addEventListener('click', () => addZone());

    // Sayfa yüklendiğinde varsayılan zone'ları oluştur
    generateZoneInputs(parseInt(zoneCountSelect.value));

    // ========== MULTI-ZONE FORM SUBMIT ==========

    multizoneForm.addEventListener('submit', async (e) => {
      e.preventDefault();

      const zones = collectZoneData();

      // Validasyon
      for (let i = 0; i < zones.length; i++) {
        const total = Object.values(zones[i]).reduce((a, b) => a + b, 0);
        if (total <= 0) {
          alert(`Zone ${i + 1} boş olamaz!`);
          return;
        }
      }

      // Kural oranlari toplami 100 olmali
      const rule_weights = getRuleWeights();
      const weightsTotal = Object.values(rule_weights).reduce((a, b) => a + b, 0);
      if (Math.abs(weightsTotal - 100) > 0.01) {
        alert('Kural oranlari toplami 100 olmak zorundadir. Su an: ' + Math.round(weightsTotal * 10) / 10 + '. Oranlari duzeltip tekrar deneyin.');
        return;
      }

      // Loading göster
      await showLoadingAnimation();
      loadingStatus.textContent = `${zones.length} zone optimize ediliyor...`;

      try {
        const useSurrogate2 = document.getElementById('ml-surrogate-toggle')?.checked || false;
        const response = await fetch(`${API_BASE}/optimize_multi_zone`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ zones, rule_weights, use_surrogate: useSurrogate2 })
        });

        const data = await response.json();

        // Loading gizle
        clearInterval(progressInterval);
        loadingProgress.style.width = '100%';
        loadingProgressText.textContent = '100%';
        await new Promise(r => setTimeout(r, 500));
        loadingOverlay.classList.add('hidden');

        if (data.error) {
          if (data.disconnected_zones && data.disconnected_zones.length > 0) {
            window._disconnectedZones = data.disconnected_zones;
            pdDropOffTree = null;
            pdRender();
            const labels = data.disconnected_zones.map(i => pdRegions[i]?.label || `Zone ${i+1}`).join(', ');
            alert(`Baglantisiz zone'lar: ${labels}\nTum zone'lar birbirine komsu olmalidir.`);
          } else {
            alert(`Hata: ${data.error}`);
          }
          return;
        }

        // Store drop-off tree for 2D canvas overlay
        pdDropOffTree = data.drop_off_tree || null;
        window._disconnectedZones = null;
        pdRender();

        // Sonuçları göster
        multiZoneResults = data;
        displayMultiZoneResults(data);

      } catch (err) {
        clearInterval(progressInterval);
        loadingOverlay.classList.add('hidden');
        alert(`Bağlantı hatası: ${err.message}`);
      }
    });

    function displayMultiZoneResults(data) {
      // Panel designer ve kural panelini gizle; sonuclari goster
      if (emptyState) emptyState.style.display = 'none';
      const rwPanel = document.getElementById('rule-weights-panel');
      if (rwPanel) rwPanel.style.display = 'none';
      resultsSection.classList.remove('hidden');

      // Root zone'u bul (en yüksek ply)
      const rootZone = data.zones.find(z => z && z.is_root);

      // Fitness score (root zone'un skoru)
      if (rootZone) {
        fitnessScoreEl.textContent = rootZone.fitness.toFixed(1);
        currentMasterSequence = rootZone.sequence;
        originalMasterSequence = rootZone.sequence;

        // Penalties (root zone)
        if (rootZone.penalties) {
          renderPenalties(rootZone.penalties);
        }

        // Symmetry & Balance scores
        if (rootZone.penalties?.R1) {
          const r1 = rootZone.penalties.R1;
          symmetryPenaltyEl.textContent = `${r1.score} / ${r1.weight}`;
          symmetryPenaltyEl.className = r1.penalty === 0 ? 'text-2xl font-mono mt-2 text-emerald-700' : 'text-2xl font-mono mt-2 text-rose-700';
        }
        if (rootZone.penalties?.R2) {
          const r2 = rootZone.penalties.R2;
          balanceScoreEl.textContent = `${r2.score} / ${r2.weight}`;
          balanceScoreEl.className = r2.penalty === 0 ? 'text-2xl font-mono mt-2 text-emerald-700' : 'text-2xl font-mono mt-2 text-rose-700';
        }
      }

      // Stats
      let statsText = `${data.zones.length} zone • ${data.stats.duration_seconds}s`;
      statsMetaEl.textContent = statsText;

      // Ramp violations warning
      if (data.ramp_checks && data.ramp_checks.length > 0) {
        const violations = data.ramp_checks.filter(r => !r.feasible);
        if (violations.length > 0) {
          let msg = 'Ramp Kisiti Uyarisi:\n';
          violations.forEach(v => {
            msg += `Zone ${v.zone_a + 1} <-> Zone ${v.zone_b + 1}: ${v.ply_diff} ply fark, gereken=${v.required_ramp_mm}mm, mevcut=${v.available_mm}mm\n`;
          });
          setTimeout(() => alert(msg), 600);
        }
      }
      runMetaEl.textContent = `Multi-Zone Optimization Complete`;

      // Zone Score Cards - tüm zone'ları kartlarla göster
      renderZoneScoreCards(data.zones);

      // Laminate Map - tüm zone'ları göster (cache'le ve toggle moduna göre render)
      window._laminateMapZones = data.zones;
      window._laminateMapTransitions = data.transitions;
      window._laminateMapNeighborGraph = data.neighbor_graph || [];
      rerenderLaminateMap();

      // İyileştirme Önerileri - Laminate Map'in hemen altında
      renderImprovementSuggestions(data.zones);

      // 3D Views (Stacking + Panel 3D)
      const view3dCard = document.getElementById('view3d-card');
      if (window._view3d) {
        view3dCard.classList.remove('hidden');
        // Stacking view init
        if (!window._view3d.initialized) {
          window._view3d.init(document.getElementById('view3d-container'));
          window._view3d.legend(document.getElementById('view3d-legend'));
          window._view3d.initialized = true;
        }
        window._view3d.update(data.zones, data.weight, data.ramp_checks);

        // Panel 3D init
        if (!window._view3d.panel3dInitialized) {
          window._view3d.initPanel3D(document.getElementById('panel3d-container'));
          window._view3d.panel3dInitialized = true;
        }
        // bounds bilgisini pdRegions'tan al
        const _bounds = (typeof pdRegions !== 'undefined' && pdRegions.length > 0)
          ? pdRegions.map(r => ({ x: r.x, y: r.y, w: r.w, h: r.h, label: r.label, color: r.color }))
          : null;
        window._view3d._dropOffTree = data.drop_off_tree || {};
        window._view3d.updatePanel3D(data.zones, _bounds, data.weight, data.ramp_checks);

        // Tab switching
        setupView3DTabs();

        // Initialize Cross-Section View
        if (typeof crossSectionView !== 'undefined') {
          crossSectionView.init(data.zones.filter(z => z && z.sequence));
        }

        // Initialize Ply Coverage Map
        if (typeof plyCoverageMap !== 'undefined') {
          plyCoverageMap.init(data.zones.filter(z => z && z.sequence));
        }

        // Initialize Fiber Orientation Overlay
        if (typeof fiberOrientationOverlay !== 'undefined') {
          fiberOrientationOverlay.init();
          // Generate lines after ply meshes are created
          setTimeout(() => {
            if (typeof plyMeshes !== 'undefined' && plyMeshes.length > 0) {
              fiberOrientationOverlay.generate(plyMeshes);
            }
          }, 500);
        }
      }
    }

    // ========== 3D TABS: Stacking vs Panel 3D ==========
    let _view3dTabSetup = false;
    function setupView3DTabs() {
      if (_view3dTabSetup) return;
      _view3dTabSetup = true;

      const tabStacking = document.getElementById('tab-stacking');
      const tabPanel3d = document.getElementById('tab-panel3d');
      const stackingPane = document.getElementById('stacking-pane');
      const panel3dPane = document.getElementById('panel3d-pane');
      const title = document.getElementById('view3d-title');
      const subtitle = document.getElementById('view3d-subtitle');

      function activateTab(tab) {
        // Style active/inactive
        [tabStacking, tabPanel3d].forEach(btn => {
          btn.className = 'view3d-tab px-3 py-1.5 text-xs font-semibold rounded-md text-slate-600 hover:bg-slate-300 transition-all';
        });
        tab.className = 'view3d-tab px-3 py-1.5 text-xs font-semibold rounded-md bg-slate-800 text-white transition-all';

        if (tab === tabStacking) {
          stackingPane.classList.remove('hidden');
          panel3dPane.classList.add('hidden');
          title.textContent = '3D Composite Panel View';
          subtitle.textContent = 'Fare: dondur | Scroll: zoom | Katmana tikla: detay';
        } else {
          stackingPane.classList.add('hidden');
          panel3dPane.classList.remove('hidden');
          title.textContent = 'Panel 3D — Zone Map';
          subtitle.textContent = '2D ciziminizin 3D modeli | Her zone kalinligina gore yukseklik alir';
          // Panel3D renderer resize tetikleme
          if (window._view3d && window._view3d.resizePanel3D) window._view3d.resizePanel3D();
        }
      }

      tabStacking.addEventListener('click', () => activateTab(tabStacking));
      tabPanel3d.addEventListener('click', () => activateTab(tabPanel3d));
    }


    function renderMultiZoneLaminateMap(zones, transitions, neighborGraph) {
      laminateMapEl.innerHTML = '';

      // Store zones data for Excel export and view toggle
      window._laminateMapZones = zones;
      window._laminateMapTransitions = transitions;
      window._laminateMapNeighborGraph = neighborGraph;

      // neighbor_graph: backend'den gelen komşuluk listesi
      // neighborGraph[i] = zone i'nin komşu zone indeksleri listesi
      const zoneNeighborMap = new Map();
      if (Array.isArray(neighborGraph) && neighborGraph.length > 0) {
        neighborGraph.forEach((neighbors, idx) => {
          if (Array.isArray(neighbors)) zoneNeighborMap.set(idx, neighbors);
        });
      }

      const colorMap = {
        '0': 'bg-emerald-500',
        '90': 'bg-sky-500',
        '45': 'bg-rose-500',
        '-45': 'bg-amber-500',
      };

      const dotColorMap = {
        '0': 'bg-emerald-500',
        '90': 'bg-sky-500',
        '45': 'bg-rose-500',
        '-45': 'bg-amber-500',
      };

      // Zone'ları ply sayısına göre sırala (büyükten küçüğe)
      const sortedZones = [...zones].filter(z => z !== null).sort((a, b) => b.ply_count - a.ply_count);
      const maxLen = sortedZones[0]?.ply_count || 1;

      // Root zone'u bul (en kalın zone = parent referansı)
      const rootZone = sortedZones.find(z => z.is_root) || sortedZones[0];
      const rootSeq = rootZone ? rootZone.sequence : [];
      const rootLen = rootSeq.length;

      // --- Helper: normalize ply_counts coming from backend (JSON keys are strings) ---
      function normalizeAngleCounts(obj) {
        const out = { '0': 0, '90': 0, '45': 0, '-45': 0 };
        if (!obj || typeof obj !== 'object') return out;
        for (const [k, v] of Object.entries(obj)) {
          const key = String(parseInt(k, 10));
          if (key === '0' || key === '90' || key === '45' || key === '-45') {
            out[key] = parseInt(v, 10) || 0;
          }
        }
        return out;
      }

      // Zone index -> zone obj map (parent/child ilişkisini kolay bulmak için)
      const zoneByIndex = new Map();
      (zones || []).forEach(z => {
        if (z && typeof z.index === 'number') zoneByIndex.set(z.index, z);
      });

      // transitions[].dropped_indices her zaman *parent zone* sequence indeksleri
      // üzerinden ifade edilir (root -> child, child -> grandchild vb.).
      const transitionByTo = new Map();
      (transitions || []).forEach(tr => {
        if (tr && typeof tr.to === 'number') transitionByTo.set(tr.to, tr);
      });

      sortedZones.forEach((zone, stackIdx) => {
        const row = document.createElement('div');
        row.className = 'flex items-start gap-4 bg-white/80 border-2 border-slate-300 rounded-xl px-4 py-3 shadow-md';

        const isRoot = zone.is_root;
        const label = document.createElement('div');
        label.className = 'w-32 text-right text-xs font-medium pt-1';
        label.innerHTML = `
          <span class="${isRoot ? 'text-blue-400' : 'text-slate-400'}">
            Zone ${zone.index + 1} ${isRoot ? '(Root)' : ''}
          </span>
          <br/>
          <span class="text-slate-500">${zone.ply_count} ply • ${zone.fitness.toFixed(1)}pts</span>
        `;
        row.appendChild(label);

        const grid = document.createElement('div');
        grid.className = 'flex flex-col gap-1 flex-1';

        // ── Ortak ön-hesaplamalar ──────────────────────────────────────────────
        // Parent referans dizisi ve düşürülen indeksler (drop-off haritası için)
        let displaySeq = [];
        let droppedSet = new Set();
        if (isRoot) {
          displaySeq = Array.isArray(zone.sequence) ? zone.sequence : [];
        } else {
          const tr = transitionByTo.get(zone.index);
          let parentZone = null;
          if (tr) {
            const parentIndex = Array.isArray(tr.from) ? tr.from[0] : tr.from;
            parentZone = zoneByIndex.get(parentIndex) || null;
          }
          const parentSeq = parentZone && Array.isArray(parentZone.sequence) ? parentZone.sequence : rootSeq;
          displaySeq = parentSeq || [];
          if (tr && Array.isArray(tr.dropped_indices)) {
            droppedSet = new Set(
              tr.dropped_indices
                .map(n => parseInt(n, 10))
                .filter(n => Number.isFinite(n) && n >= 0)
            );
          }
        }
        const displayLen = displaySeq.length;
        const angleCounts = normalizeAngleCounts(zone.ply_counts);

        // === 1) ANA (HER ZAMAN GÖRÜNÜR) DİZİLİM — Zone'un kendi temiz dizilimi ===
        // Root için: kendi sequence'i (zaten X işareti yok)
        // Non-root için: kendi sequence'i (X'siz, temiz) — her zaman görünür
        const seq = Array.isArray(zone.sequence) ? zone.sequence : [];
        const seqLen = seq.length;
        const seqMidIndex = Math.floor(seqLen / 2);
        const seqIsOdd = seqLen % 2 === 1;

        const primaryRow = document.createElement('div');
        primaryRow.className = 'flex flex-wrap gap-[2px] bg-slate-100 p-2 rounded-md border border-slate-300 relative';

        // Spacer: root uzunluğuna hizala
        const seqSpacer = Math.floor((maxLen - seqLen) / 2);
        for (let i = 0; i < seqSpacer; i++) {
          const empty = document.createElement('div');
          empty.className = 'w-6 h-6';
          primaryRow.appendChild(empty);
        }

        seq.forEach((angle, idx) => {
          if (!seqIsOdd && idx === seqMidIndex) {
            const cl = document.createElement('div');
            cl.className = 'relative w-0 h-6 flex items-center justify-center';
            cl.innerHTML = `<div class="absolute w-[2px] h-8 bg-amber-500 z-10"></div>`;
            primaryRow.appendChild(cl);
          }
          const b = document.createElement('div');
          b.className = `w-6 h-6 rounded-sm ${colorMap[angle.toString()] || 'bg-slate-500'} flex items-center justify-center text-[8px] font-mono font-semibold text-white shadow-sm ring-1 ring-white/30`;
          b.textContent = `${angle}°`;
          b.title = `${angle}°`;
          if (seqIsOdd && idx === seqMidIndex) {
            b.style.position = 'relative';
            const cl = document.createElement('div');
            cl.className = 'absolute left-1/2 top-0 w-[2px] h-8 bg-amber-500 z-20';
            cl.style.transform = 'translateX(-50%)';
            cl.style.top = '-4px';
            b.appendChild(cl);
          }
          primaryRow.appendChild(b);
        });

        grid.appendChild(primaryRow);

        // === KOMŞULUK BİLGİSİ (tüm zone'lar için görünür) ===
        const zoneNeighbors = zoneNeighborMap.get(zone.index) || [];
        if (zoneNeighbors.length > 0) {
          const neighborRow = document.createElement('div');
          neighborRow.className = 'flex items-center gap-2 flex-wrap mt-1.5';
          const neighborLabel = document.createElement('span');
          neighborLabel.className = 'text-[11px] font-semibold text-slate-500';
          neighborLabel.textContent = 'Komşu Zonlar:';
          neighborRow.appendChild(neighborLabel);
          zoneNeighbors.forEach(nIdx => {
            const badge = document.createElement('span');
            badge.className = 'text-[11px] font-semibold px-2 py-0.5 rounded-full bg-indigo-100 text-indigo-700 border border-indigo-300';
            badge.textContent = `Zone ${nIdx + 1}`;
            neighborRow.appendChild(badge);
          });
          grid.appendChild(neighborRow);
        }

        // === 2) DROP-OFF HARİTASI (X'li, üst zone referanslı) → Toggle içinde ===
        // Non-root için: parent sequence üzerinde hangi katmanların düşürüldüğünü gösterir.
        // Root için: zaten tek dizilim var, toggle gereksiz.
        if (!isRoot) {
          const refWrapper = document.createElement('div');
          refWrapper.className = 'mt-2';

          // Toggle butonu
          const toggleBtn = document.createElement('button');
          toggleBtn.type = 'button';
          toggleBtn.className = 'flex items-center gap-2 text-xs font-semibold text-slate-700 bg-slate-100 hover:bg-slate-200 px-3 py-1.5 rounded-md border border-slate-300 shadow-sm transition-all focus:outline-none focus:ring-2 focus:ring-slate-300';
          toggleBtn.style.width = 'fit-content';
          toggleBtn.innerHTML = `
            <svg class="w-3.5 h-3.5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>
            <span>Drop-Off Haritası Göster</span>
          `;

          // Gizli konteyner
          const contentDiv = document.createElement('div');
          contentDiv.className = 'hidden mt-2 p-3 bg-slate-50 border border-slate-200 rounded-lg shadow-inner';

          toggleBtn.onclick = () => {
            const isHidden = contentDiv.classList.contains('hidden');
            if (isHidden) {
              contentDiv.classList.remove('hidden');
              contentDiv.classList.add('flex', 'flex-col', 'gap-1');
              toggleBtn.innerHTML = `
                <svg class="w-3.5 h-3.5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" /></svg>
                <span>Drop-Off Haritası Gizle</span>
              `;
              toggleBtn.classList.add('bg-slate-200');
            } else {
              contentDiv.classList.add('hidden');
              contentDiv.classList.remove('flex', 'flex-col', 'gap-1');
              toggleBtn.innerHTML = `
                <svg class="w-3.5 h-3.5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>
                <span>Drop-Off Haritası Göster</span>
              `;
              toggleBtn.classList.remove('bg-slate-200');
            }
          };

          // İçerik başlığı
          const refLabel = document.createElement('span');
          refLabel.className = 'text-sm font-bold text-slate-600 block mb-1';
          refLabel.textContent = 'Drop-off haritası (üst zone referansı):';
          contentDiv.appendChild(refLabel);

          // X'li referans satırı
          const refRow = document.createElement('div');
          refRow.className = 'flex flex-wrap gap-[2px] bg-white px-2 py-1.5 rounded border border-slate-300 flex-1 relative';

          const refSpacer = Math.floor((maxLen - displayLen) / 2);
          for (let i = 0; i < refSpacer; i++) {
            const empty = document.createElement('div');
            empty.className = 'w-6 h-6';
            refRow.appendChild(empty);
          }

          const midIndex = Math.floor(displayLen / 2);
          const isOddCount = displayLen % 2 === 1;

          displaySeq.forEach((angle, idx) => {
            const isDropped = droppedSet.has(idx);

            if (!isOddCount && idx === midIndex) {
              const cl = document.createElement('div');
              cl.className = 'relative w-0 h-6 flex items-center justify-center';
              cl.innerHTML = `<div class="absolute w-[2px] h-8 bg-amber-500 z-10"></div>`;
              refRow.appendChild(cl);
            }

            const block = document.createElement('div');
            if (isDropped) {
              block.className = `w-6 h-6 rounded-sm ${colorMap[angle.toString()] || 'bg-slate-500'} flex flex-col items-center justify-center text-white shadow-md ring-2 ring-white/50 relative opacity-50`;
              block.title = `${angle}° - Çıkarıldı`;
              const xMark = document.createElement('span');
              xMark.textContent = '✕';
              xMark.className = 'text-[11px] font-black leading-none text-white drop-shadow-[0_1px_2px_rgba(0,0,0,0.9)]';
              block.appendChild(xMark);
              const angleText = document.createElement('span');
              angleText.textContent = `${angle}°`;
              angleText.className = 'text-[7px] font-mono font-bold leading-none text-white drop-shadow-[0_1px_1px_rgba(0,0,0,0.8)]';
              block.appendChild(angleText);
            } else {
              block.className = `w-6 h-6 rounded-sm ${colorMap[angle.toString()] || 'bg-slate-500'} flex items-center justify-center text-[8px] font-mono font-semibold text-white shadow-sm ring-1 ring-white/30`;
              block.textContent = `${angle}°`;
              block.title = `${angle}°`;
            }

            if (isOddCount && idx === midIndex) {
              block.style.position = 'relative';
              const cl = document.createElement('div');
              cl.className = 'absolute left-1/2 top-0 w-[2px] h-8 bg-amber-500 z-20';
              cl.style.transform = 'translateX(-50%)';
              cl.style.top = '-4px';
              block.appendChild(cl);
            }

            refRow.appendChild(block);
          });

          contentDiv.appendChild(refRow);
          refWrapper.appendChild(toggleBtn);
          refWrapper.appendChild(contentDiv);
          grid.appendChild(refWrapper);
        }

        row.appendChild(grid);

        // Sağ tarafta açı sayıları legend
        const legend = document.createElement('div');
        legend.className = 'w-28 flex flex-col gap-1 pt-1 text-xs font-mono flex-shrink-0';

        const angleOrder = ['0', '90', '45', '-45'];
        const angleLabels = { '0': '0°', '90': '90°', '45': '+45°', '-45': '-45°' };
        angleOrder.forEach(a => {
          const count = angleCounts[a] || 0;
          const legendRow = document.createElement('div');
          legendRow.className = 'flex items-center gap-1.5';
          legendRow.innerHTML = `
            <span class="w-3 h-3 rounded-sm ${dotColorMap[a]} inline-block flex-shrink-0"></span>
            <span class="text-slate-600">${angleLabels[a]}</span>
            <span class="ml-auto font-semibold text-slate-800">${count}</span>
          `;
          legend.appendChild(legendRow);
        });

        // Total (kalan ply sayısı)
        const totalRemaining = Object.values(angleCounts).reduce((s, v) => s + v, 0);
        const totalRow = document.createElement('div');
        totalRow.className = 'flex items-center gap-1.5 border-t border-slate-300 pt-1 mt-1';
        totalRow.innerHTML = `
          <span class="w-3 h-3 inline-block flex-shrink-0"></span>
          <span class="text-slate-600 font-semibold">Total</span>
          <span class="ml-auto font-bold text-slate-900">${totalRemaining}</span>
        `;
        legend.appendChild(totalRow);

        row.appendChild(legend);
        laminateMapEl.appendChild(row);
      });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DİKEY (VERTICAL) LAMINATE MAP RENDER
    // Zone'lar yan yana sütunlar, katmanlar yukarıdan aşağıya
    // ═══════════════════════════════════════════════════════════════════════
    function renderVerticalLaminateMap(zones, transitions, neighborGraph) {
      laminateMapEl.innerHTML = '';

      const colorMap = {
        '0': 'bg-emerald-500',
        '90': 'bg-sky-500',
        '45': 'bg-rose-500',
        '-45': 'bg-amber-500',
      };

      const dotColorMap = { ...colorMap };

      const sortedZones = [...zones].filter(z => z !== null).sort((a, b) => b.ply_count - a.ply_count);
      const maxLen = sortedZones[0]?.ply_count || 1;
      const rootZone = sortedZones.find(z => z.is_root) || sortedZones[0];
      const rootSeq = rootZone ? rootZone.sequence : [];

      function normalizeAngleCounts(obj) {
        const out = { '0': 0, '90': 0, '45': 0, '-45': 0 };
        if (!obj || typeof obj !== 'object') return out;
        for (const [k, v] of Object.entries(obj)) {
          const key = String(parseInt(k, 10));
          if (key === '0' || key === '90' || key === '45' || key === '-45') {
            out[key] = parseInt(v, 10) || 0;
          }
        }
        return out;
      }

      const zoneByIndex = new Map();
      (zones || []).forEach(z => {
        if (z && typeof z.index === 'number') zoneByIndex.set(z.index, z);
      });

      const transitionByTo = new Map();
      (transitions || []).forEach(tr => {
        if (tr && typeof tr.to === 'number') transitionByTo.set(tr.to, tr);
      });

      const zoneNeighborMap = new Map();
      if (Array.isArray(neighborGraph) && neighborGraph.length > 0) {
        neighborGraph.forEach((neighbors, idx) => {
          if (Array.isArray(neighbors)) zoneNeighborMap.set(idx, neighbors);
        });
      }

      // Ana konteyner: zone'lar yan yana
      const container = document.createElement('div');
      container.className = 'flex gap-2 overflow-x-auto pb-2';

      // ── Tüm zone'lar root dizilimi üzerinden hizalanacak ──
      const rootLen = rootSeq.length;
      const rootMid = Math.floor(rootLen / 2);
      const rootIsOdd = rootLen % 2 === 1;

      // ── Her zone için root pozisyonlarındaki dropped set'i hesapla (zincirleme) ──
      // Zone'dan root'a giden yolu bulup, yol üzerindeki tüm drop'ları birleştir
      function getDroppedIndicesFromRoot(zoneIdx) {
        const allDropped = new Set();
        let currentIdx = zoneIdx;
        const visited = new Set();
        while (currentIdx !== undefined && !visited.has(currentIdx)) {
          visited.add(currentIdx);
          const currentZone = zoneByIndex.get(currentIdx);
          if (currentZone && currentZone.is_root) break;
          const tr = transitionByTo.get(currentIdx);
          if (!tr) break;
          if (Array.isArray(tr.dropped_indices)) {
            // Bu transition'ın dropped_indices'i parent sequence üzerinden
            // Bunları root sequence indekslerine çevirmemiz gerek
            tr.dropped_indices.forEach(di => {
              const idx = parseInt(di, 10);
              if (Number.isFinite(idx) && idx >= 0) allDropped.add(idx);
            });
          }
          const parentIndex = Array.isArray(tr.from) ? tr.from[0] : tr.from;
          currentIdx = parentIndex;
        }
        return allDropped;
      }

      sortedZones.forEach((zone) => {
        const isRoot = zone.is_root;
        const seq = Array.isArray(zone.sequence) ? zone.sequence : [];
        const seqLen = seq.length;
        const angleCounts = normalizeAngleCounts(zone.ply_counts);

        // Drop-off hesaplamaları - ROOT dizilimi üzerinden
        let droppedFromRoot = new Set();
        let parentZoneRef = null;
        if (!isRoot) {
          const tr = transitionByTo.get(zone.index);
          if (tr) {
            const parentIndex = Array.isArray(tr.from) ? tr.from[0] : tr.from;
            parentZoneRef = zoneByIndex.get(parentIndex) || null;
          }
          droppedFromRoot = getDroppedIndicesFromRoot(zone.index);
        }

        // Sütun
        const col = document.createElement('div');
        col.className = 'flex flex-col items-center min-w-[130px] max-w-[180px] flex-1 bg-white/80 border border-slate-300 rounded-lg px-2 py-2 shadow-sm';

        // Başlık
        const header = document.createElement('div');
        header.className = 'text-center mb-2 pb-1.5 border-b border-slate-200 w-full';
        let headerHTML = `
          <span class="text-[10px] font-bold ${isRoot ? 'text-blue-600' : 'text-slate-700'}">
            Zone ${zone.index + 1} ${isRoot ? '(Root)' : ''}
          </span>
          <br/>
          <span class="text-[9px] text-slate-500">${zone.ply_count} ply • ${zone.fitness.toFixed(1)}pts</span>
        `;
        header.innerHTML = headerHTML;
        col.appendChild(header);

        // Katmanlar dikey — TÜM ZONE'LAR ROOT DİZİLİMİ ÜZERİNDEN
        const layerContainer = document.createElement('div');
        layerContainer.className = 'flex flex-col items-center gap-[1px] w-full';

        rootSeq.forEach((angle, idx) => {
          // Simetri ekseni
          if (!rootIsOdd && idx === rootMid) {
            const symLine = document.createElement('div');
            symLine.className = 'w-full h-[5px] bg-amber-500 rounded-full my-1 shadow-[0_0_6px_rgba(245,158,11,0.5)]';
            symLine.title = 'Simetri Ekseni';
            layerContainer.appendChild(symLine);
          }

          const isDropped = !isRoot && droppedFromRoot.has(idx);
          const block = document.createElement('div');

          if (isDropped) {
            // Düşürülmüş katman: boşluk
            block.className = 'w-full h-4 rounded-[2px] bg-slate-200/50 border border-dashed border-slate-300';
            block.title = `${angle}° - Çıkarıldı`;
          } else {
            // Mevcut katman: renkli kutu
            block.className = `w-full h-4 rounded-[2px] ${colorMap[angle.toString()] || 'bg-slate-500'} flex items-center justify-center text-[8px] font-mono font-semibold text-white ring-1 ring-white/20`;
            block.textContent = `${angle}°`;
            block.title = `Ply ${idx + 1}: ${angle}°`;
          }

          // Simetri ekseni - tek sayıda ortadaki ply
          if (rootIsOdd && idx === rootMid) {
            block.style.position = 'relative';
            block.classList.add('ring-2', 'ring-amber-500');
          }

          layerContainer.appendChild(block);
        });

        col.appendChild(layerContainer);

        // Komşuluk bilgisi
        const zoneNeighbors = zoneNeighborMap.get(zone.index) || [];
        if (zoneNeighbors.length > 0) {
          const neighborDiv = document.createElement('div');
          neighborDiv.className = 'flex flex-wrap gap-0.5 justify-center mt-2 pt-1.5 border-t border-slate-200 w-full';
          const nLabel = document.createElement('span');
          nLabel.className = 'text-[8px] text-slate-500 w-full text-center block mb-0.5';
          nLabel.textContent = 'Komşu';
          neighborDiv.appendChild(nLabel);
          zoneNeighbors.forEach(nIdx => {
            const badge = document.createElement('span');
            badge.className = 'text-[8px] font-semibold px-1 py-0 rounded-full bg-indigo-100 text-indigo-700 border border-indigo-300';
            badge.textContent = `Zone ${nIdx + 1}`;
            neighborDiv.appendChild(badge);
          });
          col.appendChild(neighborDiv);
        }

        // Referans bilgisi (non-root, komşu zonların altında)
        if (!isRoot && parentZoneRef) {
          const refDiv = document.createElement('div');
          refDiv.className = 'flex items-center justify-center gap-1 mt-1.5 w-full';
          refDiv.innerHTML = `<span class="text-[8px] text-orange-500 font-semibold">Ref: Zone ${parentZoneRef.index + 1}</span>`;
          col.appendChild(refDiv);
        }

        // Temiz dizilim butonu (Non-root) — sağa temiz sütun açılır
        let cleanCol = null;
        if (!isRoot && droppedFromRoot.size > 0) {
          const toggleBtn = document.createElement('button');
          toggleBtn.type = 'button';
          toggleBtn.className = 'flex items-center gap-1 text-[8px] font-semibold text-slate-600 bg-slate-100 hover:bg-slate-200 px-1.5 py-0.5 rounded border border-slate-300 shadow-sm transition-all w-full justify-center mt-2';
          toggleBtn.innerHTML = `
            <svg class="w-3 h-3 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h10M4 18h16"/></svg>
            <span>Temiz Dizilim</span>
          `;
          col.appendChild(toggleBtn);

          // Sağ tarafa açılacak temiz dizilim sütunu (başlangıçta gizli)
          cleanCol = document.createElement('div');
          cleanCol.className = 'hidden flex-col items-center min-w-[130px] max-w-[180px] flex-1 bg-blue-50/80 border border-blue-300/60 rounded-lg px-2 py-2 shadow-sm';

          // Temiz dizilim başlık
          const cleanHeader = document.createElement('div');
          cleanHeader.className = 'text-center mb-2 pb-1.5 border-b border-blue-200 w-full';
          cleanHeader.innerHTML = `
            <span class="text-[10px] font-bold text-blue-600">Dizilim</span>
            <br/>
            <span class="text-[9px] text-blue-400">Zone ${zone.index + 1} (${zone.ply_count} ply)</span>
          `;
          cleanCol.appendChild(cleanHeader);

          // Temiz katmanlar — root üzerinden, dropped olanlar boşluk yok sadece kalan
          const cleanLayers = document.createElement('div');
          cleanLayers.className = 'flex flex-col items-center gap-[1px] w-full';

          // Root bazlı: aynı pozisyonlarda, dropped olanlar görünmez boşluk
          rootSeq.forEach((angle, idx) => {
            if (!rootIsOdd && idx === rootMid) {
              const symLine = document.createElement('div');
              symLine.className = 'w-full h-[5px] bg-amber-500 rounded-full my-1 shadow-[0_0_6px_rgba(245,158,11,0.5)]';
              cleanLayers.appendChild(symLine);
            }

            const isDropped = droppedFromRoot.has(idx);
            const block = document.createElement('div');

            if (isDropped) {
              // Görünmez boşluk (hizalama için yer tutucu)
              block.className = 'w-full h-4';
            } else {
              block.className = `w-full h-4 rounded-[2px] ${colorMap[angle.toString()] || 'bg-slate-500'} flex items-center justify-center text-[8px] font-mono font-semibold text-white ring-1 ring-white/20`;
              block.textContent = `${angle}°`;
              block.title = `${angle}°`;
            }

            if (rootIsOdd && idx === rootMid && !isDropped) {
              block.classList.add('ring-2', 'ring-amber-500');
            }

            cleanLayers.appendChild(block);
          });

          cleanCol.appendChild(cleanLayers);

          // Toggle logic
          toggleBtn.onclick = () => {
            const isHidden = cleanCol.classList.contains('hidden');
            if (isHidden) {
              cleanCol.classList.remove('hidden');
              cleanCol.classList.add('flex');
              toggleBtn.classList.add('bg-slate-200');
              toggleBtn.querySelector('span').textContent = 'Gizle';
            } else {
              cleanCol.classList.add('hidden');
              cleanCol.classList.remove('flex');
              toggleBtn.classList.remove('bg-slate-200');
              toggleBtn.querySelector('span').textContent = 'Temiz Dizilim';
            }
          };
        }

        // Açı sayıları (alt kısım)
        const legend = document.createElement('div');
        legend.className = 'mt-2 pt-1.5 border-t border-slate-200 w-full flex flex-col gap-0 text-[8px] font-mono';
        const angleOrder = ['0', '90', '45', '-45'];
        const angleLabels = { '0': '0°', '90': '90°', '45': '+45°', '-45': '-45°' };
        angleOrder.forEach(a => {
          const count = angleCounts[a] || 0;
          const lr = document.createElement('div');
          lr.className = 'flex items-center gap-0.5';
          lr.innerHTML = `
            <span class="w-2 h-2 rounded-[1px] ${dotColorMap[a]} inline-block flex-shrink-0"></span>
            <span class="text-slate-600">${angleLabels[a]}</span>
            <span class="ml-auto font-semibold text-slate-800">${count}</span>
          `;
          legend.appendChild(lr);
        });
        const totalRemaining = Object.values(angleCounts).reduce((s, v) => s + v, 0);
        const totalRow = document.createElement('div');
        totalRow.className = 'flex items-center gap-0.5 border-t border-slate-300 pt-0.5 mt-0.5';
        totalRow.innerHTML = `
          <span class="w-2 h-2 inline-block flex-shrink-0"></span>
          <span class="text-slate-600 font-semibold">Total</span>
          <span class="ml-auto font-bold text-slate-900">${totalRemaining}</span>
        `;
        legend.appendChild(totalRow);
        col.appendChild(legend);

        container.appendChild(col);
        // Temiz dizilim sütununu zone'un hemen sağına ekle
        if (cleanCol) {
          container.appendChild(cleanCol);
        }
      });

      laminateMapEl.appendChild(container);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAMINATE MAP VIEW TOGGLE (Yatay ↔ Dikey)
    // ═══════════════════════════════════════════════════════════════════════
    let _laminateViewMode = 'vertical'; // varsayılan dikey

    function setupLaminateViewToggle() {
      const hBtn = document.getElementById('view-horizontal-btn');
      const vBtn = document.getElementById('view-vertical-btn');
      if (!hBtn || !vBtn) return;

      function updateToggleStyle() {
        if (_laminateViewMode === 'vertical') {
          vBtn.className = 'px-2.5 py-1.5 text-xs font-semibold transition flex items-center gap-1 bg-slate-800 text-white';
          hBtn.className = 'px-2.5 py-1.5 text-xs font-semibold transition flex items-center gap-1 bg-white text-slate-500 hover:bg-slate-50';
        } else {
          hBtn.className = 'px-2.5 py-1.5 text-xs font-semibold transition flex items-center gap-1 bg-slate-800 text-white';
          vBtn.className = 'px-2.5 py-1.5 text-xs font-semibold transition flex items-center gap-1 bg-white text-slate-500 hover:bg-slate-50';
        }
      }

      hBtn.addEventListener('click', () => {
        if (_laminateViewMode === 'horizontal') return;
        _laminateViewMode = 'horizontal';
        updateToggleStyle();
        rerenderLaminateMap();
      });

      vBtn.addEventListener('click', () => {
        if (_laminateViewMode === 'vertical') return;
        _laminateViewMode = 'vertical';
        updateToggleStyle();
        rerenderLaminateMap();
      });

      updateToggleStyle();
    }

    // Mevcut verileri cache'den tekrar render et
    function rerenderLaminateMap() {
      const zones = window._laminateMapZones;
      const transitions = window._laminateMapTransitions;
      const neighborGraph = window._laminateMapNeighborGraph;
      if (!zones) return;
      if (_laminateViewMode === 'vertical') {
        renderVerticalLaminateMap(zones, transitions, neighborGraph);
      } else {
        renderMultiZoneLaminateMap(zones, transitions, neighborGraph);
      }
    }

    // Setup toggle on page load
    document.addEventListener('DOMContentLoaded', setupLaminateViewToggle);

    // Kural ikonlarını güncelleyen fonksiyon
    function updateRuleStatus(ruleNum, status) {
      const icon = document.getElementById(`rule-${ruleNum}-icon`);
      if (!icon) return;

      if (status === 'checking') {
        icon.textContent = '⏳';
        icon.className = 'w-4 h-4 flex items-center justify-center animate-pulse';
      } else if (status === 'done') {
        icon.textContent = '✅';
        icon.className = 'w-4 h-4 flex items-center justify-center';
      } else if (status === 'error') {
        icon.textContent = '❌';
        icon.className = 'w-4 h-4 flex items-center justify-center';
      }
    }

    // Yükleme animasyonu fonksiyonu
    async function showLoadingAnimation() {
      loadingOverlay.classList.remove('hidden');

      // Tüm kuralları başlangıç durumuna getir
      for (let i = 1; i <= 8; i++) {
        updateRuleStatus(i, 'checking');
      }

      const rules = [
        { num: 1, name: 'Symmetry', delay: 500 },
        { num: 2, name: 'Balance', delay: 1000 },
        { num: 3, name: 'Adjacency', delay: 1250 },
        { num: 4, name: 'External Plies', delay: 1500 },
        { num: 5, name: 'Distribution', delay: 2000 },
        { num: 6, name: 'Grouping', delay: 2500 },
        { num: 7, name: 'Buckling', delay: 3000 },
        { num: 8, name: 'Lateral Bending', delay: 3500 },
      ];

      // Progress bar animasyonu
      let progress = 0;
      progressInterval = setInterval(() => {
        progress += 2;
        if (progress > 90) progress = 90; // Backend tamamlanana kadar 90'da kal
        loadingProgress.style.width = `${progress}%`;
        loadingProgressText.textContent = `${Math.round(progress)}%`;
      }, 100);

      // Kuralları sırayla kontrol et
      for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        const prevDelay = i > 0 ? rules[i - 1].delay : 0;
        await new Promise(resolve => setTimeout(resolve, rule.delay - prevDelay));
        updateRuleStatus(rule.num, 'checking');
        loadingStatus.textContent = `Checking Rule ${rule.num}: ${rule.name}...`;

        await new Promise(resolve => setTimeout(resolve, 300));
        updateRuleStatus(rule.num, 'done');
      }

      loadingStatus.textContent = 'Running Genetic Algorithm...';
      loadingProgress.style.width = '95%';
      loadingProgressText.textContent = '95%';

      return progressInterval;
    }

    function statusColor(value, invert = false) {
      if (value === '--') return 'text-slate-600';
      const good = invert ? value < 5 : value >= 90;
      return good ? 'text-emerald-700' : 'text-rose-700';
    }

    function getPenaltyExplanation(name, val) {
      const explanations = {
        'R1_Symmetry': val === 0
          ? '✅ Mükemmel: İlk ve son katmanlar simetrik olarak eşleşiyor.'
          : '❌ Simetri bozulması: Karşılıklı katmanlar eşleşmiyor.',
        'R2_Balance': val === 0
          ? '✅ Mükemmel: +45° ve -45° sayıları dengeli (kuplaj önleme).'
          : '❌ Dengesizlik: +45° ve -45° sayıları eşit değil, kuplaj riski var.',
        'R3_Percentage': val === 0
          ? '✅ Mükemmel: Tüm açılar uygun yüzde aralığında (8%-67%).'
          : '❌ Yüzde hatası: Bazı açılar izin verilen yüzde aralığının dışında.',
        'R3_Adjacency': val === "FORBIDDEN"
          ? '🚫 YASAK: 0° ve 90° katmanları yan yana olamaz (HARD RULE ihlali - çözüm geçersiz).'
          : (val === 0
            ? '✅ Mükemmel: 0° ve 90° katmanları yan yana değil.'
            : '❌ Komşuluk hatası: 0° ve 90° katmanları yan yana olamaz.'),
        'R4_External': val === 0
          ? '✅ Mükemmel: Dış katmanlar ±45° ile başlayıp bitiyor (hasar toleransı).'
          : '❌ Dış katman hatası: İlk ve son katmanlar ±45° olmalı.',
        'R5_Distribution': val === 0
          ? '✅ Mükemmel: Açılar dönüşümlü yerleştirilmiş (tek katman tercihi).'
          : '❌ Dağılım hatası: Aynı açılı katmanlar ardışık yerleştirilmiş (dönüşümlü yerleşim tercih edilir).',
        'R6_Grouping': val === 0
          ? '✅ Mükemmel: Aynı açılı katmanlar 3\'ten fazla yan yana değil (yapısal bütünlük).'
          : '❌ Gruplama hatası: Aynı açılı katmanlar çok fazla yan yana.',
        'R7_Buckling': val === 0
          ? '✅ Mükemmel: Uç bölgelerde yeterli ±45° katmanı var (burkulma performansı).'
          : '❌ Burkulma riski: Uç bölgelerde ±45° katmanları yetersiz.',
        'R8_LateralBending': val === 0
          ? '✅ Mükemmel: 90° katmanları orta düzlemden uzakta (lateral eğilme sertliği).'
          : '❌ Lateral eğilme hatası: 90° katmanları orta düzleme çok yakın.',
        // Backward compatibility
        'R2_R5_Contiguity': val === 0
          ? '✅ Mükemmel: +45° ve -45° katmanları doğru sırada.'
          : '❌ Ardışıklık hatası: ±45° katmanları yan yana gelmeli.',
        'CLT_Imbalance': val === 0
          ? '✅ Mükemmel: +45° ve -45° sayıları dengeli.'
          : '❌ Dengesizlik: +45° ve -45° sayıları eşit değil.'
      };
      return explanations[name] || (val === 0 ? '✅ Kurala uygun.' : '❌ Kural ihlali tespit edildi.');
    }

    // ==================== İYİLEŞTİRME ÖNERİLERİ ====================
    function renderImprovementSuggestions(zones) {
      const container = document.getElementById('improvement-suggestions');
      if (!container) return;
      container.innerHTML = '';

      // Kural meta verisi: açıklama, neden kötü, genel öneri
      const ruleMeta = {
        R1: {
          name: 'R1 — Simetri',
          icon: '⚖️',
          why: 'Asimetrik laminat ısıl biçim bozukluğuna (warping) ve eğilme-bükülme eşleşmesine yol açar.',
          tip: 'Kat sırasının simetrik olması için her yönde kat sayısını iki katına çıkarın veya mevcut katların yerini değiştirin.',
          color: 'rose'
        },
        R2: {
          name: 'R2 — Denge',
          icon: '🔁',
          why: '+45° ve −45° kat sayıları eşit olmazsa laminat kayma altında burulma yapar.',
          tip: 'Her +45° katı için bir −45° katı ekleyin. Toplam ±45° çifti çift sayı olmalı.',
          color: 'orange'
        },
        R3: {
          name: 'R3 — Yüzde & Komşuluk',
          icon: '📊',
          why: '0°-90° yan yana geldiğinde arayüz gerilmeleri yüksek olur; tek bir yönde yüksek yüzde izotropik dayanımı düşürür.',
          tip: 'Her yön için %10-65 aralığını hedefleyin. 0° ve 90° katların doğrudan bitişik gelmesini önleyin.',
          color: 'amber'
        },
        R4: {
          name: 'R4 — Dış Katlar',
          icon: '🛡️',
          why: 'Dış yüzeylerde 0° kat olması burkulma ve darbe hasarı riskini artırır.',
          tip: 'İlk ve son iki kat ±45° olmalı. Laminat sırasının başına ve sonuna ±45° ekleyin.',
          color: 'violet'
        },
        R5: {
          name: 'R5 — Dağılım',
          icon: '📐',
          why: 'Aynı yöndeki katlar laminat içinde bir arada kümelenirse lokal deformasyon oluşur.',
          tip: 'Aynı yöndeki katları laminat boyunca eşit aralıklara dağıtın. Sıralamayı daha homojen yapın.',
          color: 'sky'
        },
        R6: {
          name: 'R6 — Gruplama',
          icon: '🔗',
          why: 'Art arda 4 veya daha fazla aynı yönlü kat delaminasyon ve çatlak yayılımı riskini önemli ölçüde artırır.',
          tip: 'Aynı yönde maksimum 3 kat koyun. Grupları kırmak için aralarına farklı yönlü kat ekleyin.',
          color: 'rose'
        },
        R7: {
          name: 'R7 — Burkulma',
          icon: '📏',
          why: 'Yüksek ±45° içeriği veya simetrik dağılım eksikliği burkulma mukavemetini düşürür.',
          tip: '±45° katlarını dış yüzeylere yakın tutun. Merkezde 0° yoğunluğu sağlayın.',
          color: 'teal'
        },
        R8: {
          name: 'R8 — Yanal Eğilme',
          icon: '↔️',
          why: '90° kat eksikliği yanal yük altında düşük rijitlik ve aşırı eğilmeye neden olur.',
          tip: 'Toplam kat sayısının en az %10\'u 90° olmalı. 90° katları çift-simetrik konuma yerleştirin.',
          color: 'indigo'
        }
      };

      // Tüm zone'lardaki kural ihlallerini topla
      const violations = []; // { rule, zoneName, penalty, weight, reason, percentage }
      const validZones = (zones || []).filter(z => z && z.penalties);

      validZones.forEach(z => {
        const zName = 'Zone ' + (z.index + 1) + (z.is_root ? ' (Root)' : '');
        Object.entries(z.penalties || {}).forEach(([rule, ruleData]) => {
          const weight = Number(ruleData.weight) || 0;
          const score  = Number(ruleData.score)  || 0;
          const penalty = Number(ruleData.penalty) || 0;
          const reason  = ruleData.reason || '';
          if (penalty <= 0) return; // tam uyumlu — gösterme
          const pct = weight > 0 ? (score / weight) * 100 : 0;
          violations.push({ rule, zoneName: zName, penalty, weight, score, reason, pct });
        });
      });

      if (violations.length === 0) {
        container.classList.add('hidden');
        return;
      }

      // Ceza puanına göre büyükten küçüğe sırala
      violations.sort((a, b) => b.penalty - a.penalty);

      container.classList.remove('hidden');

      // Açılır-kapanır başlık
      const header = document.createElement('button');
      header.type = 'button';
      header.className = 'improvement-suggestions-toggle w-full flex items-center gap-3 mb-4 text-left rounded-lg hover:bg-slate-50 transition-colors p-2 -m-2';
      header.setAttribute('aria-expanded', 'false');
      header.innerHTML = `
        <span class="improvement-suggestions-chevron text-slate-400 transition-transform duration-200 inline-block" style="transform: rotate(-90deg)">▼</span>
        <div class="w-1 h-8 bg-amber-500 rounded-full flex-shrink-0"></div>
        <div>
          <h3 class="text-base font-bold text-slate-900">İyileştirme Önerileri</h3>
          <p class="text-xs text-slate-500 mt-0.5">${violations.length} ihlal/uyarı tespit edildi — ceza puanına göre sıralandı</p>
        </div>
      `;
      container.appendChild(header);

      // İçerik sarmalayıcı (açılır-kapanır)
      const contentWrap = document.createElement('div');
      contentWrap.className = 'improvement-suggestions-content hidden';

      // Tablo wrapper
      const tableWrap = document.createElement('div');
      tableWrap.className = 'overflow-x-auto rounded-xl border border-slate-200 shadow-sm';

      const table = document.createElement('table');
      table.className = 'w-full text-sm border-collapse';

      // Tablo başlık satırı
      table.innerHTML = `
        <thead>
          <tr class="bg-slate-800 text-white">
            <th class="px-4 py-3 text-left font-semibold w-6">#</th>
            <th class="px-4 py-3 text-left font-semibold">Kural</th>
            <th class="px-4 py-3 text-left font-semibold">Zone</th>
            <th class="px-4 py-3 text-left font-semibold">Skor</th>
            <th class="px-4 py-3 text-left font-semibold">Neden Kötü?</th>
            <th class="px-4 py-3 text-left font-semibold">Ne Yapmalısın?</th>
          </tr>
        </thead>
      `;

      const tbody = document.createElement('tbody');

      violations.forEach((v, idx) => {
        const meta = ruleMeta[v.rule] || { name: v.rule, icon: '⚠️', why: v.reason || '—', tip: '—', color: 'slate' };
        const isWarn = v.pct >= 70; // %70+ → uyarı (sarı), altı → hata (kırmızı)
        const severityLabel = isWarn
          ? `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium bg-amber-100 text-amber-700">⚠ Uyarı</span>`
          : `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium bg-rose-100 text-rose-700">✗ İhlal</span>`;

        const rowBg = idx % 2 === 0 ? 'bg-white' : 'bg-slate-50/70';
        const tr = document.createElement('tr');
        tr.className = `${rowBg} border-b border-slate-100 hover:bg-blue-50/40 transition-colors`;
        tr.innerHTML = `
          <td class="px-4 py-3 font-mono text-slate-400 text-xs">${idx + 1}</td>
          <td class="px-4 py-3">
            <div class="flex items-center gap-2">
              <span class="text-lg">${meta.icon}</span>
              <div>
                <div class="font-semibold text-slate-800">${meta.name}</div>
                ${severityLabel}
              </div>
            </div>
          </td>
          <td class="px-4 py-3 font-medium text-slate-700">${v.zoneName}</td>
          <td class="px-4 py-3">
            <div class="font-mono text-sm ${isWarn ? 'text-amber-600' : 'text-rose-600'} font-bold">${v.score.toFixed(1)} / ${v.weight.toFixed(1)}</div>
            <div class="w-full bg-slate-200 rounded-full h-1.5 mt-1">
              <div class="h-1.5 rounded-full ${isWarn ? 'bg-amber-400' : 'bg-rose-400'}" style="width:${Math.max(v.pct,2).toFixed(0)}%"></div>
            </div>
            <div class="text-xs text-slate-400 mt-0.5">${v.pct.toFixed(0)}%</div>
          </td>
          <td class="px-4 py-3 text-slate-600 text-xs leading-relaxed max-w-[220px]">${meta.why}</td>
          <td class="px-4 py-3 text-slate-700 text-xs leading-relaxed max-w-[240px] font-medium">${meta.tip}</td>
        `;
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      tableWrap.appendChild(table);
      contentWrap.appendChild(tableWrap);

      // Alt not
      const note = document.createElement('p');
      note.className = 'text-xs text-slate-400 mt-3 italic';
      note.textContent = 'Bu öneriler mevcut optimizasyon sonucuna göre otomatik oluşturulmuştur. Ağırlıkları değiştirip tekrar optimize ederek iyileştirme sağlayabilirsiniz.';
      contentWrap.appendChild(note);

      container.appendChild(contentWrap);

      // Aç/kapa tıklama
      header.addEventListener('click', function () {
        const contentWrap = container.querySelector('.improvement-suggestions-content');
        if (!contentWrap) return;
        const isCollapsed = contentWrap.classList.toggle('hidden');
        header.setAttribute('aria-expanded', !isCollapsed);
        const chevron = header.querySelector('.improvement-suggestions-chevron');
        if (chevron) chevron.style.transform = isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)';
      });
    }

    function renderPenalties(penalties) {
      penaltyListEl.innerHTML = '';
      const entries = Object.entries(penalties);
      if (!entries.length) {
        penaltyListEl.innerHTML = '<p class="text-slate-600 text-sm">No penalties recorded.</p>';
        return;
      }

      // Rule name mapping
      const ruleNames = {
        'R1': 'Symmetry',
        'R2': 'Balance',
        'R3': 'Adjacency',
        'R4': 'External Plies',
        'R5': 'Distribution',
        'R6': 'Grouping',
        'R7': 'Buckling',
        'R8': 'Lateral Bending'
      };

      // Rule purpose is shown in the right-side panel; keep rows compact here.

      entries.forEach(([ruleName, ruleData]) => {
        // Handle new format: ruleData is { weight, score, penalty, reason }
        const container = document.createElement('div');
        container.className = 'bg-white/70 backdrop-blur border border-slate-300/60 rounded-md px-3 py-2 space-y-1 shadow-sm';

        const row = document.createElement('div');
        row.className = 'flex items-center justify-between';

        let weight, score, penalty, reason;
        if (typeof ruleData === 'object' && ruleData !== null && 'weight' in ruleData) {
          // New format
          weight = Number(ruleData.weight) || 0;
          score = Number(ruleData.score) || 0;
          penalty = Number(ruleData.penalty) || 0;
          reason = ruleData.reason || '';
        } else {
          // Legacy format (should not happen, but handle gracefully)
          weight = 100;
          score = typeof ruleData === 'number' ? (100 - ruleData) : 0;
          penalty = typeof ruleData === 'number' ? ruleData : 0;
          reason = '';
        }

        // Calculate percentage
        const percentage = weight > 0 ? (score / weight) * 100 : 0;

        // Determine color based on penalty
        const scoreColor = penalty === 0 ? 'text-emerald-700' : 'text-rose-700';

        // Display rule name with full name
        const fullRuleName = ruleNames[ruleName] ? `${ruleName} - ${ruleNames[ruleName]}` : ruleName;

        row.innerHTML = `<span class="text-slate-800 font-semibold">${fullRuleName}</span><span class="font-mono ${scoreColor}">${score.toFixed(2)} / ${weight.toFixed(2)} (${percentage.toFixed(1)}%)</span>`;

        const explanation = document.createElement('div');
        explanation.className = 'text-xs text-slate-600 mt-1';
        if (reason) {
          explanation.textContent = `❌ ${reason}`;
        } else {
          explanation.textContent = '✅ Kurala uygun.';
        }

        container.appendChild(row);
        container.appendChild(explanation);
        penaltyListEl.appendChild(container);
      });
    }

    // ==================== ZONE SCORE CARDS ====================
    function renderZoneScoreCards(zones) {
      const container = document.getElementById('zone-score-cards');
      if (!container) return;
      container.innerHTML = '';

      const sortedZones = [...zones].filter(z => z !== null).sort((a, b) => b.ply_count - a.ply_count);

      const ruleNames = {
        'R1': 'Sym', 'R2': 'Bal', 'R3': 'Pct',
        'R4': 'Ext', 'R5': 'Dis', 'R6': 'Grp',
        'R7': 'Bck', 'R8': 'Lat'
      };

      sortedZones.forEach(zone => {
        const isRoot = zone.is_root;
        const fitness = zone.fitness || 0;
        const plyCount = zone.ply_count || 0;
        const penalties = zone.penalties || {};

        // Uyari ikonu: herhangi bir penalty > 0 ise goster
        const hasWarning = Object.values(penalties).some(r => {
          if (typeof r === 'object' && r !== null) return (r.penalty || 0) > 0;
          return r > 0;
        });

        const card = document.createElement('div');
        card.className = 'bg-white/80 backdrop-blur border border-slate-200 rounded-xl p-4 shadow-sm cursor-pointer hover:shadow-md hover:border-slate-300 transition-all relative';
        card.addEventListener('click', () => openZoneDetailModal(zone));

        // Uyari ikonu
        const warningHtml = hasWarning
          ? '<span class="absolute top-3 right-3 text-amber-500 text-lg" title="Kural ihlali mevcut">&#9888;</span>'
          : '<span class="absolute top-3 right-3 text-emerald-500 text-lg" title="Tum kurallar uygun">&#10003;</span>';

        // Kural skorlari tablosu
        let rulesHtml = '';
        const entries = Object.entries(penalties);
        // 2 sutunlu gosterim
        for (let i = 0; i < entries.length; i += 2) {
          rulesHtml += '<div class="flex gap-4">';
          for (let j = i; j < Math.min(i + 2, entries.length); j++) {
            const [rKey, rData] = entries[j];
            const shortName = ruleNames[rKey] || rKey;
            let score, weight;
            if (typeof rData === 'object' && rData !== null && 'weight' in rData) {
              score = Number(rData.score) || 0;
              weight = Number(rData.weight) || 0;
            } else {
              score = 0; weight = 0;
            }
            const scoreColor = (rData.penalty || 0) === 0 ? 'text-emerald-700' : 'text-rose-600';
            rulesHtml += `<div class="flex-1 flex justify-between"><span class="text-slate-500">${shortName}:</span><span class="font-mono ${scoreColor}">${score.toFixed(score % 1 === 0 ? 0 : 2)} / ${weight.toFixed(0)}</span></div>`;
          }
          rulesHtml += '</div>';
        }

        card.innerHTML = `
          ${warningHtml}
          <div class="flex items-center justify-between mb-1">
            <span class="text-sm font-bold text-slate-900">Zone ${zone.index + 1}</span>
          </div>
          <div class="text-4xl font-bold ${fitness >= 90 ? 'text-emerald-600' : fitness >= 70 ? 'text-amber-600' : 'text-rose-600'}">${fitness.toFixed(1)}</div>
          <div class="text-xs text-slate-500 mt-0.5">${plyCount} ply</div>
          ${isRoot ? '<div class="text-xs font-bold text-blue-600 mt-1">MASTER</div>' : ''}
          <div class="mt-3 pt-3 border-t border-slate-100 space-y-1 text-[11px]">
            ${rulesHtml}
          </div>
        `;

        container.appendChild(card);
      });
    }

    // ==================== ZONE DETAIL MODAL ====================
    function openZoneDetailModal(zone) {
      const modal = document.getElementById('zone-detail-modal');
      const title = document.getElementById('zone-modal-title');
      const subtitle = document.getElementById('zone-modal-subtitle');
      const penaltiesContainer = document.getElementById('zone-modal-penalties');
      if (!modal || !title || !subtitle || !penaltiesContainer) return;

      const isRoot = zone.is_root;
      title.textContent = `Zone ${zone.index + 1}${isRoot ? ' (Master)' : ''}`;
      subtitle.textContent = `${zone.ply_count} ply \u00b7 Fitness: ${zone.fitness.toFixed(1)} / 100`;

      // Render penalties
      penaltiesContainer.innerHTML = '';
      const penalties = zone.penalties || {};
      const ruleFullNames = {
        'R1': 'Symmetry', 'R2': 'Balance', 'R3': 'Percentage / Adjacency',
        'R4': 'External Plies', 'R5': 'Distribution', 'R6': 'Grouping',
        'R7': 'Buckling', 'R8': 'Lateral Bending'
      };

      Object.entries(penalties).forEach(([ruleName, ruleData]) => {
        const container = document.createElement('div');
        container.className = 'bg-white/70 border border-slate-200 rounded-lg px-3 py-2.5 space-y-1';

        let weight, score, penalty, reason;
        if (typeof ruleData === 'object' && ruleData !== null && 'weight' in ruleData) {
          weight = Number(ruleData.weight) || 0;
          score = Number(ruleData.score) || 0;
          penalty = Number(ruleData.penalty) || 0;
          reason = ruleData.reason || '';
        } else {
          weight = 100; score = 0; penalty = 0; reason = '';
        }

        const percentage = weight > 0 ? (score / weight) * 100 : 0;
        const scoreColor = penalty === 0 ? 'text-emerald-700' : 'text-rose-700';
        const fullName = ruleFullNames[ruleName] ? `${ruleName} \u2014 ${ruleFullNames[ruleName]}` : ruleName;

        const row = document.createElement('div');
        row.className = 'flex items-center justify-between';
        row.innerHTML = `<span class="text-slate-800 font-semibold">${fullName}</span><span class="font-mono ${scoreColor}">${score.toFixed(2)} / ${weight} (${percentage.toFixed(1)}%)</span>`;

        const explanation = document.createElement('div');
        explanation.className = 'text-xs text-slate-600';
        explanation.innerHTML = reason
          ? `<span class="text-rose-600 font-medium">\u2718 Kural ihlali.</span>`
          : `<span class="text-emerald-600 font-medium">\u2714 Kurala uygun.</span>`;

        container.appendChild(row);
        container.appendChild(explanation);
        penaltiesContainer.appendChild(container);
      });

      // Show modal
      modal.classList.remove('hidden');
    }

    // Modal close handlers
    (function () {
      const modal = document.getElementById('zone-detail-modal');
      const closeBtn = document.getElementById('zone-modal-close');
      const backdrop = document.getElementById('zone-modal-backdrop');
      if (!modal) return;
      function closeModal() { modal.classList.add('hidden'); }
      if (closeBtn) closeBtn.addEventListener('click', closeModal);
      if (backdrop) backdrop.addEventListener('click', closeModal);
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });
    })();

    function renderChart() {
      // Chart removed per request; keep stub to avoid errors.
    }

    function renderLaminateMap(masterSeq, dropResults) {
      laminateMapEl.innerHTML = '';
      const colorMap = {
        '0': 'bg-emerald-500',
        '90': 'bg-sky-500',
        '45': 'bg-rose-500',
        '-45': 'bg-amber-500',
      };

      // Build sequence chain to track what was removed from where
      const sequenceChain = [masterSeq];
      dropResults.forEach(r => sequenceChain.push(r.seq));

      const stacks = [{ title: `Root (${masterSeq.length} ply)`, seq: masterSeq, isRoot: true }, ...dropResults.map((r, i) => ({ title: `Zone ${i + 1} (${r.target} ply)`, seq: r.seq, isRoot: false, dropData: r, prevSeq: sequenceChain[i] }))];
      const maxLen = masterSeq.length || 1;

      stacks.forEach((stack, stackIdx) => {
        // Container for each stack row
        const stackContainer = document.createElement('div');
        stackContainer.className = 'space-y-2';

        const row = document.createElement('div');
        row.className = 'flex items-start gap-4';

        const label = document.createElement('div');
        label.className = 'w-28 text-right text-xs text-slate-600 font-medium pt-1';
        label.textContent = stack.title;
        row.appendChild(label);

        const gridWrapper = document.createElement('div');
        gridWrapper.className = 'relative flex-1';

        const grid = document.createElement('div');
        grid.className = 'flex flex-wrap gap-[2px] bg-slate-100 p-2 rounded-md border border-slate-300 relative';

        // Açı sayılarını hesapla
        const angleCounts = { 0: 0, 90: 0, 45: 0, '-45': 0 };
        stack.seq.forEach(angle => {
          const key = angle.toString();
          if (key in angleCounts) angleCounts[key]++;
        });
        const spacer = Math.floor((maxLen - stack.seq.length) / 2);

        // Add spacer blocks
        for (let i = 0; i < spacer; i++) {
          const empty = document.createElement('div');
          empty.className = 'w-7 h-7';
          grid.appendChild(empty);
        }

        // Add sequence blocks
        const seqLen = stack.seq.length;
        const midIndex = Math.floor(seqLen / 2);

        const isOddCount = seqLen % 2 === 1;  // Tek sayıda ply mı?

        stack.seq.forEach((angle, idx) => {
          // Orta çizgisi - Tek sayıda: ortadaki ply'ın üzerine, Çift sayıda: iki ply arasına
          if (!isOddCount && idx === midIndex) {
            // Çift sayıda: İki ply arasına çizgi
            const centerLine = document.createElement('div');
            centerLine.className = 'relative w-0 h-7 flex items-center justify-center';
            centerLine.innerHTML = `
                <div class="absolute w-[3px] h-10 bg-amber-500 z-10 shadow-[0_0_8px_rgba(245,158,11,0.35)]" style="margin-left: -1.5px;"></div>
              `;
            grid.appendChild(centerLine);
          }

          // Bu pozisyon drop-off'lardan birinde düşürülmüş mü kontrol et
          let isDropped = false;
          let droppedInZone = '';

          // Her stack için bir sonraki zone'daki drop'ları kontrol et
          // Root (stackIdx=0) → Zone 1 (dropResults[0]) kontrol eder
          // Zone 1 (stackIdx=1) → Zone 2 (dropResults[1]) kontrol eder, vb.
          if (stackIdx < dropResults.length) {
            const nextDropData = dropResults[stackIdx];
            if (nextDropData && nextDropData.dropped && nextDropData.dropped.includes(idx)) {
              isDropped = true;
              droppedInZone = `Zone ${stackIdx + 1}`;
            }
          }

          const block = document.createElement('div');
          let blockClass = `w-7 h-7 rounded-sm ${colorMap[angle.toString()] || 'bg-slate-500'} flex items-center justify-center text-[9px] font-mono font-semibold text-white shadow-sm transition-all ring-1 ring-white/30`;

          // Düşürülmüş katman ise özel styling
          if (isDropped) {
            blockClass += ' opacity-30 line-through border-2 border-rose-500 border-dashed relative ring-0';
            block.title = `${angle}° - ${droppedInZone}'da çıkarıldı (Pozisyon ${idx})`;

            // Üzerine X işareti ekle
            const deleteIcon = document.createElement('div');
            deleteIcon.className = 'absolute -top-1 -right-1 w-3 h-3 bg-rose-600 rounded-full flex items-center justify-center text-[8px] text-white shadow-sm';
            deleteIcon.textContent = '✕';
            deleteIcon.style.fontSize = '8px';
            deleteIcon.style.lineHeight = '1';
            block.style.position = 'relative';
          } else {
            block.title = `${angle}°`;
          }

          block.className = blockClass;
          block.textContent = `${angle}°`;
          block.dataset.index = idx; // Index'i sakla
          block.dataset.angle = angle; // Açıyı sakla

          // Tek sayıda ply: Ortadaki ply'ın ortasına simetri çizgisi ekle
          if (isOddCount && idx === midIndex) {
            block.style.position = 'relative';
            const centerLineOnPly = document.createElement('div');
            centerLineOnPly.className = 'absolute left-1/2 top-0 w-[3px] h-full bg-amber-500 z-20 shadow-[0_0_8px_rgba(245,158,11,0.35)]';
            centerLineOnPly.style.transform = 'translateX(-50%)';
            centerLineOnPly.style.height = '40px';  // Ply'dan biraz taşsın
            centerLineOnPly.style.top = '-6px';
            block.appendChild(centerLineOnPly);
            block.title += ' (Simetri Ekseni)';
          }

          // Sadece master sequence (root) için drag-and-drop özelliği (düşürülmemiş katmanlar için)
          if (stackIdx === 0 && stack.isRoot && !isDropped) {
            block.draggable = true;
            block.className += ' cursor-move hover:scale-110 hover:ring-2 hover:ring-blue-500/40';
            block.title = `Sürükle-bırak ile taşı: ${angle}°`;

            // Drag başladığında
            block.addEventListener('dragstart', (e) => {
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', idx.toString());
              block.style.opacity = '0.5';
              e.target.classList.add('dragging');
            });

            // Drag bittiğinde
            block.addEventListener('dragend', (e) => {
              block.style.opacity = '1';
              e.target.classList.remove('dragging');
              // Tüm drop zone'ların highlight'ını kaldır
              grid.querySelectorAll('.drop-zone-active').forEach(el => {
                el.classList.remove('drop-zone-active');
              });
            });

            // Üzerine gelindiğinde (dragover)
            block.addEventListener('dragover', (e) => {
              if (e.preventDefault) {
                e.preventDefault(); // Drop izni ver
              }
              e.dataTransfer.dropEffect = 'move';

              // Sadece başka bir block'un üzerindeyse highlight yap
              if (!e.target.classList.contains('dragging') && e.target.dataset.index !== undefined) {
                e.target.classList.add('drop-zone-active');
              }
              return false;
            });

            // Üzerinden çıkıldığında
            block.addEventListener('dragleave', (e) => {
              e.target.classList.remove('drop-zone-active');
            });

            // Drop edildiğinde
            block.addEventListener('drop', (e) => {
              if (e.stopPropagation) {
                e.stopPropagation(); // Event bubbling'i durdur
              }

              const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
              const dropIndex = parseInt(e.target.dataset.index);

              // Geçerli değer kontrolü
              if (isNaN(draggedIndex) || isNaN(dropIndex)) {
                e.target.classList.remove('drop-zone-active');
                return false;
              }

              // Aynı pozisyona drop edilirse bir şey yapma
              if (draggedIndex === dropIndex) {
                e.target.classList.remove('drop-zone-active');
                return false;
              }

              // Katmanları swap et
              const draggedAngle = stack.seq[draggedIndex];
              const dropAngle = stack.seq[dropIndex];

              stack.seq[draggedIndex] = dropAngle;
              stack.seq[dropIndex] = draggedAngle;

              // currentMasterSequence'ı güncelle
              if (currentMasterSequence) {
                currentMasterSequence[draggedIndex] = dropAngle;
                currentMasterSequence[dropIndex] = draggedAngle;
              }

              // DOM'u güncelle - block'ların içeriğini ve rengini değiştir
              const draggedBlock = grid.querySelector(`[data-index="${draggedIndex}"]`);
              const dropBlock = grid.querySelector(`[data-index="${dropIndex}"]`);

              if (draggedBlock && dropBlock) {
                draggedBlock.textContent = `${dropAngle}°`;
                draggedBlock.dataset.angle = dropAngle;
                draggedBlock.className = `w-7 h-7 rounded-sm ${colorMap[dropAngle.toString()]} flex items-center justify-center text-[9px] font-mono font-semibold text-white shadow-sm transition-all ring-1 ring-white/30 cursor-move hover:scale-110 hover:ring-2 hover:ring-blue-500/40`;
                draggedBlock.title = `Sürükle-bırak ile taşı: ${dropAngle}°`;

                dropBlock.textContent = `${draggedAngle}°`;
                dropBlock.dataset.angle = draggedAngle;
                dropBlock.className = `w-7 h-7 rounded-sm ${colorMap[draggedAngle.toString()]} flex items-center justify-center text-[9px] font-mono font-semibold text-white shadow-sm transition-all ring-1 ring-white/30 cursor-move hover:scale-110 hover:ring-2 hover:ring-blue-500/40`;
                dropBlock.title = `Sürükle-bırak ile taşı: ${draggedAngle}°`;
              }

              e.target.classList.remove('drop-zone-active');
              return false;
            });
          } else {
            block.title = `${angle}°`;
          }

          grid.appendChild(block);
        });

        gridWrapper.appendChild(grid);
        row.appendChild(gridWrapper);

        // Sağ tarafta açı sayılarını göster
        const angleCountsDiv = document.createElement('div');
        angleCountsDiv.className = 'w-36 text-xs pt-1 space-y-0.5 bg-white/70 backdrop-blur border border-slate-300/60 rounded-md px-2 py-1.5 shadow-sm';
        angleCountsDiv.innerHTML = `
            <div class="flex justify-between"><span class="text-emerald-700 font-medium">0°:</span> <span class="font-mono text-slate-800">${angleCounts['0']}</span></div>
            <div class="flex justify-between"><span class="text-sky-700 font-medium">90°:</span> <span class="font-mono text-slate-800">${angleCounts['90']}</span></div>
            <div class="flex justify-between"><span class="text-rose-700 font-medium">45°:</span> <span class="font-mono text-slate-800">${angleCounts['45']}</span></div>
            <div class="flex justify-between"><span class="text-amber-700 font-medium">-45°:</span> <span class="font-mono text-slate-800">${angleCounts['-45']}</span></div>
          `;
        row.appendChild(angleCountsDiv);

        stackContainer.appendChild(row);

        // Drop-off optimization rules explanation for zones
        if (!stack.isRoot && stack.dropData && stack.prevSeq) {
          const droppedIndices = stack.dropData.dropped || [];
          const droppedCount = droppedIndices.length;
          const removedPairs = droppedCount / 2;

          // Get removed ply angles from previous sequence
          const removedPlies = droppedIndices.map(idx => stack.prevSeq[idx]).filter(a => a !== undefined);

          // Count removed plies by angle and group their positions
          const removedCounts = {};
          const removedPositionsByAngle = {};

          droppedIndices.forEach(idx => {
            const angle = stack.prevSeq[idx];
            if (angle !== undefined) {
              removedCounts[angle] = (removedCounts[angle] || 0) + 1;
              if (!removedPositionsByAngle[angle]) {
                removedPositionsByAngle[angle] = [];
              }
              removedPositionsByAngle[angle].push(idx);
            }
          });

          // Format removed plies display
          const removedDisplay = Object.entries(removedCounts)
            .map(([angle, count]) => `${angle}° (${count})`)
            .join(', ') || 'Yok';

          // Format removed positions by angle
          const removedPositionsDisplay = Object.entries(removedPositionsByAngle)
            .map(([angle, positions]) => {
              const sortedPos = positions.sort((a, b) => a - b);
              return `<div class="ml-4"><span class="text-rose-700 font-mono font-semibold">${angle}°</span> → Pozisyon: <span class="font-mono text-slate-800">${sortedPos.join(', ')}</span></div>`;
            })
            .join('') || '<div class="ml-4 text-slate-600">Yok</div>';

          const rulesInfo = document.createElement('div');
          rulesInfo.className = 'ml-32 bg-slate-50 border border-slate-200 rounded-md px-3 py-2 text-xs text-slate-600 shadow-sm';
          rulesInfo.innerHTML = `
              <div class="flex items-start gap-2">
                <span class="text-blue-700 text-base">⚙️</span>
                <div class="flex-1 space-y-1.5">
                  <div class="font-semibold text-slate-800 mb-1.5">Drop-Off Bilgisi:</div>
                  <div class="flex items-start gap-2">
                    <span class="text-rose-700 font-mono">✗</span>
                    <div class="flex-1">
                      <div><span class="text-slate-700">Çıkarılan Ply'ler:</span> <span class="font-mono text-rose-700 font-semibold">${removedDisplay}</span> (toplam ${droppedCount} ply)</div>
                      <div class="mt-1.5 pt-1.5 border-t border-slate-200">
                        <div class="text-slate-600 mb-1">Çıkarılan Pozisyonlar:</div>
                        ${removedPositionsDisplay}
                  </div>
                  </div>
                  </div>
                </div>
              </div>
            `;
          stackContainer.appendChild(rulesInfo);
        }

        laminateMapEl.appendChild(stackContainer);
      });
    }

    function renderSummary(data) {
      const stats = data.stats || {};
      summaryRuntimeEl.textContent = `Süre: ${stats.duration_seconds ?? '--'}s`;
      summaryParamsEl.innerHTML = `
          <div>Popülasyon: <span class="font-mono text-slate-900">${stats.population_size ?? '--'}</span></div>
          <div>Jenerasyon: <span class="font-mono text-slate-900">${stats.generations ?? '--'}</span></div>
          <div>Toplam Ply: <span class="font-mono text-slate-900">${stats.plies ?? '--'}</span></div>
        `;
      summaryMasterEl.innerHTML = '';
      (data.master_sequence || []).forEach((ang) => {
        const chip = document.createElement('span');
        chip.className = 'px-2 py-1 rounded-md bg-white/70 backdrop-blur border border-slate-300/60 text-xs font-mono text-slate-800 shadow-sm';
        chip.textContent = `${ang}°`;
        summaryMasterEl.appendChild(chip);
      });
      const drops = data.drop_off_results || [];
      if (!drops.length) {
        summaryDropEl.innerHTML = '<div class="text-slate-600">Drop-off uygulanmadı.</div>';
      } else {
        summaryDropEl.innerHTML = '';
        drops.forEach((d) => {
          const row = document.createElement('div');
          row.className = 'flex items-center justify-between bg-white/70 backdrop-blur border border-slate-300/60 rounded-md px-2 py-1 shadow-sm';
          const score = d.score ?? 0;
          // Drop-off skorları yeşil renkte, 100 üzerinden göster
          row.innerHTML = `<span class="text-slate-700">Hedef ${d.target} ply</span><span class="font-mono text-emerald-700">${score.toFixed(2)} / 100</span>`;
          summaryDropEl.appendChild(row);
        });
      }
    }

    async function runOptimization(formData) {
      // Loading animasyonunu başlat
      const progressInterval = await showLoadingAnimation();

      runMetaEl.textContent = 'Running...';
      const payload = {
        ply_counts: {
          0: Number(formData.get('0')),
          90: Number(formData.get('90')),
          45: Number(formData.get('45')),
          '-45': Number(formData.get('-45')),
        },
        population_size: Number(formData.get('population_size')),
        generations: Number(formData.get('generations')),
      };

      try {
        const response = await fetch(`${API_BASE}/optimize`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!response.ok) throw new Error('Optimization failed');

        const data = await response.json();

        // Simetri kontrolü - kullanıcı seçimi gerekiyor mu?
        if (data.requires_symmetry_choice) {
          if (progressInterval) clearInterval(progressInterval);
          loadingOverlay.classList.add('hidden');

          return new Promise((resolve, reject) => {
            showSymmetryWarning(data.symmetry_info, async (choice) => {
              if (choice === null) {
                // Kullanıcı "mevcut sayılarla devam" seçti - null gönder
                payload.symmetry_user_choice = { continue_with_current: true };
              } else {
                // Kullanıcı bir öneri seçti
                payload.symmetry_user_choice = choice;
              }

              // Loading'i yeniden başlat
              const newProgressInterval = await showLoadingAnimation();
              runMetaEl.textContent = 'Running...';

              try {
                const retryResponse = await fetch(`${API_BASE}/optimize`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload),
                });
                if (!retryResponse.ok) throw new Error('Optimization failed');

                // Progress'i tamamla
                if (newProgressInterval) clearInterval(newProgressInterval);
                loadingProgress.style.width = '100%';
                loadingProgressText.textContent = '100%';
                loadingStatus.textContent = 'Optimization Complete!';

                await new Promise(r => setTimeout(r, 500));
                loadingOverlay.classList.add('hidden');

                const retryData = await retryResponse.json();
                resolve(retryData);
              } catch (err) {
                if (newProgressInterval) clearInterval(newProgressInterval);
                loadingOverlay.classList.add('hidden');
                reject(err);
              }
            });
          });
        }

        // Progress'i tamamla
        if (progressInterval) clearInterval(progressInterval);
        loadingProgress.style.width = '100%';
        loadingProgressText.textContent = '100%';
        loadingStatus.textContent = 'Optimization Complete!';

        await new Promise(resolve => setTimeout(resolve, 500));
        loadingOverlay.classList.add('hidden');

        return data;
      } catch (error) {
        if (progressInterval) clearInterval(progressInterval);
        loadingOverlay.classList.add('hidden');
        throw error;
      }
    }

    multizoneForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const formData = new FormData(multizoneForm);
      try {
        const data = await runOptimization(formData);
        emptyState.classList.add('hidden');
        resultsSection.classList.remove('hidden');

        // Zone management için master sequence'i sakla
        currentMasterSequence = data.master_sequence || [];
        originalMasterSequence = data.master_sequence || []; // Orijinal master'ı sakla

        // Ply counts'u önce set et (root zone oluşturulmadan önce)
        currentPlyCounts = {
          0: Number(formData.get('0')),
          90: Number(formData.get('90')),
          45: Number(formData.get('45')),
          '-45': Number(formData.get('-45')),
        };

        if (data.master_sequence) {
          // Zone management section'ı göster
          zoneManagementSection.classList.remove('hidden');

          // Root zone'u otomatik oluştur
          try {
            const initResponse = await fetch(`${API_BASE}/zones/init_root`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                session_id: currentSessionId,
                master_sequence: data.master_sequence,
                ply_counts: currentPlyCounts
              })
            });
            if (initResponse.ok) {
              const initData = await initResponse.json();
              currentZones = initData.all_zones || [];
              currentTransitions = initData.transitions || [];
              lastDropoffSourceZoneId = 0; // Root zone ID
              renderZoneList();
              renderZoneDiagram();
              updateZoneSelects();
            }
          } catch (error) {
            console.error('Root zone oluşturma hatası:', error);
          }
        }

        // Fitness Score: Display as total_score / max_score
        const fitnessScore = Number(data.fitness_score) || 0;
        const maxScore = Number(data.max_score) || 100;
        const fitnessPercentage = maxScore > 0 ? (fitnessScore / maxScore) * 100 : 0;
        fitnessScoreEl.textContent = `${fitnessScore.toFixed(2)} / ${maxScore.toFixed(2)}`;
        fitnessScoreEl.className = `text-3xl font-bold ${fitnessPercentage >= 90 ? 'text-emerald-700' : fitnessPercentage >= 70 ? 'text-amber-700' : 'text-rose-700'}`;

        // Fitness hint: Show percentage and status
        fitnessHintEl.innerHTML = `
            <span class="text-slate-500">💡</span> 
            ${fitnessPercentage >= 90 ? 'Mükemmel' : fitnessPercentage >= 70 ? 'İyi' : 'Geliştirilebilir'} skor (${fitnessPercentage.toFixed(1)}%).
          `;

        // Symmetry Score: Use new format
        const symRule = data.penalties?.R1;
        let symScore = 0, symWeight = 100, symPenalty = 0, symReason = '';
        if (symRule && typeof symRule === 'object') {
          symScore = Number(symRule.score) || 0;
          symWeight = Number(symRule.weight) || 100;
          symPenalty = Number(symRule.penalty) || 0;
          symReason = symRule.reason || '';
        }
        const symPercentage = symWeight > 0 ? (symScore / symWeight) * 100 : 0;
        symmetryPenaltyEl.textContent = `${symScore.toFixed(2)} / ${symWeight.toFixed(2)}`;
        symmetryPenaltyEl.className = `text-2xl font-mono mt-2 ${symPenalty === 0 ? 'text-emerald-700' : 'text-rose-700'}`;
        symmetryHintEl.innerHTML = `
            <span class="text-slate-500">💡</span> 
            ${symPenalty === 0 ? 'Mükemmel simetri: İlk ve son katmanlar eşleşiyor.' : `Simetri hatası: ${symReason || `${symPenalty.toFixed(2)} puan kaybı`}.`}
          `;

        // Balance Score: Use new format
        const balanceRule = data.penalties?.R2;
        let balanceScore = 0, balanceWeight = 100, balancePenalty = 0, balanceReason = '';
        if (balanceRule && typeof balanceRule === 'object') {
          balanceScore = Number(balanceRule.score) || 0;
          balanceWeight = Number(balanceRule.weight) || 100;
          balancePenalty = Number(balanceRule.penalty) || 0;
          balanceReason = balanceRule.reason || '';
        }
        const balancePercentage = balanceWeight > 0 ? (balanceScore / balanceWeight) * 100 : 0;
        balanceScoreEl.textContent = `${balanceScore.toFixed(2)} / ${balanceWeight.toFixed(2)}`;
        balanceScoreEl.className = `text-2xl font-mono mt-2 ${balancePenalty === 0 ? 'text-emerald-700' : 'text-rose-700'}`;
        balanceHintEl.innerHTML = `
            <span class="text-slate-500">💡</span> 
            ${balancePenalty === 0 ? 'Dengeli: +45° ve -45° sayıları eşit (kuplaj önleme).' : `Dengesizlik: ${balanceReason || `${balancePenalty.toFixed(2)} puan kaybı`}.`}
          `;

        statsMetaEl.textContent = `${data.stats.plies} ply • pop ${data.stats.population_size} • ${data.stats.generations} generations • ${data.stats.duration_seconds}s`;
        runMetaEl.textContent = `Completed in ${data.stats.duration_seconds}s`;

        // Current sequence ve ply counts'u sakla
        currentMasterSequence = [...(data.master_sequence || [])];
        originalMasterSequence = [...(data.master_sequence || [])]; // Orijinal master sequence'ı sakla
        currentPlyCounts = {
          0: Number(formData.get('0')),
          90: Number(formData.get('90')),
          45: Number(formData.get('45')),
          '-45': Number(formData.get('-45')),
        };
        dropOffResults = [...(data.drop_off_results || [])]; // Drop-off sonuçlarını sakla

        // Mevcut ply sayısını güncelle
        if (currentPlyCountEl) {
          currentPlyCountEl.textContent = currentMasterSequence.length;
        }

        renderSummary(data);
        renderPenalties(data.penalties || {});
        renderChart(data.history || []);
        renderLaminateMap(data.master_sequence || [], dropOffResults);
      } catch (err) {
        console.error(err);
        runMetaEl.textContent = 'Error: ' + err.message;
      }
    });

    // Drop-Off butonu event listener
    if (applyDropoffBtn && dropoffTargetInput) {
      applyDropoffBtn.addEventListener('click', async () => {
        if (!currentMasterSequence || !currentPlyCounts) {
          alert('Lütfen önce bir optimizasyon çalıştırın.');
          return;
        }

        const targetPly = parseInt(dropoffTargetInput.value);
        if (isNaN(targetPly) || targetPly <= 0) {
          alert('Lütfen geçerli bir ply sayısı girin.');
          return;
        }

        if (targetPly >= currentMasterSequence.length) {
          alert(`Hedef ply sayısı (${targetPly}) mevcut ply sayısından (${currentMasterSequence.length}) küçük olmalı.`);
          return;
        }

        applyDropoffBtn.disabled = true;
        applyDropoffBtn.textContent = 'Drop-Off Uygulanıyor...';

        try {
          const response = await fetch(`${API_BASE}/dropoff`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              master_sequence: currentMasterSequence,
              target_ply: targetPly,
              ply_counts: currentPlyCounts
            })
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Drop-off başarısız');
          }

          const data = await response.json();

          // Drop-off sonucunu listeye ekle
          const dropoffResult = {
            target: data.target_ply,
            seq: data.sequence,
            score: data.fitness_score,
            dropped: data.dropped_indices
          };
          dropOffResults.push(dropoffResult);

          // Zone sistemine ekle
          await addDropoffToZones(dropoffResult, lastDropoffSourceZoneId);

          // Master sequence'ı güncelle (son drop-off sonucu yeni master olur)
          currentMasterSequence = [...data.sequence];

          // Mevcut ply sayısını güncelle
          if (currentPlyCountEl) {
            currentPlyCountEl.textContent = currentMasterSequence.length;
          }

          // Input'u temizle
          dropoffTargetInput.value = '';

          // Laminate map'i güncelle - orijinal master sequence ile tüm drop-off sonuçlarını göster
          const masterForDisplay = originalMasterSequence || currentMasterSequence;
          renderLaminateMap(masterForDisplay, dropOffResults);

          // Başarı mesajı
          runMetaEl.textContent = `Drop-off uygulandı: ${data.original_ply} → ${data.target_ply} ply (${data.removed_count} katman silindi). Skor: ${data.fitness_score.toFixed(2)}`;

        } catch (err) {
          console.error(err);
          alert('Hata: ' + err.message);
        } finally {
          applyDropoffBtn.disabled = false;
          applyDropoffBtn.textContent = 'Drop-Off Uygula';
        }
      });

      // Enter tuşu ile de drop-off yapılabilir
      if (dropoffTargetInput) {
        dropoffTargetInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            applyDropoffBtn.click();
          }
        });
      }
    }

    // Açıya özel Drop-Off butonu event listener
    const applyDropoffAngleBtn = document.getElementById('apply-dropoff-angle-btn');
    const dropoffSourceZoneSelect = document.getElementById('dropoff-source-zone-select');
    const planSchematicEl = document.getElementById('plan-schematic');
    const dropoffAngle0 = document.getElementById('dropoff-angle-0');
    const dropoffAngle90 = document.getElementById('dropoff-angle-90');
    const dropoffAngle45 = document.getElementById('dropoff-angle-45');
    const dropoffAngleM45 = document.getElementById('dropoff-angle-m45');

    if (applyDropoffAngleBtn) {
      applyDropoffAngleBtn.addEventListener('click', async () => {
        if (!currentMasterSequence || !currentPlyCounts) {
          alert('Lütfen önce bir optimizasyon çalıştırın.');
          return;
        }

        // Kaynak zone seçimi (master veya zone)
        let sourceMode = 'master';
        let sourceZoneIdForZones = lastDropoffSourceZoneId ?? 0;
        let sourceSequence = currentMasterSequence;
        if (dropoffSourceZoneSelect && dropoffSourceZoneSelect.value && dropoffSourceZoneSelect.value !== 'master') {
          const chosenId = parseInt(dropoffSourceZoneSelect.value);
          if (!isNaN(chosenId)) {
            const chosenZone = (currentZones || []).find(z => z.zone_id === chosenId);
            if (chosenZone && Array.isArray(chosenZone.sequence)) {
              sourceMode = 'zone';
              sourceZoneIdForZones = chosenZone.zone_id;
              sourceSequence = chosenZone.sequence;
            }
          }
        }

        // Input değerlerini al
        const target0 = dropoffAngle0.value ? parseInt(dropoffAngle0.value) : null;
        const target90 = dropoffAngle90.value ? parseInt(dropoffAngle90.value) : null;
        const target45 = dropoffAngle45.value ? parseInt(dropoffAngle45.value) : null;
        const targetM45 = dropoffAngleM45.value ? parseInt(dropoffAngleM45.value) : null;

        // En az bir değer girilmiş mi kontrol et
        if (target0 === null && target90 === null && target45 === null && targetM45 === null) {
          alert('Lütfen en az bir açı için hedef sayı girin.');
          return;
        }

        // Target ply counts objesi oluştur (sadece girilen değerler)
        const targetPlyCounts = {};
        if (target0 !== null) targetPlyCounts['0'] = target0;
        if (target90 !== null) targetPlyCounts['90'] = target90;
        if (target45 !== null) targetPlyCounts['45'] = target45;
        if (targetM45 !== null) targetPlyCounts['-45'] = targetM45;

        // Validation: Hedef sayılar mevcut sayılardan fazla olmamalı
        const currentCounts = {};
        sourceSequence.forEach(angle => {
          currentCounts[angle] = (currentCounts[angle] || 0) + 1;
        });

        for (const [angle, targetCount] of Object.entries(targetPlyCounts)) {
          const current = currentCounts[parseInt(angle)] || 0;
          if (targetCount > current) {
            alert(`Hata: ${angle}° için hedef ${targetCount} ama mevcut sadece ${current} katman var.`);
            return;
          }
          if (targetCount < 0) {
            alert(`Hata: ${angle}° için hedef sayı negatif olamaz.`);
            return;
          }
        }

        applyDropoffAngleBtn.disabled = true;
        applyDropoffAngleBtn.textContent = 'Açıya Özel Drop-Off Uygulanıyor...';

        try {
          const response = await fetch(`${API_BASE}/dropoff_angle_targets`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              master_sequence: sourceSequence,
              target_ply_counts: targetPlyCounts
            })
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Açıya özel drop-off başarısız');
          }

          const data = await response.json();

          // Toplam hedef ply sayısını hesapla
          const totalTarget = Object.values(targetPlyCounts).reduce((sum, val) => sum + val, 0);

          // Drop-off sonucunu listeye ekle
          const dropoffResult = {
            target: totalTarget,
            seq: data.sequence,
            score: data.fitness_score,
            dropped: Object.values(data.dropped_by_angle || {}).flat() // Tüm düşürülen indexleri birleştir
          };
          dropOffResults.push(dropoffResult);

          // Zone sistemine ekle
          await addDropoffToZones(dropoffResult, sourceZoneIdForZones);

          // Sadece master modunda ardışık çalışmayı koru
          if (sourceMode === 'master') {
            currentMasterSequence = [...data.sequence];
            if (currentPlyCountEl) {
              currentPlyCountEl.textContent = currentMasterSequence.length;
            }
          }

          // Input'ları temizle
          dropoffAngle0.value = '';
          dropoffAngle90.value = '';
          dropoffAngle45.value = '';
          dropoffAngleM45.value = '';

          // Laminate map'i güncelle
          if (sourceMode === 'master') {
            const masterForDisplay = originalMasterSequence || currentMasterSequence;
            renderLaminateMap(masterForDisplay, dropOffResults);
          } else {
            // Zone kaynaklı drop-off: indeksler farklı olabileceği için sadece bu sonucu göster
            renderLaminateMap(sourceSequence, [dropoffResult]);
          }

          // Detaylı başarı mesajı
          const removedDetails = Object.entries(data.dropped_by_angle || {})
            .map(([angle, indices]) => `${angle}°: ${indices.length / 2} çift`)
            .join(', ');

          runMetaEl.textContent = `Açıya özel drop-off uygulandı: ${data.original_total} → ${data.new_total} ply (${removedDetails}). Skor: ${data.fitness_score.toFixed(2)}`;

        } catch (err) {
          console.error(err);
          alert('Hata: ' + err.message);
        } finally {
          applyDropoffAngleBtn.disabled = false;
          applyDropoffAngleBtn.textContent = 'Açıya Özel Drop-Off Uygula';
        }
      });
    }

    // Keep schematic highlight in sync with dropdown source selection
    if (dropoffSourceZoneSelect) {
      dropoffSourceZoneSelect.addEventListener('change', () => {
        // Render using currentZones/currentTransitions (if available)
        try { renderPlanSchematic(); } catch (_) { }
      });
    }

    // Simetri Uyarı Modalı
    const symmetryModal = document.createElement('div');
    symmetryModal.id = 'symmetry-modal';
    symmetryModal.className = 'fixed inset-0 bg-black/70 z-50 flex items-center justify-center hidden';
    symmetryModal.innerHTML = `
        <div class="bg-white rounded-xl border border-slate-200 p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto shadow-xl">
          <div class="flex items-center gap-3 mb-4">
            <span class="text-3xl">⚠️</span>
            <h3 class="text-xl font-bold text-slate-900">Simetri Uyarısı</h3>
          </div>
          <div id="symmetry-issues" class="space-y-3 mb-4 text-sm text-slate-700"></div>
          <div id="symmetry-suggestions" class="space-y-2 mb-4"></div>
          <div class="flex gap-3 justify-end pt-4 border-t border-slate-200">
            <button id="symmetry-cancel-btn" class="button-with-icon btn-slate">
              İptal
            </button>
          </div>
        </div>
      `;
    document.body.appendChild(symmetryModal);

    function showSymmetryWarning(symmetryInfo, onChoice) {
      const issuesEl = document.getElementById('symmetry-issues');
      const suggestionsEl = document.getElementById('symmetry-suggestions');

      issuesEl.innerHTML = symmetryInfo.issues.map(issue =>
        `<div class="bg-amber-50 p-3 rounded-md border border-amber-200">
            <p class="text-amber-900">${issue.message}</p>
          </div>`
      ).join('');

      suggestionsEl.innerHTML = '';
      if (symmetryInfo.suggestions && symmetryInfo.suggestions.length > 0) {
        suggestionsEl.innerHTML = '<div class="text-sm font-semibold text-slate-800 mb-2">Öneriler:</div>';
        symmetryInfo.suggestions.forEach((suggestion, idx) => {
          const btn = document.createElement('button');
          btn.className = 'w-full text-left px-4 py-3 bg-white hover:bg-slate-50 border border-slate-200 rounded-md transition-colors mb-2 shadow-sm';
          btn.innerHTML = `
              <div class="text-slate-800 font-medium">${suggestion.description}</div>
            `;
          btn.onclick = () => {
            symmetryModal.classList.add('hidden');
            onChoice(suggestion);
          };
          suggestionsEl.appendChild(btn);
        });

        // "Mevcut sayılarla devam et" seçeneği
        const continueBtn = document.createElement('button');
        continueBtn.className = 'w-full text-left px-4 py-3 bg-amber-50 hover:bg-amber-100 border border-amber-300 rounded-md transition-colors mt-2';
        continueBtn.innerHTML = `
            <div class="text-amber-900 font-medium">⚠️ Mevcut sayılarla devam et (küçük simetri penalty'si kabul edilir)</div>
          `;
        continueBtn.onclick = () => {
          symmetryModal.classList.add('hidden');
          onChoice(null); // null = mevcut sayılarla devam
        };
        suggestionsEl.appendChild(continueBtn);
      }

      document.getElementById('symmetry-cancel-btn').onclick = () => {
        symmetryModal.classList.add('hidden');
      };

      symmetryModal.classList.remove('hidden');
    }

    // Zone Management
    const zoneManagementSection = document.getElementById('zone-management-section');
    const zoneDiagram = document.getElementById('zone-diagram');
    const zoneList = document.getElementById('zone-list');
    const initRootZoneBtn = document.getElementById('init-root-zone-btn');
    const mergeZonesSelect = document.getElementById('merge-zones-select');
    const createZoneMergeBtn = document.getElementById('create-zone-merge-btn');

    let currentSessionId = 'default';
    let currentZones = [];
    let currentTransitions = [];
    let lastDropoffSourceZoneId = 0; // Son drop-off'un kaynak zone ID'si
    // Plan şeması için (fotoğraf benzeri) otomatik yerleşim ipuçları
    // slot: 0=üst, 1=orta, 2=alt (kolon içi)
    // col: kolon index (depth) override (örn. ÜSTÜNE/ALTINA aynı kolon)
    // kind: 'global' (kolon üst/orta/alt) | 'above' (kaynağın üstüne) | 'below' (kaynağın altına)
    let planLayoutHints = {}; // zone_id -> { slot: 0|1|2, col?: number, kind?: string, anchor?: number }
    let pendingPlanDrop = null; // { sourceZoneId, targetDepth, slot, kind?: string }
    let planPinnedTooltipZoneId = null; // Katman dizilimi panelini "pin"lemek için (DIZ butonu)

    // Kaynak Zone Seçim Modalı
    const sourceZoneModal = document.createElement('div');
    sourceZoneModal.id = 'source-zone-modal';
    sourceZoneModal.className = 'fixed inset-0 bg-black/70 z-50 flex items-center justify-center hidden';
    sourceZoneModal.innerHTML = `
        <div class="bg-white rounded-xl border border-slate-200 p-6 max-w-md w-full mx-4 shadow-xl">
          <div class="flex items-center gap-3 mb-4">
            <span class="text-2xl">🔗</span>
            <h3 class="text-lg font-bold text-slate-900">Kaynak Zone Seçin</h3>
          </div>
          <p class="text-sm text-slate-700 mb-4">
            Bu drop-off hangi zone'dan dallanacak?
          </p>
          <select id="modal-source-zone-select" class="w-full bg-white border border-slate-300 rounded-md px-3 py-2 text-sm text-slate-900 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <option value="">Seçiniz...</option>
          </select>
          <div class="flex gap-3 justify-end">
            <button id="modal-cancel-btn" class="button-with-icon btn-slate">
              İptal
            </button>
            <button id="modal-confirm-btn" class="button-with-icon btn-blue">
              Onayla
            </button>
          </div>
        </div>
      `;
    document.body.appendChild(sourceZoneModal);

    function showSourceZoneModal(zones) {
      return new Promise((resolve, reject) => {
        const select = document.getElementById('modal-source-zone-select');
        select.innerHTML = '<option value="">Seçiniz...</option>';
        zones.forEach(zone => {
          const option = document.createElement('option');
          option.value = zone.zone_id;
          option.textContent = `${zone.name} (${zone.ply_count} ply)`;
          select.appendChild(option);
        });

        // Varsayılan olarak en son zone'u seç
        if (zones.length > 0) {
          const maxZone = zones.reduce((max, zone) =>
            zone.zone_id > max.zone_id ? zone : max
          );
          select.value = maxZone.zone_id;
        }

        document.getElementById('modal-confirm-btn').onclick = () => {
          const selectedId = parseInt(select.value);
          if (selectedId !== null && !isNaN(selectedId)) {
            sourceZoneModal.classList.add('hidden');
            resolve(selectedId);
          } else {
            alert('Lütfen bir zone seçin.');
          }
        };

        document.getElementById('modal-cancel-btn').onclick = () => {
          sourceZoneModal.classList.add('hidden');
          reject(new Error('İptal edildi'));
        };

        sourceZoneModal.classList.remove('hidden');
      });
    }

    // Eski drop-off sonuçlarını zone sistemine ekle
    async function addDropoffToZones(dropoffData, sourceZoneId = null) {
      try {
        // Eğer zone'lar yoksa, yükle veya root oluştur
        if (currentZones.length === 0) {
          if (originalMasterSequence && originalMasterSequence.length > 0) {
            // Root zone oluştur
            const initResponse = await fetch(`${API_BASE}/zones/init_root`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                session_id: currentSessionId,
                master_sequence: originalMasterSequence,
                ply_counts: currentPlyCounts
              })
            });
            if (initResponse.ok) {
              const initData = await initResponse.json();
              currentZones = initData.all_zones || [];
              currentTransitions = initData.transitions || [];
              zoneManagementSection.classList.remove('hidden');
              lastDropoffSourceZoneId = 0; // Root zone ID
            }
          } else {
            // Zone'ları yükle
            await loadZones();
          }
        }

        // Source zone ID belirlenmediyse, kullanıcıya seçtir
        if (sourceZoneId === null) {
          if (currentZones.length > 0) {
            try {
              sourceZoneId = await showSourceZoneModal(currentZones);
            } catch (error) {
              // Kullanıcı iptal etti, zone ekleme
              return;
            }
          } else {
            // Zone yoksa root'u kullan
            sourceZoneId = 0;
          }
        }

        // Yeni zone'u backend'e ekle
        const response = await fetch(`${API_BASE}/zones/add_from_dropoff`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id: currentSessionId,
            source_zone_id: sourceZoneId,
            sequence: dropoffData.seq,
            ply_count: dropoffData.target,
            fitness_score: dropoffData.score,
            dropped_indices: dropoffData.dropped
          })
        });

        if (response.ok) {
          const data = await response.json();
          currentZones = data.zones || [];
          currentTransitions = data.transitions || [];
          // Yeni oluşturulan zone'un ID'sini kaydet (bir sonraki drop-off için kaynak olacak)
          if (data.zone && data.zone.zone_id !== undefined) {
            lastDropoffSourceZoneId = data.zone.zone_id;
            // Eğer kullanıcı plan şemada bir hedef (üst/orta/alt) seçtiyse, yeni zone'u o slot'a yerleştir
            if (pendingPlanDrop && pendingPlanDrop.sourceZoneId === sourceZoneId) {
              planLayoutHints[lastDropoffSourceZoneId] = {
                slot: pendingPlanDrop.slot,
                col: pendingPlanDrop.targetDepth,
                kind: pendingPlanDrop.kind || 'global',
                anchor: pendingPlanDrop.sourceZoneId
              };
              pendingPlanDrop = null;
            }
          }
          renderZoneList();
          renderZoneDiagram();
          updateZoneSelects();
        }
      } catch (error) {
        console.error('Zone ekleme hatası:', error);
      }
    }

    async function loadZones() {
      try {
        const response = await fetch(`${API_BASE}/zones/list?session_id=${currentSessionId}`);
        const data = await response.json();
        currentZones = data.zones || [];
        currentTransitions = data.transitions || [];
        renderZoneList();
        renderZoneDiagram();
        updateZoneSelects();
      } catch (error) {
        console.error('Zone yükleme hatası:', error);
      }
    }

    function renderZoneList() {
      zoneList.innerHTML = '';
      if (currentZones.length === 0) {
        zoneList.innerHTML = '<div class="text-slate-600 text-sm">Henüz zone oluşturulmadı</div>';
        return;
      }

      currentZones.forEach(zone => {
        const zoneDiv = document.createElement('div');
        zoneDiv.className = 'bg-white/70 backdrop-blur border border-slate-300/60 rounded-md p-3 shadow-sm';
        zoneDiv.innerHTML = `
            <div class="flex items-center justify-between mb-2">
              <span class="font-semibold text-slate-800">${zone.name}</span>
              <span class="text-xs text-slate-500">ID: ${zone.zone_id}</span>
            </div>
            <div class="text-xs text-slate-600 space-y-1">
              <div>Ply Sayısı: <span class="text-slate-800 font-mono">${zone.ply_count}</span></div>
              <div>Fitness: <span class="text-emerald-700 font-mono">${zone.fitness_score.toFixed(2)}</span></div>
              <div>Tip: <span class="text-slate-800">${zone.transition_type === 'drop_off' ? 'Drop-Off' : 'Merge'}</span></div>
              ${zone.source_zones.length > 0 ? `<div>Kaynak: <span class="text-slate-800">Zone ${zone.source_zones.join(', ')}</span></div>` : ''}
            </div>
          `;
        zoneList.appendChild(zoneDiv);
      });
    }

    function renderZoneDiagram() {
      // Gelişmiş şematik görselleştirme
      if (currentZones.length === 0) {
        zoneDiagram.innerHTML = '<div class="text-slate-500 text-center py-20">Zone diyagramı burada görüntülenecek</div>';
        return;
      }

      // Zone pozisyonlarını hesapla (hierarchical layout)
      const zonePositions = {};
      const zoneLevels = {}; // Her zone'un seviyesi (root = 0)
      const levelZones = {}; // Her seviyedeki zone'lar

      // Root zone'u bul ve seviye 0'a koy
      const rootZone = currentZones.find(z => z.zone_id === 0);
      if (rootZone) {
        zoneLevels[0] = 0;
        levelZones[0] = levelZones[0] || [];
        levelZones[0].push(rootZone);
      }

      // Diğer zone'ları seviyelere göre yerleştir
      const processed = new Set([0]);
      let currentLevel = 1;

      while (processed.size < currentZones.length) {
        levelZones[currentLevel] = levelZones[currentLevel] || [];

        currentZones.forEach(zone => {
          if (processed.has(zone.zone_id)) return;

          // Bu zone'un kaynak zone'ları işlenmiş mi?
          const allSourcesProcessed = zone.source_zones.every(sid => processed.has(sid));
          if (allSourcesProcessed && zone.source_zones.length > 0) {
            zoneLevels[zone.zone_id] = currentLevel;
            levelZones[currentLevel].push(zone);
            processed.add(zone.zone_id);
          }
        });

        if (levelZones[currentLevel].length === 0) break;
        currentLevel++;
      }

      // İşlenmemiş zone'ları son seviyeye ekle
      currentZones.forEach(zone => {
        if (!processed.has(zone.zone_id)) {
          const maxLevel = Math.max(...Object.keys(levelZones).map(Number));
          levelZones[maxLevel + 1] = levelZones[maxLevel + 1] || [];
          levelZones[maxLevel + 1].push(zone);
          zoneLevels[zone.zone_id] = maxLevel + 1;
        }
      });

      // Pozisyonları hesapla
      Object.keys(levelZones).forEach(level => {
        const zonesInLevel = levelZones[level];
        const levelNum = parseInt(level);
        const y = levelNum * 120 + 30;
        const totalWidth = zonesInLevel.length * 180;
        const startX = (800 - totalWidth) / 2; // Ortala

        zonesInLevel.forEach((zone, idx) => {
          const x = startX + idx * 180;
          zonePositions[zone.zone_id] = { x, y };
        });
      });

      // SVG container
      let html = '<div class="relative" style="min-height: 400px; overflow-x: auto;">';
      html += '<svg class="absolute" style="width: 100%; height: 100%; min-width: 800px; min-height: 400px;">';

      // Arrow marker tanımla
      html += `
          <defs>
            <marker id="arrowhead-blue" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
              <polygon points="0 0, 10 3, 0 6" fill="#1d4ed8" />
            </marker>
            <marker id="arrowhead-purple" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
              <polygon points="0 0, 10 3, 0 6" fill="#6d28d9" />
            </marker>
            <marker id="arrowhead-orange" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
              <polygon points="0 0, 10 3, 0 6" fill="#b45309" />
            </marker>
          </defs>
        `;

      // Geçişleri çiz - Fotoğraftaki gibi temiz ve organize
      // Her hedef zone için gelen çizgileri grupla ve ayrı tut
      const targetConnections = {}; // target_id -> array of {fromId, fromX, fromY, trans}

      currentTransitions.forEach((trans) => {
        const fromIds = Array.isArray(trans.from) ? trans.from : [trans.from];
        const toZone = currentZones.find(z => z.zone_id === trans.to);

        if (!toZone || !zonePositions[trans.to]) return;

        fromIds.forEach((fromId) => {
          const fromZone = currentZones.find(z => z.zone_id === fromId);
          if (!fromZone || !zonePositions[fromId]) return;

          if (!targetConnections[trans.to]) {
            targetConnections[trans.to] = [];
          }

          targetConnections[trans.to].push({
            fromId,
            fromX: zonePositions[fromId].x + 75,
            fromY: zonePositions[fromId].y + 60,
            trans
          });
        });
      });

      // Her hedef zone için çizgileri düzenli çiz
      Object.keys(targetConnections).forEach((targetId, targetIdx) => {
        const connections = targetConnections[targetId];
        const toZone = currentZones.find(z => z.zone_id === parseInt(targetId));
        if (!toZone || !zonePositions[toZone.zone_id]) return;

        const toX = zonePositions[toZone.zone_id].x + 75;
        const toY = zonePositions[toZone.zone_id].y;
        const totalConnections = connections.length;

        connections.forEach((conn, connIdx) => {
          const fromX = conn.fromX;
          const fromY = conn.fromY;
          const trans = conn.trans;

          const strokeColor = trans.type === 'merge' ? '#6d28d9' :
            trans.type === 'angle_drop_off' ? '#b45309' : '#1d4ed8';
          const markerId = trans.type === 'merge' ? 'arrowhead-purple' :
            trans.type === 'angle_drop_off' ? 'arrowhead-orange' : 'arrowhead-blue';

          // Fotoğraftaki gibi: Her çizgiyi hedefe yaklaştırırken offset ver
          // Hedef zone'un sol tarafına farklı yüksekliklerde yaklaş
          const offsetY = totalConnections > 1
            ? ((connIdx - (totalConnections - 1) / 2) * 15) // Her çizgi 15px aralıkla
            : 0;

          // Basit L-şekilli path: Yatay → Dikey (fotoğraftaki gibi düz çizgiler)
          // Zone'dan çıkış → Ara nokta (hedefin yanında) → Hedefe giriş
          const midX = toX - 30; // Hedefin 30px soluna
          const approachY = toY + offsetY; // Hedefe yaklaşım yüksekliği

          const pathId = `path-${targetId}-${connIdx}`;

          // Düz çizgilerle L-şekilli path
          html += `
              <path id="${pathId}"
                    d="M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${approachY} L ${toX} ${approachY}" 
                    stroke="${strokeColor}" 
                    stroke-width="2.5" 
                    fill="none"
                    marker-end="url(#${markerId})"
                    class="transition-path"
                    style="animation-delay: ${targetIdx * 0.1 + connIdx * 0.05}s;"/>
            `;
        });
      });

      // Zone'ları çiz (animasyonlu)
      currentZones.forEach((zone, zoneIdx) => {
        const pos = zonePositions[zone.zone_id];
        if (!pos) return;

        const borderColor = zone.zone_id === 0 ? '#1d4ed8' :
          zone.transition_type === 'merge' ? '#6d28d9' :
            zone.transition_type === 'angle_drop_off' ? '#b45309' : '#1d4ed8';

        // Gradient tanımla (daha güzel görünüm için)
        const gradientId = `gradient-${zone.zone_id}`;
        html += `
            <defs>
              <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:${borderColor};stop-opacity:0.16" />
                <stop offset="100%" style="stop-color:${borderColor};stop-opacity:0.03" />
              </linearGradient>
              <filter id="glow-${zone.zone_id}">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
          `;

        html += `
            <g class="zone-group zone-hover-group" data-zone-id="${zone.zone_id}"
               style="animation: fadeInScale 0.5s ease-out ${zoneIdx * 0.1}s both;">
              <rect x="${pos.x}" y="${pos.y}" width="150" height="60" rx="8" 
                    fill="url(#${gradientId})" 
                    stroke="${borderColor}" 
                    stroke-width="2.5" 
                    class="zone-box"
                    style="transition: all 0.3s ease; cursor: pointer;"
                    filter="url(#glow-${zone.zone_id})"/>
              <text x="${pos.x + 75}" y="${pos.y + 20}" 
                    text-anchor="middle" fill="#0f172a" font-weight="700" font-size="14"
                    style="pointer-events: none; user-select: none;">
                ${zone.name}
              </text>
              <text x="${pos.x + 75}" y="${pos.y + 38}" 
                    text-anchor="middle" fill="#475569" font-size="11"
                    style="pointer-events: none; user-select: none;">
                ${zone.ply_count} ply
              </text>
              <text x="${pos.x + 75}" y="${pos.y + 55}" 
                    text-anchor="middle" fill="#047857" font-size="11" font-weight="700"
                    style="pointer-events: none; user-select: none;">
                ${zone.fitness_score.toFixed(1)}
              </text>
            </g>
          `;
      });

      html += '</svg></div>';
      zoneDiagram.innerHTML = html;
    }

    // Plan-view schematic (mentor sketch style): show ply totals and derivation
    function renderPlanSchematic() {
      if (!planSchematicEl) return;

      const zones = (currentZones || []).slice();
      if (!zones.length) {
        planSchematicEl.innerHTML = '<div class="h-full flex items-center justify-center text-xs text-slate-500">Şematik için önce root zone oluşturun.</div>';
        return;
      }

      const zoneById = new Map(zones.map(z => [z.zone_id, z]));
      const allIds = new Set(zones.map(z => z.zone_id));

      // Selected source: dropdown drives highlight (master -> Root if present)
      let selectedId = null;
      if (dropoffSourceZoneSelect && dropoffSourceZoneSelect.value) {
        if (dropoffSourceZoneSelect.value === 'master') {
          selectedId = allIds.has(0) ? 0 : null;
        } else {
          const parsed = parseInt(dropoffSourceZoneSelect.value);
          selectedId = Number.isFinite(parsed) ? parsed : null;
        }
      } else {
        selectedId = allIds.has(0) ? 0 : null;
      }

      // Build adjacency from transitions
      const children = new Map(); // from -> Set(to)
      (currentTransitions || []).forEach(tr => {
        const to = tr.to;
        if (!allIds.has(to)) return;
        const froms = Array.isArray(tr.from) ? tr.from : [tr.from];
        froms.forEach(f => {
          if (!allIds.has(f)) return;
          if (!children.has(f)) children.set(f, new Set());
          children.get(f).add(to);
        });
      });

      // BFS depths from Root (0) if exists, else first zone
      const rootId = allIds.has(0) ? 0 : zones[0].zone_id;
      const depth = new Map();
      depth.set(rootId, 0);
      const q = [rootId];
      while (q.length) {
        const id = q.shift();
        const kids = children.get(id) ? Array.from(children.get(id)) : [];
        kids.forEach(k => {
          if (!depth.has(k)) {
            depth.set(k, (depth.get(id) || 0) + 1);
            q.push(k);
          }
        });
      }
      // Place any disconnected zones on depth 1+
      zones.forEach(z => {
        if (!depth.has(z.zone_id)) depth.set(z.zone_id, 1);
      });

      // Explicit column override (e.g. ÜSTÜNE/ALTINA -> same column as source)
      zones.forEach(z => {
        const hintedCol = planLayoutHints[z.zone_id]?.col;
        if (Number.isFinite(hintedCol)) depth.set(z.zone_id, Math.max(0, hintedCol));
      });

      const maxDepth = Math.max(...Array.from(depth.values()));
      const levelsRaw = new Map(); // d -> zoneIds[]
      zones.forEach(z => {
        const d = depth.get(z.zone_id) || 0;
        if (!levelsRaw.has(d)) levelsRaw.set(d, []);
        levelsRaw.get(d).push(z.zone_id);
      });

      // Depth-by-depth ordering so we can keep "above/below source" intuition.
      const levels = new Map(); // d -> sorted zoneIds[]
      const indexInLevel = new Map(); // zone_id -> index in its depth

      const getKindOffset = (kind) => {
        if (kind === 'above') return -1;
        if (kind === 'below') return 1;
        return 0; // 'global' or undefined
      };

      const getSlot = (id) => (planLayoutHints[id]?.slot ?? 1);
      const getKind = (id) => (planLayoutHints[id]?.kind ?? 'global');
      const getAnchor = (id) => (planLayoutHints[id]?.anchor ?? null);

      // Depth 0
      const level0 = (levelsRaw.get(0) || []).slice();
      level0.sort((a, b) => {
        const za = zoneById.get(a);
        const zb = zoneById.get(b);
        const pa = (za?.ply_count ?? 0);
        const pb = (zb?.ply_count ?? 0);
        if (pb !== pa) return pb - pa;
        return a - b;
      });
      levels.set(0, level0);
      level0.forEach((id, idx) => indexInLevel.set(id, idx));

      // Depth 1..maxDepth
      for (let d = 1; d <= maxDepth; d++) {
        const ids = (levelsRaw.get(d) || []).slice();
        ids.sort((a, b) => {
          const za = zoneById.get(a);
          const zb = zoneById.get(b);
          const pa = (za?.ply_count ?? 0);
          const pb = (zb?.ply_count ?? 0);

          // Prefer positioning relative to anchor (source zone)
          const aa = getAnchor(a);
          const ab = getAnchor(b);
          const ia = aa !== null && indexInLevel.has(aa) ? indexInLevel.get(aa) : 0;
          const ib = ab !== null && indexInLevel.has(ab) ? indexInLevel.get(ab) : 0;

          const da = ia * 10 + getKindOffset(getKind(a));
          const db = ib * 10 + getKindOffset(getKind(b));
          if (da !== db) return da - db;

          // Secondary: slot (global Üst/Orta/Alt)
          const sa = getSlot(a);
          const sb = getSlot(b);
          if (sa !== sb) return sa - sb;

          // Then: ply desc, id asc
          if (pb !== pa) return pb - pa;
          return a - b;
        });

        levels.set(d, ids);
        ids.forEach((id, idx) => indexInLevel.set(id, idx));
      }

      // Make zones "contiguous" like the mentor sketch:
      // - Each depth is a column slice inside the part
      // - Each depth has 3 fixed vertical slots (üst/orta/alt)
      //   so even a single child can sit above/below instead of stretching full height.
      const W = 1000;
      const H = 240;
      const pad = 16;
      const outerPad = 10;
      const innerX = outerPad + pad;
      const innerY = outerPad + pad;
      const innerW = W - (outerPad + pad) * 2;
      const innerH = H - (outerPad + pad) * 2;
      // Her zaman bir "boş kolon" daha göster ki kullanıcı drop hedefini seçebilsin
      const cols = Math.max(2, maxDepth + 2);
      const colW = innerW / cols;

      const cell = new Map(); // id -> {x,y,w,h,cx,cy,lx,rx}
      const slotH = innerH / 3;
      levels.forEach((ids, d) => {
        const x = innerX + d * colW;
        const w = colW;
        const bySlot = { 0: [], 1: [], 2: [] };
        ids.forEach((id) => {
          const s = (planLayoutHints[id]?.slot ?? 1);
          const slot = (s === 0 || s === 2) ? s : 1;
          bySlot[slot].push(id);
        });
        [0, 1, 2].forEach((slot) => {
          const arr = bySlot[slot];
          if (!arr || arr.length === 0) return;
          const perH = slotH / arr.length;
          arr.forEach((id, idx) => {
            const y = innerY + slot * slotH + idx * perH;
            const h = perH;
            cell.set(id, {
              x, y, w, h,
              cx: x + w / 2,
              cy: y + h / 2,
              lx: x,
              rx: x + w
            });
          });
        });
      });

      // SVG scaffolding: outer "part" rectangle like the sketch
      let svg = `
          <svg viewBox="0 0 ${W} ${H}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <marker id="ps-arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                <polygon points="0 0, 10 3, 0 6" fill="#0f172a" opacity="0.55" />
              </marker>
            </defs>
            <rect x="${outerPad}" y="${outerPad}" width="${W - outerPad * 2}" height="${H - outerPad * 2}" rx="10"
                  fill="rgba(255,255,255,0.15)" stroke="rgba(15,23,42,0.20)" stroke-width="2"/>
        `;

      // Draw column separators (subtle)
      for (let c = 1; c < cols; c++) {
        const x = innerX + c * colW;
        svg += `<line x1="${x}" y1="${innerY}" x2="${x}" y2="${innerY + innerH}" stroke="rgba(15,23,42,0.10)" stroke-width="1"/>`;
      }

      // Draw transitions as internal arrows (center-to-center)
      (currentTransitions || []).forEach(tr => {
        const to = tr.to;
        if (!allIds.has(to)) return;
        const toZ = zoneById.get(to);
        const toC = cell.get(to);
        if (!toC) return;
        const froms = Array.isArray(tr.from) ? tr.from : [tr.from];
        froms.forEach((f, fi) => {
          if (!allIds.has(f)) return;
          const fromZ = zoneById.get(f);
          const fromC = cell.get(f);
          if (!fromC || !fromZ) return;

          // Center-to-center (requested)
          const x1 = fromC.cx;
          const y1 = fromC.cy;
          const x2 = toC.cx;
          const y2 = toC.cy;

          // slight offset to reduce overlap when multiple edges converge
          const off = (fi - (froms.length - 1) / 2) * 6;
          const sy1 = y1 + off;
          const sy2 = y2 + off;

          const label = `${fromZ.ply_count}→${toZ?.ply_count ?? ''}`;
          const mx = (x1 + x2) / 2;
          const my = (sy1 + sy2) / 2;

          // Mild curve for readability (still center-to-center)
          const cx = mx;
          const cy = my - 18; // lift label/curve slightly

          svg += `
              <path d="M ${x1} ${sy1} Q ${cx} ${cy} ${x2} ${sy2}"
                    stroke="rgba(15,23,42,0.45)" stroke-width="2"
                    fill="none"
                    marker-end="url(#ps-arrow)"/>
              <g opacity="0.9">
                <rect x="${mx - 18}" y="${my - 10}" width="36" height="16" rx="6"
                      fill="rgba(255,255,255,0.75)" stroke="rgba(15,23,42,0.15)"/>
                <text x="${mx}" y="${my + 2}" text-anchor="middle"
                      font-family="JetBrains Mono, ui-monospace" font-size="10"
                      fill="#0f172a" opacity="0.75">${label}</text>
              </g>
            `;
        });
      });

      // Draw contiguous zone cells (touching, like regions)
      zones.forEach(z => {
        const c = cell.get(z.zone_id);
        if (!c) return;
        const isSelected = selectedId !== null && z.zone_id === selectedId;
        const stroke = isSelected ? '#e11d48' : 'rgba(15,23,42,0.35)';
        const strokeW = isSelected ? 3 : 2;
        const seqBtnFill = isSelected ? 'rgba(225,29,72,0.10)' : 'rgba(15,23,42,0.06)';
        const seqBtnStroke = isSelected ? 'rgba(225,29,72,0.45)' : 'rgba(15,23,42,0.16)';

        svg += `
            <g data-zone-id="${z.zone_id}" style="cursor:pointer">
              <rect x="${c.x}" y="${c.y}" width="${c.w}" height="${c.h}"
                    rx="8"
                    fill="rgba(255,255,255,0.72)"
                    stroke="${stroke}" stroke-width="${strokeW}"/>

              <text x="${c.x + 12}" y="${c.y + 18}"
                    font-family="Inter, system-ui, sans-serif" font-size="12"
                    fill="#0f172a" opacity="0.85">${z.name}</text>
              <text x="${c.x + 12}" y="${c.y + 42}"
                    font-family="JetBrains Mono, ui-monospace" font-size="20"
                    fill="#0f172a" font-weight="700">${z.ply_count}</text>

              <!-- Small in-box button to show stacking sequence (no hover needed) -->
              <g data-seq-btn="1" data-zid="${z.zone_id}" style="cursor:pointer">
                <rect x="${c.x + 10}" y="${c.y + 6}" width="40" height="18" rx="9"
                      fill="${seqBtnFill}" stroke="${seqBtnStroke}" stroke-width="1"/>
                <text x="${c.x + 30}" y="${c.y + 19}" text-anchor="middle"
                      font-family="JetBrains Mono, ui-monospace" font-size="10"
                      fill="rgba(15,23,42,0.75)" style="pointer-events:none; user-select:none;">DIZ</text>
              </g>
            </g>
          `;
      });

      // Drop hedefi seçimi (EN ÜSTTE çizilsin ki tıklanabilir olsun):
      // - Hedef kolonda (bir sonraki kolon) 3 slot (üst/orta/alt)
      // - ÜSTÜNE/ALTINA: SAĞA değil, aynı kolonda üst/alt yerleşim
      if (selectedId !== null && depth.has(selectedId)) {
        const sd = depth.get(selectedId) || 0;
        const targetDepth = sd + 1;
        const srcCell = cell.get(selectedId);
        if (srcCell && targetDepth < cols) {
          const tx = innerX + targetDepth * colW;

          // Hedef kolonunda 3 slot’u (arka plan) göster (etiketsiz, tıklanabilir)
          [0, 1, 2].forEach((slot) => {
            const y = innerY + slot * slotH;
            const isActive =
              pendingPlanDrop &&
              pendingPlanDrop.sourceZoneId === selectedId &&
              pendingPlanDrop.targetDepth === targetDepth &&
              pendingPlanDrop.slot === slot &&
              (pendingPlanDrop.kind || 'global') === 'global';
            svg += `
                <g data-drop-target="1" data-kind="global" data-target-depth="${targetDepth}" data-slot="${slot}" style="cursor:pointer">
                  <rect x="${tx}" y="${y}" width="${colW}" height="${slotH}"
                        fill="${isActive ? 'rgba(225,29,72,0.08)' : 'rgba(15,23,42,0.015)'}"
                        stroke="${isActive ? 'rgba(225,29,72,0.45)' : 'rgba(15,23,42,0.06)'}"
                        stroke-width="${isActive ? 2 : 1}"
                        stroke-dasharray="4 4"/>
                </g>
              `;
          });

          // Seçili kutunun üstüne/altına hızlı hedef butonları
          // NOT: targetDepth = sd (aynı kolon) olarak kaydedilir.
          const btnW = Math.min(92, colW - 18);
          const btnH = 18;
          const bx = Math.min(srcCell.x + srcCell.w - btnW - 10, W - outerPad - btnW - 10);
          const drawBtn = (kind, by, slot, text) => {
            const isActive =
              pendingPlanDrop &&
              pendingPlanDrop.sourceZoneId === selectedId &&
              pendingPlanDrop.targetDepth === sd &&
              pendingPlanDrop.slot === slot &&
              (pendingPlanDrop.kind || 'global') === kind;
            svg += `
                <g data-drop-target="1" data-kind="${kind}" data-target-depth="${sd}" data-slot="${slot}" style="cursor:pointer">
                  <rect x="${bx}" y="${by}" width="${btnW}" height="${btnH}" rx="8"
                        fill="${isActive ? 'rgba(225,29,72,0.16)' : 'rgba(255,255,255,0.70)'}"
                        stroke="${isActive ? 'rgba(225,29,72,0.70)' : 'rgba(15,23,42,0.18)'}"
                        stroke-width="${isActive ? 2 : 1}"/>
                  <text x="${bx + 10}" y="${by + 12}"
                        font-family="Inter, system-ui, sans-serif" font-size="11"
                        fill="rgba(15,23,42,0.75)">${text}</text>
                </g>
              `;
          };
          // Üstüne / Altına: yeni zone aynı kolonda (sd) ama üst slot veya alt slot'a gider
          const topBy = Math.max(innerY + 6, Math.min(srcCell.y + 6, innerY + innerH - btnH - 6));
          const botBy = Math.max(innerY + 6, Math.min(srcCell.y + srcCell.h - btnH - 6, innerY + innerH - btnH - 6));
          drawBtn('above', topBy, 0, 'ÜSTÜNE');
          drawBtn('below', botBy, 2, 'ALTINA');
        }
      }

      svg += '</svg>';
      planSchematicEl.innerHTML = svg;

      // Hover tooltip for zone sequence (accordion-like)
      let tooltip = planSchematicEl.querySelector('#plan-schematic-tooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'plan-schematic-tooltip';
        tooltip.className = 'hidden absolute z-20 w-[860px] max-w-[96vw]';
        tooltip.style.pointerEvents = 'none';
        planSchematicEl.appendChild(tooltip);
      }

      const angleClass = (a) => {
        if (a === 0) return 'bg-emerald-500';
        if (a === 90) return 'bg-sky-500';
        if (a === 45) return 'bg-rose-500';
        if (a === -45) return 'bg-amber-500';
        return 'bg-slate-500';
      };

      const buildSeqPreview = (seq) => {
        // Tooltip yatay kaydırmalı olduğu için mümkün olduğunca tam göster.
        // Sadece aşırı uzun dizilimlerde (örn. yüzlerce) kısalt.
        const maxShow = 500;
        const safe = Array.isArray(seq) ? seq : [];
        if (safe.length <= maxShow) return safe;
        const head = safe.slice(0, 80);
        const tail = safe.slice(-60);
        return [...head, '…', ...tail];
      };

      const showTooltip = (zoneId) => {
        const z = zoneById.get(zoneId);
        if (!z || !Array.isArray(z.sequence)) return;

        // counts
        const counts = { 0: 0, 90: 0, 45: 0, '-45': 0 };
        z.sequence.forEach(a => {
          if (a === 0) counts[0] += 1;
          else if (a === 90) counts[90] += 1;
          else if (a === 45) counts[45] += 1;
          else if (a === -45) counts['-45'] += 1;
        });

        const nTotal = z.sequence.length;
        const isOdd = nTotal % 2 === 1;
        const mid = Math.floor(nTotal / 2);
        const axisText = isOdd ? `eks:${mid}` : `eks:${mid - 1}|${mid}`;

        const preview = buildSeqPreview(z.sequence);
        // If preview is shortened, axis marker may not be visually present; show axisText anyway.
        let chips = '';
        const addAxisMarkerBetween = () =>
          `<span class="inline-flex items-center justify-center w-[4px] h-7 bg-amber-500/90 rounded-sm shadow-[0_0_6px_rgba(245,158,11,0.35)] mx-1" title="Simetri ekseni"></span>`;

        for (let i = 0; i < preview.length; i++) {
          const a = preview[i];
          if (a === '…') {
            chips += `<span class="px-2 py-1 rounded-md bg-slate-200 text-slate-700 text-[10px] font-mono">…</span>`;
            continue;
          }
          const ang = Number(a);
          const cls = angleClass(ang);

          // Even: axis is between two middle plies -> add marker when we reach mid index
          // Only works when we are rendering full sequence (no ellipsis). For shortened preview, marker might be absent.
          if (!isOdd && preview.length === nTotal && i === mid) {
            chips += addAxisMarkerBetween();
          }

          // Odd: axis is on the middle ply -> overlay marker on that chip (only if not shortened)
          const isAxisOnThis = isOdd && preview.length === nTotal && i === mid;
          chips += `
              <span class="relative inline-flex items-center justify-center w-7 h-7 rounded-sm ${cls} text-[9px] font-mono font-semibold text-white shadow-sm">
                ${ang}°
                ${isAxisOnThis ? `<span class="absolute left-1/2 top-[-3px] w-[3px] h-[32px] bg-amber-500/90 rounded-sm shadow-[0_0_6px_rgba(245,158,11,0.35)]" style="transform: translateX(-50%);"></span>` : ``}
              </span>
            `;
        }

        tooltip.innerHTML = `
            <div class="bg-white/90 backdrop-blur border border-slate-300/70 rounded-xl shadow-xl overflow-hidden">
              <div class="px-3 py-2 border-b border-slate-200 flex items-center justify-between">
                <div class="text-sm font-semibold text-slate-900">${z.name} — <span class="font-mono">${z.ply_count}</span> ply</div>
                <div class="text-[11px] text-slate-600 font-mono">0:${counts[0]}  90:${counts[90]}  45:${counts[45]}  -45:${counts['-45']}  •  ${axisText}</div>
              </div>
              <div class="px-3 py-2">
                <div class="text-[11px] text-slate-600 mb-2">Dizilim (hover ile açılır/kapanır):</div>
                <div class="flex flex-nowrap gap-1 overflow-x-auto overflow-y-hidden pb-1 whitespace-nowrap">
                  ${chips}
                </div>
              </div>
            </div>
          `;

        tooltip.classList.remove('hidden');

        // position relative to zone rect, prefer above
        const g = planSchematicEl.querySelector(`[data-zone-id="${zoneId}"]`);
        const rect = planSchematicEl.getBoundingClientRect();
        const svgEl = planSchematicEl.querySelector('svg');
        if (!g || !svgEl) return;

        // read cell bbox from rect element inside g
        const r = g.querySelector('rect');
        if (!r) return;
        const x = Number(r.getAttribute('x')) || 0;
        const y = Number(r.getAttribute('y')) || 0;
        const w = Number(r.getAttribute('width')) || 0;
        const h = Number(r.getAttribute('height')) || 0;

        const viewBox = svgEl.viewBox.baseVal;
        const sx = rect.width / (viewBox.width || 1000);
        const sy = rect.height / (viewBox.height || 240);
        const px = x * sx;
        const py = y * sy;
        const pw = w * sx;
        const ph = h * sy;

        // compute tooltip size after render
        const ttW = tooltip.offsetWidth || 860;
        const ttH = tooltip.offsetHeight || 160;
        // Prefer side placement so we don't visually cover ÜSTÜNE/ALTINA buttons
        let left = px - ttW - 12; // left side
        let top = py + ph / 2 - ttH / 2; // vertically centered
        const fitsLeft = left >= 8;
        const fitsTop = top >= 8 && (top + ttH) <= (rect.height - 8);
        if (!(fitsLeft && fitsTop)) {
          // try right side
          const rightLeft = px + pw + 12;
          const fitsRight = (rightLeft + ttW) <= (rect.width - 8);
          if (fitsRight && fitsTop) {
            left = rightLeft;
          } else {
            // fallback: above/below centered
            left = px + pw / 2 - ttW / 2;
            left = Math.max(8, Math.min(left, rect.width - ttW - 8));
            top = py - ttH - 10; // above
            if (top < 8) top = py + ph + 10; // below fallback
            top = Math.max(8, Math.min(top, rect.height - ttH - 8));
          }
        }

        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
      };

      const forceHideTooltip = () => {
        tooltip.classList.add('hidden');
      };

      const hideTooltip = () => {
        // If user pinned it via DIZ button, don't auto-hide
        if (planPinnedTooltipZoneId !== null) return;
        forceHideTooltip();
      };

      // Click-to-select source zone
      planSchematicEl.querySelectorAll('[data-zone-id]').forEach(el => {
        el.addEventListener('click', () => {
          const zid = el.getAttribute('data-zone-id');
          if (!dropoffSourceZoneSelect) return;
          planPinnedTooltipZoneId = null;
          forceHideTooltip();
          dropoffSourceZoneSelect.value = String(zid);
          pendingPlanDrop = null; // kaynak değişince hedef seçimi sıfırla
          dropoffSourceZoneSelect.dispatchEvent(new Event('change'));
        });

        // Hover: show sequence
        el.addEventListener('mouseenter', () => {
          const zid = parseInt(el.getAttribute('data-zone-id'));
          if (!Number.isFinite(zid)) return;
          // Seçili zone üzerinde tooltip açma: hedef butonlarını kapatabiliyor.
          if (selectedId !== null && zid === selectedId) return;
          showTooltip(zid);
        });
        el.addEventListener('mouseleave', hideTooltip);
      });

      // Click-to-toggle sequence panel (DIZ)
      planSchematicEl.querySelectorAll('[data-seq-btn="1"]').forEach(el => {
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          const zid = parseInt(el.getAttribute('data-zid'));
          if (!Number.isFinite(zid)) return;
          if (planPinnedTooltipZoneId === zid) {
            planPinnedTooltipZoneId = null;
            forceHideTooltip();
            return;
          }
          planPinnedTooltipZoneId = zid;
          showTooltip(zid);
        });
      });

      // Click-to-select drop target slot (üst/orta/alt)
      planSchematicEl.querySelectorAll('[data-drop-target="1"]').forEach(el => {
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          if (selectedId === null) return;
          const td = parseInt(el.getAttribute('data-target-depth'));
          const slot = parseInt(el.getAttribute('data-slot'));
          const kind = el.getAttribute('data-kind') || 'global';
          if (!Number.isFinite(td) || !Number.isFinite(slot)) return;
          pendingPlanDrop = { sourceZoneId: selectedId, targetDepth: td, slot, kind };
          renderPlanSchematic();
        });
      });

      // Hide tooltip when leaving the whole panel
      planSchematicEl.addEventListener('mouseleave', hideTooltip);

      // If user pinned a tooltip, restore it after rerender
      if (planPinnedTooltipZoneId !== null && zoneById.has(planPinnedTooltipZoneId)) {
        showTooltip(planPinnedTooltipZoneId);
      }
    }

    function updateZoneSelects() {
      // Drop-off kaynak zone select (ana drop-off paneli)
      if (dropoffSourceZoneSelect) {
        dropoffSourceZoneSelect.innerHTML = '<option value="master">Mevcut Master (Optimizasyon Sonucu)</option>';
        (currentZones || []).forEach(zone => {
          const option = document.createElement('option');
          option.value = zone.zone_id.toString();
          option.textContent = `${zone.name} (${zone.ply_count} ply)`;
          dropoffSourceZoneSelect.appendChild(option);
        });

        // Varsayılan: son drop-off kaynağı varsa onu seç, yoksa Root varsa Root
        const hasLast = lastDropoffSourceZoneId !== null && (currentZones || []).some(z => z.zone_id === lastDropoffSourceZoneId);
        if (hasLast) {
          dropoffSourceZoneSelect.value = String(lastDropoffSourceZoneId);
        } else if ((currentZones || []).some(z => z.zone_id === 0)) {
          dropoffSourceZoneSelect.value = '0';
        } else {
          dropoffSourceZoneSelect.value = 'master';
        }
      }

      // Merge zones select
      mergeZonesSelect.innerHTML = '';
      currentZones.forEach(zone => {
        const option = document.createElement('option');
        option.value = zone.zone_id.toString(); // String olarak set et
        option.textContent = `${zone.name} (${zone.ply_count} ply)`;
        mergeZonesSelect.appendChild(option);
      });

      // Refresh plan schematic (source selection + photo-like view)
      renderPlanSchematic();
    }

    // Initialize root zone
    initRootZoneBtn.addEventListener('click', async () => {
      if (!currentMasterSequence) {
        alert('Lütfen önce bir optimizasyon çalıştırın.');
        return;
      }

      try {
        initRootZoneBtn.disabled = true;
        initRootZoneBtn.textContent = 'Başlatılıyor...';

        const response = await fetch(`${API_BASE}/zones/init_root`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id: currentSessionId,
            master_sequence: currentMasterSequence,
            ply_counts: currentPlyCounts
          })
        });

        if (!response.ok) throw new Error('Root zone başlatılamadı');

        const data = await response.json();
        currentZones = data.all_zones || [];
        currentTransitions = data.transitions || [];

        zoneManagementSection.classList.remove('hidden');
        renderZoneList();
        renderZoneDiagram();
        updateZoneSelects();

        initRootZoneBtn.textContent = 'Root Zone Başlatıldı ✓';
      } catch (error) {
        alert('Hata: ' + error.message);
        initRootZoneBtn.disabled = false;
        initRootZoneBtn.textContent = 'Root Zone\'u Başlat';
      }
    });

    // Create zone from merge
    createZoneMergeBtn.addEventListener('click', async () => {
      const selectedZones = Array.from(mergeZonesSelect.selectedOptions).map(opt => parseInt(opt.value));

      if (selectedZones.length < 2) {
        alert('Lütfen en az 2 zone seçin.');
        return;
      }

      try {
        createZoneMergeBtn.disabled = true;
        createZoneMergeBtn.textContent = 'Birleştiriliyor...';

        const response = await fetch(`${API_BASE}/zones/create_from_merge`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id: currentSessionId,
            source_zone_ids: selectedZones
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Zone birleştirilemedi');
        }

        const data = await response.json();

        // Zone'ları güncelle
        if (data.zones && Array.isArray(data.zones)) {
          currentZones = data.zones;
        }
        if (data.transitions && Array.isArray(data.transitions)) {
          currentTransitions = data.transitions;
        }

        // Şemayı güncelle
        renderZoneList();
        renderZoneDiagram();
        updateZoneSelects();

        // Başarı mesajı
        const newZone = data.zone;
        if (newZone) {
          const sourceNames = selectedZones.map(zid => zid === 0 ? 'Root' : `Zone ${zid}`).join(' + ');
          runMetaEl.textContent = `Merge Zone ${newZone.zone_id} oluşturuldu: ${sourceNames} → Zone ${newZone.zone_id} (${newZone.ply_count} ply, ${newZone.fitness_score.toFixed(2)} skor)`;
        }

        mergeZonesSelect.selectedIndex = -1;
        createZoneMergeBtn.disabled = false;
        createZoneMergeBtn.textContent = 'Birleştirme ile Zone Oluştur';
      } catch (error) {
        alert('Hata: ' + error.message);
        createZoneMergeBtn.disabled = false;
        createZoneMergeBtn.textContent = 'Birleştirme ile Zone Oluştur';
      }
    });

    // UI Demo Mode: load mock results without waiting optimization
    (function initDemoMode() {
      try {
        const params = new URLSearchParams(window.location.search);
        if (!params.has('demo')) return;
        if (params.get('demo') !== '1') return;

        // Show results instantly
        if (emptyState) emptyState.classList.add('hidden');
        if (resultsSection) resultsSection.classList.remove('hidden');
        runMetaEl.textContent = 'Demo Mode (No optimization run)';

        // Simple symmetric mock master sequence (36 plies)
        const master = [
          45, 0, -45, 90, 0, 45, -45, 90, 0, 45, -45, 0, 90, 45, 0, -45, 90, 0,
          0, 90, -45, 0, 45, 90, 0, -45, 45, 90, 0, -45, 45, 0, 90, -45, 0, 45
        ];
        const demoData = {
          fitness_score: 96.2,
          max_score: 100,
          stats: { plies: master.length, population_size: 120, generations: 600, duration_seconds: 0.0 },
          master_sequence: master,
          drop_off_results: [],
          penalties: {
            R1: { weight: 20, score: 20, penalty: 0, reason: '' },
            R2: { weight: 12, score: 12, penalty: 0, reason: '' },
            R3: { weight: 13, score: 12.2, penalty: 0.8, reason: 'Demo: küçük yüzde sapması' },
            R4: { weight: 12, score: 12, penalty: 0, reason: '' },
            R5: { weight: 8, score: 7.6, penalty: 0.4, reason: 'Demo: dağılım iyileştirilebilir' },
            R6: { weight: 21, score: 21, penalty: 0, reason: '' },
            R7: { weight: 7, score: 7, penalty: 0, reason: '' },
            R8: { weight: 7, score: 6.4, penalty: 0.6, reason: 'Demo: lateral bending sınırına yakın' },
          },
          history: []
        };

        // Update globals so drop-off can be tested without waiting
        currentMasterSequence = [...demoData.master_sequence];
        originalMasterSequence = [...demoData.master_sequence];
        currentPlyCounts = { 0: 0, 90: 0, 45: 0, '-45': 0 };
        demoData.master_sequence.forEach(a => {
          if (a === 0) currentPlyCounts[0] += 1;
          else if (a === 90) currentPlyCounts[90] += 1;
          else if (a === 45) currentPlyCounts[45] += 1;
          else if (a === -45) currentPlyCounts['-45'] += 1;
        });
        if (currentPlyCountEl) currentPlyCountEl.textContent = currentMasterSequence.length;
        dropOffResults = [];

        // Render UI
        const fitnessPercentage = 100;
        fitnessScoreEl.textContent = `${demoData.fitness_score.toFixed(2)} / ${demoData.max_score.toFixed(2)}`;
        fitnessScoreEl.className = `text-3xl font-bold ${demoData.fitness_score >= 90 ? 'text-emerald-700' : demoData.fitness_score >= 70 ? 'text-amber-700' : 'text-rose-700'}`;
        fitnessHintEl.innerHTML = `<span class="text-slate-500">💡</span> Demo veri yüklendi.`;
        symmetryPenaltyEl.textContent = `20.00 / 20.00`;
        symmetryPenaltyEl.className = `text-2xl font-mono mt-2 text-emerald-700`;
        balanceScoreEl.textContent = `12.00 / 12.00`;
        balanceScoreEl.className = `text-2xl font-mono mt-2 text-emerald-700`;
        statsMetaEl.textContent = `${demoData.stats.plies} ply • pop ${demoData.stats.population_size} • ${demoData.stats.generations} generations`;

        renderSummary(demoData);
        renderPenalties(demoData.penalties || {});
        renderLaminateMap(demoData.master_sequence || [], []);
      } catch (e) {
        console.warn('Demo mode failed:', e);
      }
    })();
  </script>

  <!-- 3D Stacking View Module -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    // Global aesthetic constants
    const TECH_BG_COLOR  = 0x0f172a; // Slate-900  (koyu tema)
    const GRID_COLOR_1   = 0x1e293b; // Slate-800
    const GRID_COLOR_2   = 0x334155; // Slate-700
    const LIGHT_BG_COLOR = 0xf1f5f9; // Slate-100  (açık tema — mühendislik beyazı)
    const LIGHT_GRID_1   = 0xbdc3cd; // Slate-300  (ana ızgara)
    const LIGHT_GRID_2   = 0xdde3ec; // Slate-200  (ikinci ızgara)
    const BLOOM_PARAMS = { threshold: 0.9, strength: 0.4, radius: 0.15 };  // Reduced for performance

    // ==================== CONSTANTS ====================
    const ANGLE_COLORS = {
      '0': 0x34d399,  // bright emerald-green (0 deg fiber)
      '90': 0x60a5fa,  // bright blue (90 deg)
      '45': 0xf87171,  // bright coral-red (45 deg)
      '-45': 0xfbbf24,  // bright amber-yellow (-45 deg)
    };
    const ANGLE_HEX = { '0': '#34d399', '90': '#60a5fa', '45': '#f87171', '-45': '#fbbf24' };
    const ANGLE_LABELS = { '0': '0°', '90': '90°', '45': '+45°', '-45': '-45°' };
    const PLY_THICKNESS_MM = 0.125; // typical prepreg ply (mm)
    const PLY_HEIGHT = 0.08;
    const PLY_GAP = 0.02;
    const PLY_WIDTH = 5.0;
    const EDGE_COLOR = 0x64748b;
    const SEGMENT_DEPTH = 3.2;
    const RAMP_LENGTH = 2.0;

    // ==================== MODULE STATE ====================
    // ==================== MODULE STATE ====================
    let renderer, camera, scene, controls, containerEl, tooltipEl, composer;
    let zoneGroupContainer = null;
    let plyMeshes = [];       // { mesh, plyIdx, angle, baseY, zones }
    let currentZonesData = null;
    let currentSortedZones = null;
    let currentTotalDepth = 0;
    let explodeFactor = 0;    // 0..1
    let highlightedMesh = null;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let stackingWireframe = false;
    let stackingIsolatedAngle = null;

    // ==================== GRADIENT SKY BACKGROUND ====================
    function createGradientSky(scene) {
      const skyGeo = new THREE.SphereGeometry(80, 32, 32);
      const count = skyGeo.attributes.position.count;
      const colors = new Float32Array(count * 3);
      const topColor = new THREE.Color(0xd1d8e8);  // cooler sky
      const midColor = new THREE.Color(0xe8ecf4);  // soft transition
      const botColor = new THREE.Color(0xf1f5f9);  // warm ground
      for (let i = 0; i < count; i++) {
        const y = skyGeo.attributes.position.getY(i);
        const t = (y + 80) / 160; // 0 bottom, 1 top
        const c = t > 0.5
          ? midColor.clone().lerp(topColor, (t - 0.5) * 2)
          : botColor.clone().lerp(midColor, t * 2);
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }
      skyGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const skyMat = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide, fog: false });
      scene.add(new THREE.Mesh(skyGeo, skyMat));
    }

    // ==================== PROCEDURAL ENVIRONMENT MAP ====================
    function createEnvMap(renderer) {
      const pmrem = new THREE.PMREMGenerator(renderer);
      pmrem.compileCubemapShader();
      const envScene = new THREE.Scene();
      // Simple gradient env for reflections
      const envGeo = new THREE.SphereGeometry(10, 32, 32);
      const envCount = envGeo.attributes.position.count;
      const envColors = new Float32Array(envCount * 3);
      for (let i = 0; i < envCount; i++) {
        const y = envGeo.attributes.position.getY(i);
        const t = (y + 10) / 20;
        const c = new THREE.Color().lerpColors(new THREE.Color(0x8899bb), new THREE.Color(0xffffff), t);
        envColors[i * 3] = c.r; envColors[i * 3 + 1] = c.g; envColors[i * 3 + 2] = c.b;
      }
      envGeo.setAttribute('color', new THREE.BufferAttribute(envColors, 3));
      envScene.add(new THREE.Mesh(envGeo, new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide })));
      const envTex = pmrem.fromScene(envScene, 0.02).texture;
      pmrem.dispose();
      return envTex;
    }

    // ==================== FULLSCREEN TOGGLE ====================
    function toggleFullscreen(cardEl) {
      if (!cardEl) return;
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        cardEl.requestFullscreen().catch(() => { });
      }
    }

    // ==================== TOGGLE BUTTON STATE HELPER ====================
    function toggleBtnActive(btn, active) {
      if (!btn) return;
      btn.className = active
        ? 'px-2 py-1 text-xs rounded bg-slate-800 text-white transition flex items-center gap-1'
        : 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1';
    }

    // ==================== STATS OVERLAY UPDATE ====================
    function updateStackingStats(zones, weightInfo) {
      const overlay = document.getElementById('stacking-stats-overlay');
      if (!overlay) return;
      if (!zones || !zones.length) { overlay.classList.add('hidden'); return; }
      overlay.classList.remove('hidden');
      const validZones = zones.filter(z => z && z.sequence && z.sequence.length > 0);
      const maxPly = Math.max(0, ...validZones.map(z => z.ply_count));
      const thickness = (maxPly * PLY_THICKNESS_MM).toFixed(2);

      // Fixed selectors to match HTML (font-bold)
      const countEl = document.querySelector('#stats-zone-count .font-bold');
      if (countEl) countEl.textContent = validZones.length;

      const plyEl = document.querySelector('#stats-max-ply .font-bold');
      if (plyEl) plyEl.textContent = maxPly;

      const thickEl = document.querySelector('#stats-thickness .font-bold');
      if (thickEl) thickEl.textContent = thickness + ' mm';

      const wEl = document.querySelector('#stats-weight .font-bold');
      if (wEl) {
        if (weightInfo && weightInfo.total_weight_g) {
          wEl.textContent = weightInfo.total_weight_g.toFixed(1) + ' g';
        } else {
          wEl.textContent = '—';
        }
      }
    }

    // ==================== FIBER HATCHING TEXTURE ====================
    function createFiberTexture(angleDeg) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = 'rgba(255,255,255,0)';
      ctx.clearRect(0, 0, size, size);

      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1.2;

      const rad = (angleDeg * Math.PI) / 180;
      const step = 8;
      const diag = size * 2;

      ctx.save();
      ctx.translate(size / 2, size / 2);
      ctx.rotate(rad);
      for (let i = -diag; i < diag; i += step) {
        ctx.beginPath();
        ctx.moveTo(i, -diag);
        ctx.lineTo(i, diag);
        ctx.stroke();
      }
      ctx.restore();

      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(3, 3);
      return tex;
    }

    // Pre-generate hatching textures
    const fiberTextures = {};
    [0, 90, 45, -45].forEach(a => { fiberTextures[String(a)] = createFiberTexture(a); });

    // ==================== INIT ====================
    function initView3D(container) {
      containerEl = container;
      tooltipEl = container.parentElement?.querySelector('#view3d-tooltip') || null;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, preserveDrawingBuffer: true, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setClearColor(TECH_BG_COLOR, 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.NoToneMapping; // Handled by OutputPass
      container.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(TECH_BG_COLOR);
      scene.fog = new THREE.FogExp2(TECH_BG_COLOR, 0.02);

      // Tech Grid
      const gridHelper = new THREE.GridHelper(60, 60, GRID_COLOR_2, GRID_COLOR_1);
      gridHelper.position.y = -0.05;
      scene.add(gridHelper);

      // Camera
      const aspect = container.clientWidth / container.clientHeight;
      camera = new THREE.PerspectiveCamera(40, aspect, 0.1, 200);
      camera.position.set(10, 8, 12);

      // Environment
      const envMap = createEnvMap(renderer);
      scene.environment = envMap;
      scene.environmentIntensity = 0.8;

      // Lighting (Optimized - 2 lights instead of 4)
      const ambient = new THREE.AmbientLight(0xffffff, 0.6); // Increased ambient
      scene.add(ambient);
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.2); // Reduced intensity
      keyLight.position.set(10, 20, 10);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(1024, 1024); // Reduced shadow map size for performance
      scene.add(keyLight);

      // Post-Processing
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 1.5, 0.4, 0.85);
      bloomPass.threshold = BLOOM_PARAMS.threshold;
      bloomPass.strength = BLOOM_PARAMS.strength;
      bloomPass.radius = BLOOM_PARAMS.radius;
      composer.addPass(bloomPass);

      const outputPass = new OutputPass();
      composer.addPass(outputPass);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.autoRotateSpeed = 1.0;
      controls.minDistance = 2;
      controls.maxDistance = 80;
      controls.maxPolarAngle = Math.PI / 2 - 0.05;
      controls.target.set(0, 1, 0);
      controls.update();

      zoneGroupContainer = new THREE.Group();
      scene.add(zoneGroupContainer);

      // Animate
      (function animate() {
        requestAnimationFrame(animate);
        controls.update();
        composer.render();
      })();

      // Resize
      new ResizeObserver(() => {
        const w = container.clientWidth, h = container.clientHeight;
        if (!w || !h) return;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        composer.setSize(w, h);
      }).observe(container);

      // Events
      container.addEventListener('pointermove', onPointerMove);
      container.addEventListener('click', onPointerClick);

      // Camera Layout Buttons
      document.querySelectorAll('.view3d-cam-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const preset = btn.dataset.cam;
          setCameraPreset(preset);
        });
      });

      // Slider
      const slider = document.getElementById('exploded-slider');
      const sliderVal = document.getElementById('exploded-value');
      if (slider) {
        slider.addEventListener('input', () => {
          explodeFactor = parseInt(slider.value) / 100;
          sliderVal.textContent = slider.value + '%';
          applyExplodedView();
        });
      }

      // Export
      const exportBtn = document.getElementById('export-png-btn');
      if (exportBtn) exportBtn.addEventListener('click', exportPNG);

      // Auto Rotate
      const autoRotBtn = document.getElementById('stacking-autorotate-btn');
      if (autoRotBtn) {
        autoRotBtn.addEventListener('click', () => {
          controls.autoRotate = !controls.autoRotate;
          toggleBtnActive(autoRotBtn, controls.autoRotate);
        });
      }

      // Wireframe
      const wireBtn = document.getElementById('stacking-wireframe-btn');
      if (wireBtn) {
        wireBtn.addEventListener('click', () => {
          stackingWireframe = !stackingWireframe;
          toggleBtnActive(wireBtn, stackingWireframe);

          // Get unique InstancedMeshes
          const uniqueMeshes = [...new Set(plyMeshes.map(p => p.instancedMesh))].filter(Boolean);
          uniqueMeshes.forEach(mesh => {
            mesh.material.wireframe = stackingWireframe;
            mesh.material.opacity = stackingWireframe ? 0.3 : 1.0;
            mesh.material.transparent = stackingWireframe;
          });
        });
      }

      // Fullscreen
      const fullBtn = document.getElementById('stacking-fullscreen-btn');
      if (fullBtn) fullBtn.addEventListener('click', () => toggleFullscreen(document.getElementById('stacking-pane')));

      // Reset Iso
      const resetIsoBtn = document.getElementById('stacking-reset-isolation-btn');
      if (resetIsoBtn) {
        resetIsoBtn.addEventListener('click', () => {
          stackingIsolatedAngle = null;

          // Reset all InstancedMesh materials
          const uniqueMeshes = [...new Set(plyMeshes.map(p => p.instancedMesh))].filter(Boolean);
          uniqueMeshes.forEach(mesh => {
            mesh.material.opacity = 1;
            mesh.material.transparent = false;

            // Reset all instance colors to neutral white
            if (mesh.instanceColor) {
              for (let i = 0; i < mesh.count; i++) {
                mesh.instanceColor.setXYZ(i, 1, 1, 1);
              }
              mesh.instanceColor.needsUpdate = true;
            }
          });

          resetIsoBtn.classList.add('hidden');
        });
      }
    }

    // ==================== FULLSCREEN RESIZE HANDLER ====================
    document.addEventListener('fullscreenchange', () => {
      const fsEl = document.fullscreenElement;

      // Handle Stacking View
      const sContainer = document.getElementById('view3d-container');
      const sCard = document.getElementById('view3d-card');

      if (sContainer && sCard) {
        if (fsEl === sCard) {
          sContainer.style.height = 'calc(100vh - 60px)';
          sCard.classList.add('bg-slate-900'); // Tech dark
        } else {
          sContainer.style.height = '480px';
          sCard.classList.remove('bg-slate-900');
        }
      }

      // Handle Panel 3D
      const p3Container = document.getElementById('panel3d-container');
      const p3Pane = document.getElementById('panel3d-pane');

      if (p3Container && p3Pane) {
        if (fsEl === p3Pane) {
          p3Container.style.height = 'calc(100vh - 60px)';
          p3Pane.classList.add('bg-slate-900', 'p-4');
        } else {
          p3Container.style.height = '480px';
          p3Pane.classList.remove('bg-slate-900', 'p-4');
        }
      }

      setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 100);
    });

    // ==================== 3D STACKING VIEW ====================
    let _lastWeight = null;
    let _lastRampChecks = null;
    function update3DStackingView(zones, weightInfo, rampChecks) {
      _lastWeight = weightInfo || null;
      _lastRampChecks = rampChecks || null;
      if (!zoneGroupContainer) return;

      // Update stats overlay
      updateStackingStats(zones, weightInfo);

      // Clear
      while (zoneGroupContainer.children.length > 0) {
        const c = zoneGroupContainer.children[0];
        c.traverse(o => {
          if (o.geometry) o.geometry.dispose();
          if (o.material) {
            if (Array.isArray(o.material)) o.material.forEach(m => m.dispose());
            else o.material.dispose();
          }
        });
        zoneGroupContainer.remove(c);
      }
      plyMeshes = [];

      const validZones = zones.filter(z => z && z.sequence && z.sequence.length > 0);
      if (!validZones.length) return;
      const sortedZones = [...validZones].sort((a, b) => b.ply_count - a.ply_count);
      currentSortedZones = sortedZones;
      currentZonesData = zones;
      const numZones = sortedZones.length;
      const rootSeq = sortedZones[0].sequence;
      const maxPly = rootSeq.length;

      const totalDepth = numZones * SEGMENT_DEPTH + (numZones - 1) * RAMP_LENGTH;
      currentTotalDepth = totalDepth;
      const panelGroup = new THREE.Group();
      const zonePlyCounts = sortedZones.map(z => z.ply_count);
      const zoneZStarts = [];
      for (let j = 0; j < numZones; j++) zoneZStarts.push(j * (SEGMENT_DEPTH + RAMP_LENGTH));

      // ---- Build ply meshes with INSTANCED RENDERING ----
      // Group plies by angle for instancing
      const plyDataByAngle = { '0': [], '90': [], '45': [], '-45': [] };
      const plyMetadata = []; // Store metadata for each ply

      for (let plyIdx = 0; plyIdx < maxPly; plyIdx++) {
        const angle = rootSeq[plyIdx];
        const angleKey = String(angle);
        const baseY = plyIdx * (PLY_HEIGHT + PLY_GAP);

        let lastFullZone = -1;
        for (let j = 0; j < numZones; j++) {
          if (plyIdx < zonePlyCounts[j]) lastFullZone = j; else break;
        }
        if (lastFullZone < 0) continue;

        const zStart = 0;
        let zEnd;
        if (lastFullZone < numZones - 1) {
          const flatEnd = zoneZStarts[lastFullZone] + SEGMENT_DEPTH;
          const dropStart = zonePlyCounts[lastFullZone + 1];
          const dropEnd = zonePlyCounts[lastFullZone];
          const dropCount = dropEnd - dropStart;
          if (dropCount > 0) {
            const dropPos = plyIdx - dropStart;
            const t = 1.0 - (dropPos / dropCount);
            zEnd = flatEnd + RAMP_LENGTH * t;
          } else { zEnd = flatEnd; }
        } else {
          zEnd = zoneZStarts[lastFullZone] + SEGMENT_DEPTH;
        }

        const plyDepth = zEnd - zStart;
        if (plyDepth <= 0) continue;

        const zCenter = zStart + plyDepth / 2 - totalDepth / 2;

        // Which zones this ply spans
        const inZones = [];
        for (let j = 0; j <= lastFullZone; j++) inZones.push(sortedZones[j].index + 1);

        // Store ply data for this angle
        if (plyDataByAngle[angleKey]) {
          plyDataByAngle[angleKey].push({
            plyIdx, baseY, zCenter, plyDepth, angle, inZones, lastFullZone
          });
        }

        // Store metadata
        plyMetadata.push({ plyIdx, angle, baseY, zCenter, inZones, lastFullZone });
      }

      // Create InstancedMesh for each angle
      const baseGeo = new THREE.BoxGeometry(PLY_WIDTH, PLY_HEIGHT, 1.0); // Unit depth, scale via matrix
      const matrix = new THREE.Matrix4();
      const instancedMeshes = {};

      Object.keys(plyDataByAngle).forEach(angleKey => {
        const plies = plyDataByAngle[angleKey];
        if (!plies.length) return;

        const baseColor = ANGLE_COLORS[angleKey] || 0x94a3b8;
        const fiberTex = fiberTextures[angleKey] || null;

        // Use MeshStandardMaterial instead of MeshPhysicalMaterial for better performance
        const mat = new THREE.MeshStandardMaterial({
          color: baseColor,
          roughness: 0.3,
          metalness: 0.0,
          emissive: baseColor,
          emissiveIntensity: 0.08, // Reduced for performance
          transparent: false,
        });
        if (fiberTex) {
          mat.map = fiberTex;
          mat.map.needsUpdate = true;
          mat.map.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Better texture quality
        }

        // Create InstancedMesh
        const instancedMesh = new THREE.InstancedMesh(baseGeo, mat, plies.length);
        instancedMesh.castShadow = false; // Disable per-instance shadows for performance
        instancedMesh.receiveShadow = false;

        // Initialize instance color buffer for per-instance highlighting
        const colors = [];
        for (let i = 0; i < plies.length; i++) {
          colors.push(1, 1, 1); // White (neutral)
        }
        instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(colors), 3);

        // Set matrix for each instance
        plies.forEach((ply, idx) => {
          matrix.identity();
          matrix.makeTranslation(0, ply.baseY, ply.zCenter);
          matrix.scale(new THREE.Vector3(1, 1, ply.plyDepth)); // Scale depth
          instancedMesh.setMatrixAt(idx, matrix);
        });

        instancedMesh.instanceMatrix.needsUpdate = true;
        panelGroup.add(instancedMesh);
        instancedMeshes[angleKey] = { mesh: instancedMesh, plies };

        // Store for interaction
        plies.forEach((ply, idx) => {
          plyMeshes.push({
            instancedMesh,
            instanceIndex: idx,
            plyIdx: ply.plyIdx,
            angle: ply.angle,
            baseY: ply.baseY,
            zCenter: ply.zCenter,
            inZones: ply.inZones,
            lastFullZone: ply.lastFullZone,
            angleKey
          });
        });
      });

      // Add single shadow caster for entire panel group (performance optimization)
      panelGroup.castShadow = true;
      panelGroup.receiveShadow = true;

      // ---- Zone labels + dimension lines ----
      sortedZones.forEach((zone, zIdx) => {
        const topY = zone.ply_count * (PLY_HEIGHT + PLY_GAP);
        const segZ = zoneZStarts[zIdx] + SEGMENT_DEPTH / 2 - totalDepth / 2;
        const thicknessMM = (zone.ply_count * PLY_THICKNESS_MM).toFixed(2);

        // Zone label + weight
        let labelText = `Zone ${zone.index + 1}${zone.is_root ? ' (Root)' : ''} — ${zone.ply_count} ply`;
        if (_lastWeight && _lastWeight.has_geometry && _lastWeight.zone_weights_g[zIdx] != null) {
          labelText += ` • ${_lastWeight.zone_weights_g[zIdx].toFixed(1)}g`;
        }
        const sp = createTextSprite(labelText, zone.is_root);
        sp.position.set(0, topY + 0.35, segZ);
        sp.scale.set(3.0, 0.55, 1);
        panelGroup.add(sp);

        // Score
        const fitSp = createTextSprite(`Score: ${zone.fitness.toFixed(1)}`, false, true);
        fitSp.position.set(0, topY + 0.08, segZ);
        fitSp.scale.set(1.6, 0.35, 1);
        panelGroup.add(fitSp);

        // Dimension line (right side)
        const dimX = PLY_WIDTH / 2 + 0.4;
        const dimLineGeo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(dimX, 0, segZ),
          new THREE.Vector3(dimX, topY, segZ),
        ]);
        const dimLine = new THREE.Line(dimLineGeo, new THREE.LineBasicMaterial({ color: 0x475569, opacity: 0.7, transparent: true }));
        panelGroup.add(dimLine);

        // Top/bottom ticks
        [0, topY].forEach(tickY => {
          const tickGeo = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(dimX - 0.15, tickY, segZ),
            new THREE.Vector3(dimX + 0.15, tickY, segZ),
          ]);
          panelGroup.add(new THREE.Line(tickGeo, new THREE.LineBasicMaterial({ color: 0x475569 })));
        });

        // Dimension text
        const dimSp = createTextSprite(`${thicknessMM} mm`, false, true);
        dimSp.position.set(dimX + 0.6, topY / 2, segZ);
        dimSp.scale.set(1.4, 0.3, 1);
        panelGroup.add(dimSp);
      });

      zoneGroupContainer.add(panelGroup);
      frameCameraToFit(sortedZones, totalDepth);

      // Apply exploded if slider is not 0
      if (explodeFactor > 0) applyExplodedView();
    }

    // ==================== EXPLODED VIEW ====================
    function applyExplodedView() {
      const maxGap = 0.5; // max extra gap per ply at 100%
      const matrix = new THREE.Matrix4();

      // Group by InstancedMesh to minimize updates
      const meshUpdates = {};

      plyMeshes.forEach(({ instancedMesh, instanceIndex, baseY, zCenter, plyIdx }) => {
        if (!instancedMesh) return;

        const newY = baseY + plyIdx * maxGap * explodeFactor;
        const ply = plyMeshes.find(p => p.instancedMesh === instancedMesh && p.instanceIndex === instanceIndex);
        if (!ply) return;

        // Get current matrix or create new transform
        instancedMesh.getMatrixAt(instanceIndex, matrix);

        // Extract scale from matrix (z scale is ply depth)
        const scale = new THREE.Vector3();
        matrix.decompose(new THREE.Vector3(), new THREE.Quaternion(), scale);

        // Update position with exploded Y
        matrix.makeTranslation(0, newY, zCenter);
        matrix.scale(scale); // Reapply scale

        instancedMesh.setMatrixAt(instanceIndex, matrix);

        // Mark for update
        if (!meshUpdates[instancedMesh.uuid]) {
          meshUpdates[instancedMesh.uuid] = instancedMesh;
        }
      });

      // Update all modified InstancedMeshes
      Object.values(meshUpdates).forEach(mesh => {
        mesh.instanceMatrix.needsUpdate = true;
      });
    }

    // ==================== CAMERA PRESETS ====================
    function setCameraPreset(preset) {
      if (!currentSortedZones) return;
      const maxH = currentSortedZones[0].ply_count * (PLY_HEIGHT + PLY_GAP);
      const cY = maxH / 2;
      const d = Math.max(currentTotalDepth, PLY_WIDTH, maxH * 2) * 1.1;

      const presets = {
        iso: { pos: [d * 0.55, d * 0.45, d * 0.8], target: [0, cY, 0] },
        top: { pos: [0, d * 1.2, 0.01], target: [0, 0, 0] },
        front: { pos: [0, cY, d * 1.0], target: [0, cY, 0] },
        side: { pos: [d * 1.0, cY, 0], target: [0, cY, 0] },
      };
      const p = presets[preset] || presets.iso;

      // Smooth transition
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const endPos = new THREE.Vector3(...p.pos);
      const endTarget = new THREE.Vector3(...p.target);
      const duration = 600;
      const startTime = performance.now();

      function animateCam(now) {
        const t = Math.min((now - startTime) / duration, 1);
        const ease = t < 0.5 ? 2 * t * t : 1 - (-2 * t + 2) ** 2 / 2; // easeInOutQuad
        camera.position.lerpVectors(startPos, endPos, ease);
        controls.target.lerpVectors(startTarget, endTarget, ease);
        controls.update();
        if (t < 1) requestAnimationFrame(animateCam);
      }
      requestAnimationFrame(animateCam);
    }

    // ==================== CAMERA AUTO-FRAME ====================
    function frameCameraToFit(sortedZones, totalDepth) {
      const maxH = sortedZones[0].ply_count * (PLY_HEIGHT + PLY_GAP);
      const cY = maxH / 2;
      const d = Math.max(PLY_WIDTH, totalDepth, maxH * 2) * 1.0;
      camera.position.set(d * 0.55, d * 0.45, d * 0.8);
      controls.target.set(0, cY, 0);
      controls.update();
    }

    // ==================== HOVER / TOOLTIP ====================
    function onPointerMove(e) {
      if (!containerEl || !tooltipEl) return;
      const rect = containerEl.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // Get all unique InstancedMeshes
      const instancedMeshes = [...new Set(plyMeshes.map(p => p.instancedMesh))].filter(Boolean);
      const hits = raycaster.intersectObjects(instancedMeshes, false);

      // Reset previous highlight
      if (highlightedMesh && highlightedMesh.instanceId !== undefined) {
        const prev = plyMeshes.find(p =>
          p.instancedMesh === highlightedMesh.mesh &&
          p.instanceIndex === highlightedMesh.instanceId
        );
        if (prev && prev.instancedMesh && prev.instancedMesh.instanceColor) {
          // Reset to neutral white
          prev.instancedMesh.instanceColor.setXYZ(highlightedMesh.instanceId, 1, 1, 1);
          prev.instancedMesh.instanceColor.needsUpdate = true;
        }
        highlightedMesh = null;
      }

      if (hits.length > 0) {
        const hit = hits[0];
        const hitMesh = hit.object;
        const instanceId = hit.instanceId;

        const info = plyMeshes.find(p =>
          p.instancedMesh === hitMesh &&
          p.instanceIndex === instanceId
        );

        if (info) {
          // Highlight by setting instance color to gray
          if (hitMesh.instanceColor) {
            hitMesh.instanceColor.setXYZ(instanceId, 1.5, 1.5, 1.5); // Brighter for highlight
            hitMesh.instanceColor.needsUpdate = true;
          }
          highlightedMesh = { mesh: hitMesh, instanceId };

          const realThickness = ((info.plyIdx + 1) * PLY_THICKNESS_MM).toFixed(2);
          const angleColor = ANGLE_HEX[String(info.angle)] || '#94a3b8';
          const angleLabel = ANGLE_LABELS[String(info.angle)] || info.angle + '°';

          let ttHtml = `
            <div class="flex items-center justify-between mb-1 border-b border-slate-700 pb-1">
              <span class="font-bold text-white">Layer ${info.plyIdx + 1}</span>
              <span class="text-[10px] px-1.5 py-0.5 rounded text-slate-900 font-bold" style="background:${angleColor}">${angleLabel}</span>
            </div>
            <div class="space-y-0.5">
              <div class="flex justify-between"><span class="text-slate-400">Konum:</span> <span>${realThickness} mm</span></div>
              <div class="flex justify-between"><span class="text-slate-400">Zone:</span> <span class="truncate max-w-[100px]">${info.inZones.join(', ')}</span></div>
            </div>
          `;
          // Ağırlık bilgisi ekle
          if (_lastWeight && _lastWeight.has_geometry) {
            ttHtml += `<div class="border-t border-slate-700 mt-1 pt-1 text-[10px] text-slate-400 flex justify-between"><span>Toplam:</span> <span>${_lastWeight.total_weight_g.toFixed(1)}g</span></div>`;
          }
          tooltipEl.innerHTML = ttHtml;
          tooltipEl.classList.remove('hidden');
          tooltipEl.style.left = (e.clientX - containerEl.getBoundingClientRect().left + 12) + 'px';
          tooltipEl.style.top = (e.clientY - containerEl.getBoundingClientRect().top - 10) + 'px';
        }
        containerEl.style.cursor = 'pointer';
      } else {
        tooltipEl.classList.add('hidden');
        containerEl.style.cursor = 'grab';
      }
    }

    function onPointerClick(e) {
      if (!containerEl) return;
      const rect = containerEl.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // Get all unique InstancedMeshes
      const instancedMeshes = [...new Set(plyMeshes.map(p => p.instancedMesh))].filter(Boolean);
      const hits = raycaster.intersectObjects(instancedMeshes, false);

      if (hits.length > 0) {
        const hit = hits[0];
        const info = plyMeshes.find(p =>
          p.instancedMesh === hit.object &&
          p.instanceIndex === hit.instanceId
        );

        if (info) {
          // Isolate by angle
          stackingIsolatedAngle = info.angle;

          // Get unique meshes and apply opacity
          const uniqueMeshes = [...new Set(plyMeshes.map(p => p.instancedMesh))].filter(Boolean);
          uniqueMeshes.forEach(mesh => {
            // Find the angle for this mesh
            const samplePly = plyMeshes.find(p => p.instancedMesh === mesh);
            if (samplePly) {
              if (samplePly.angle !== info.angle) {
                mesh.material.opacity = 0.1;
                mesh.material.transparent = true;
              } else {
                mesh.material.opacity = 1;
                mesh.material.transparent = false;
              }
            }
          });

          // Show reset button
          const btn = document.getElementById('stacking-reset-isolation-btn');
          if (btn) {
            btn.classList.remove('hidden');
            btn.innerHTML = `<span class="font-bold">${info.angle}°</span> Gösteriliyor (Sıfırla)`;
          }
        }
      }
    }

    // ==================== ML SURROGATE STATUS ====================
    (async function checkMLStatus() {
      const badge = document.getElementById('ml-status-badge');
      const toggle = document.getElementById('ml-surrogate-toggle');
      if (!badge || !toggle) return;
      try {
        const res = await fetch('/ml/status');
        const data = await res.json();
        if (data.ml_available && data.exists) {
          badge.textContent = 'Hazir';
          badge.className = 'ml-auto text-[10px] px-1.5 py-0.5 rounded bg-violet-900/50 text-violet-300';
        } else if (data.ml_available) {
          badge.textContent = 'Model yok';
          badge.className = 'ml-auto text-[10px] px-1.5 py-0.5 rounded bg-amber-900/50 text-amber-300';
          toggle.disabled = true;
        } else {
          badge.textContent = 'Devre disi';
          badge.className = 'ml-auto text-[10px] px-1.5 py-0.5 rounded bg-slate-700 text-slate-500';
          toggle.disabled = true;
        }
      } catch {
        badge.textContent = 'Baglanti yok';
        toggle.disabled = true;
      }
    })();

    // ==================== PDF RAPOR EXPORT ====================
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    if (exportPdfBtn) {
      exportPdfBtn.addEventListener('click', exportPdfReport);
    }

    async function exportPdfReport() {
      const zones = window._laminateMapZones;
      if (!zones || !zones.length) {
        alert('PDF olusturmak icin once optimizasyon calistirin.');
        return;
      }

      const engineerName = prompt('Muhendis Adi (bos birakilabilir):', '') || '';
      const projectName = prompt('Proje Adi:', 'TUSAS Laminat Optimizasyonu') || 'TUSAS Laminat Optimizasyonu';

      const btn = document.getElementById('export-pdf-btn');
      const origText = btn.innerHTML;
      btn.innerHTML = '<span class="animate-pulse">PDF olusturuluyor...</span>';
      btn.disabled = true;

      try {
        const payload = {
          zones: zones.filter(z => z !== null),
          optimization_params: {
            zone_count: zones.filter(z => z !== null).length,
            rule_weights: window._lastRuleWeights || {},
            population_size: window._lastPopSize || '-',
            generations: window._lastGenCount || '-',
            duration_seconds: window._lastDuration || '-',
          },
          engineer_name: engineerName,
          project_name: projectName,
          revision: 'Rev. 1',
        };

        const res = await fetch('/report/pdf', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });

        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.error || 'PDF olusturulamadi');
        }

        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'optimizasyon_raporu.pdf';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (err) {
        alert('PDF olusturma hatasi: ' + err.message);
      } finally {
        btn.innerHTML = origText;
        btn.disabled = false;
      }
    }

    // ==================== EXCEL EXPORT ====================
    const exportExcelBtn = document.getElementById('export-excel-btn');
    if (exportExcelBtn) {
      exportExcelBtn.addEventListener('click', exportLaminateMapExcel);
    }

    async function exportLaminateMapExcel() {
      const zones = window._laminateMapZones;
      const transitions = window._laminateMapTransitions || [];
      if (!zones || !zones.length) {
        alert('Dışa aktarılacak veri yok. Lütfen önce optimizasyon çalıştırın.');
        return;
      }
      if (typeof ExcelJS === 'undefined') {
        alert('Excel kütüphanesi yüklenmedi. Sayfayı yenileyin ve tekrar deneyin.');
        return;
      }

      const sortedZones = [...zones].filter(z => z !== null).sort((a, b) => b.ply_count - a.ply_count);
      const rootZone = sortedZones.find(z => z.is_root) || sortedZones[0];
      const rootSeq = rootZone ? rootZone.sequence : [];
      const maxLen = rootSeq.length;
      const today = new Date();
      const todayStr = today.toLocaleDateString('tr-TR');
      const todayISO = today.toISOString().slice(0, 10);
      const docNo = 'TAI-COMP-OPT-' + todayISO;

      function normalizeAngleCounts(obj) {
        const out = { '0': 0, '90': 0, '45': 0, '-45': 0 };
        if (!obj || typeof obj !== 'object') return out;
        for (const [k, v] of Object.entries(obj)) {
          const key = String(parseInt(k, 10));
          if (Object.prototype.hasOwnProperty.call(out, key)) out[key] = parseInt(v, 10) || 0;
        }
        return out;
      }

      const rootBaseMap = Array.from({ length: maxLen }, (_, i) => i);
      const transitionByTo = new Map();
      (transitions || []).forEach(tr => {
        if (tr && typeof tr.to === 'number') transitionByTo.set(tr.to, tr);
      });
      const rootIndexMapMemo = new Map();
      function computeRootIndexMap(zoneIndex) {
        if (rootIndexMapMemo.has(zoneIndex)) return rootIndexMapMemo.get(zoneIndex);
        if (!rootZone || zoneIndex === rootZone.index) {
          rootIndexMapMemo.set(zoneIndex, rootBaseMap);
          return rootBaseMap;
        }
        const tr = transitionByTo.get(zoneIndex);
        if (!tr) { rootIndexMapMemo.set(zoneIndex, null); return null; }
        const parentIndex = Array.isArray(tr.from) ? tr.from[0] : tr.from;
        const parentMap = computeRootIndexMap(parentIndex);
        if (!parentMap) { rootIndexMapMemo.set(zoneIndex, null); return null; }
        const dropped = new Set((tr.dropped_indices || []).map(n => parseInt(n, 10)).filter(n => Number.isFinite(n) && n >= 0));
        const childMap = parentMap.filter((_rootIdx, posInParent) => !dropped.has(posInParent));
        rootIndexMapMemo.set(zoneIndex, childMap);
        return childMap;
      }

      // ===== GRAFİKLER =====
      const angle0 = rootSeq.filter(a => a === 0).length;
      const angle90 = rootSeq.filter(a => a === 90).length;
      const angle45 = rootSeq.filter(a => a === 45).length;
      const angleMinus45 = rootSeq.filter(a => a === -45).length;

      // Tüm zone'lar için yığılmış çubuk grafik (stacked bar)
      const stackedCanvas = document.createElement('canvas');
      stackedCanvas.width = Math.max(400, 100 + sortedZones.length * 90);
      stackedCanvas.height = 360;
      const stackedAngleCounts = sortedZones.map(z => normalizeAngleCounts(z.ply_counts));
      const stackedChart = new Chart(stackedCanvas.getContext('2d'), {
        type: 'bar',
        data: {
          labels: sortedZones.map(z => 'Zone ' + (z.index + 1) + (z.is_root ? ' (Root)' : '')),
          datasets: [
            {
              label: '0°',
              data: stackedAngleCounts.map((c, i) => sortedZones[i].ply_count > 0 ? ((c['0'] / sortedZones[i].ply_count) * 100) : 0),
              backgroundColor: 'rgba(239,68,68,0.85)',
              borderColor: '#EF4444',
              borderWidth: 1
            },
            {
              label: '90°',
              data: stackedAngleCounts.map((c, i) => sortedZones[i].ply_count > 0 ? ((c['90'] / sortedZones[i].ply_count) * 100) : 0),
              backgroundColor: 'rgba(59,130,246,0.85)',
              borderColor: '#3B82F6',
              borderWidth: 1
            },
            {
              label: '+45°',
              data: stackedAngleCounts.map((c, i) => sortedZones[i].ply_count > 0 ? ((c['45'] / sortedZones[i].ply_count) * 100) : 0),
              backgroundColor: 'rgba(34,197,94,0.85)',
              borderColor: '#22C55E',
              borderWidth: 1
            },
            {
              label: '-45°',
              data: stackedAngleCounts.map((c, i) => sortedZones[i].ply_count > 0 ? ((c['-45'] / sortedZones[i].ply_count) * 100) : 0),
              backgroundColor: 'rgba(245,158,11,0.85)',
              borderColor: '#F59E0B',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: false,
          scales: {
            x: { stacked: true },
            y: { stacked: true, min: 0, max: 100, title: { display: true, text: 'Yüzde (%)' } }
          },
          plugins: {
            title: { display: true, text: 'Açı Dağılımı — Tüm Zoneler (%)', font: { size: 15, weight: 'bold' } },
            legend: { position: 'bottom', labels: { font: { size: 12 } } }
          }
        }
      });
      await new Promise(r => setTimeout(r, 150));
      const pieChartImage = stackedCanvas.toDataURL('image/png');


      // ===== ÇALIŞMA KİTABI =====
      const workbook = new ExcelJS.Workbook();
      workbook.creator = 'TAI — TUSAŞ Kompozit Mühendisliği';
      workbook.created = today;
      workbook.modified = today;
      workbook.lastModifiedBy = 'TUSAŞ Laminat Optimizatörü v3.0';

      // ===== ORTAK STİLLER =====
      const S = {
        titleFill:   { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1E3A8A' } },
        titleFont:   { name: 'Calibri', size: 18, bold: true, color: { argb: 'FFFFFFFF' } },
        sectionFill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1E40AF' } },
        sectionFont: { name: 'Calibri', size: 11, bold: true, color: { argb: 'FFFFFFFF' } },
        labelFont:   { name: 'Calibri', size: 10, bold: true, color: { argb: 'FF1E3A8A' } },
        valueFont:   { name: 'Calibri', size: 10, color: { argb: 'FF1F2937' } },
        headerFill:  { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1E40AF' } },
        headerFont:  { name: 'Calibri', size: 11, bold: true, color: { argb: 'FFFFFFFF' } },
        passFill:    { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD1FAE5' } },
        passFont:    { name: 'Calibri', size: 10, bold: true, color: { argb: 'FF059669' } },
        warnFill:    { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFEF3C7' } },
        warnFont:    { name: 'Calibri', size: 10, bold: true, color: { argb: 'FFD97706' } },
        failFill:    { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFEE2E2' } },
        failFont:    { name: 'Calibri', size: 10, bold: true, color: { argb: 'FFDC2626' } },
        border:      { top: { style: 'thin', color: { argb: 'FFD1D5DB' } }, left: { style: 'thin', color: { argb: 'FFD1D5DB' } }, bottom: { style: 'thin', color: { argb: 'FFD1D5DB' } }, right: { style: 'thin', color: { argb: 'FFD1D5DB' } } },
        ply0Fill:    { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFECACA' } },
        ply0Font:    { name: 'Calibri', size: 9, bold: true, color: { argb: 'FF991B1B' } },
        ply90Fill:   { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFBFDBFE' } },
        ply90Font:   { name: 'Calibri', size: 9, bold: true, color: { argb: 'FF1E3A8A' } },
        ply45Fill:   { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD1FAE5' } },
        ply45Font:   { name: 'Calibri', size: 9, bold: true, color: { argb: 'FF065F46' } },
        plyM45Fill:  { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFEF3C7' } },
        plyM45Font:  { name: 'Calibri', size: 9, bold: true, color: { argb: 'FF92400E' } },
        centerAlign: { vertical: 'middle', horizontal: 'center' },
        leftAlign:   { vertical: 'middle', horizontal: 'left' },
        wrapAlign:   { vertical: 'middle', horizontal: 'left', wrapText: true },
      };

      function applyRuleStatus(cell, score, weight) {
        const penalty = weight - score;
        const ratio = weight > 0 ? score / weight : 1;
        if (penalty <= 0.001) {
          cell.fill = S.passFill; cell.font = S.passFont; cell.value = '✓ UYGUN';
        } else if (ratio >= 0.8) {
          cell.fill = S.warnFill; cell.font = S.warnFont; cell.value = '⚠ UYARI';
        } else {
          cell.fill = S.failFill; cell.font = S.failFont; cell.value = '✗ AYKIRI';
        }
        cell.alignment = S.centerAlign;
        cell.border = S.border;
      }

      function addSheetTitle(ws, text, lastCol) {
        const r = ws.addRow([text]);
        ws.mergeCells('A' + ws.rowCount + ':' + lastCol + ws.rowCount);
        r.height = 36;
        r.getCell(1).fill = S.titleFill;
        r.getCell(1).font = S.titleFont;
        r.getCell(1).alignment = S.centerAlign;
      }

      function addSectionHeader(ws, text, lastCol) {
        const r = ws.addRow([text]);
        ws.mergeCells('A' + ws.rowCount + ':' + lastCol + ws.rowCount);
        r.height = 22;
        r.getCell(1).fill = S.sectionFill;
        r.getCell(1).font = S.sectionFont;
        r.getCell(1).alignment = S.leftAlign;
      }

      const avgFitness = (sortedZones.reduce((s, z) => s + (z.fitness || 0), 0) / sortedZones.length).toFixed(2);

      // ============================================================
      // SAYFA 1: KAPAK SAYFASI
      // ============================================================
      const wsCover = workbook.addWorksheet('Kapak', { views: [{ showGridLines: false }] });
      wsCover.getColumn('A').width = 30;
      wsCover.getColumn('B').width = 32;
      wsCover.getColumn('C').width = 22;
      wsCover.getColumn('D').width = 22;

      wsCover.addRow([]);
      wsCover.mergeCells('A2:D2');
      const coverTitle1 = wsCover.getCell('A2');
      coverTitle1.value = 'TÜRK HAVACILIK VE UZAY SANAYİİ A.Ş.';
      coverTitle1.font = { name: 'Calibri', size: 20, bold: true, color: { argb: 'FFFFFFFF' } };
      coverTitle1.fill = S.titleFill;
      coverTitle1.alignment = S.centerAlign;
      wsCover.getRow(2).height = 44;

      wsCover.mergeCells('A3:D3');
      const coverTitle2 = wsCover.getCell('A3');
      coverTitle2.value = 'KOMPOZİT LAMINAT YIĞILIM DİZİLİMİ OPTİMİZASYON RAPORU';
      coverTitle2.font = { name: 'Calibri', size: 13, bold: true, color: { argb: 'FF1E3A8A' } };
      coverTitle2.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE0E7FF' } };
      coverTitle2.alignment = S.centerAlign;
      wsCover.getRow(3).height = 28;

      wsCover.addRow([]);

      // Doküman Kontrol Tablosu
      addSectionHeader(wsCover, 'DOKÜMAN KONTROL BİLGİLERİ', 'D');
      const dcHdr = wsCover.addRow(['Alan', 'Değer', 'Alan', 'Değer']);
      dcHdr.height = 20;
      dcHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      [
        ['Doküman No:', docNo, 'Revizyon:', 'Rev A'],
        ['Tarih:', todayStr, 'Saat:', today.toLocaleTimeString('tr-TR')],
        ['Yazılım:', 'TAI Laminat Optimizatörü v3.0', 'Doküman Tipi:', 'Teknik Rapor'],
        ['Gizlilik:', 'TAI İÇ KULLANIM', 'Dil:', 'Türkçe / İngilizce'],
      ].forEach(([l1, v1, l2, v2]) => {
        const r = wsCover.addRow([l1, v1, l2, v2]);
        r.height = 18;
        [1, 3].forEach(i => {
          r.getCell(i).font = S.labelFont;
          r.getCell(i).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
          r.getCell(i).border = S.border;
          r.getCell(i).alignment = S.leftAlign;
        });
        [2, 4].forEach(i => {
          r.getCell(i).font = S.valueFont;
          r.getCell(i).border = S.border;
          r.getCell(i).alignment = S.leftAlign;
        });
      });

      wsCover.addRow([]);

      // İmza Tablosu
      addSectionHeader(wsCover, 'ONAY', 'D');
      const sigHdr = wsCover.addRow(['', 'Hazırlayan', 'Kontrol Eden', 'Onaylayan']);
      sigHdr.height = 20;
      sigHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      ['İsim Soyad:', 'Ünvan:', 'Tarih:', 'İmza:'].forEach((field, fi) => {
        const r = wsCover.addRow([field, '', '', '']);
        r.height = fi === 3 ? 38 : 20;
        r.getCell(1).font = S.labelFont;
        r.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
        r.getCell(1).border = S.border;
        r.getCell(1).alignment = S.leftAlign;
        [2, 3, 4].forEach(i => { r.getCell(i).border = S.border; });
      });

      wsCover.addRow([]);

      // Optimizasyon Parametreleri
      addSectionHeader(wsCover, 'OPTİMİZASYON PARAMETRELERİ', 'D');
      const paramHdr = wsCover.addRow(['Parametre', 'Değer', 'Parametre', 'Değer']);
      paramHdr.height = 20;
      paramHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      [
        ['Zone Sayısı:', sortedZones.length, 'Root Zone Kat Sayısı:', rootZone ? rootZone.ply_count : '-'],
        ['Maks. Kalınlık (mm):', rootZone ? (rootZone.ply_count * 0.125).toFixed(3) : '-', 'Ort. Fitness Skoru:', avgFitness + ' / 100'],
        ['Kat Malzemesi:', 'CFRP Prepreg', 'Nominal Kat Kalınlığı:', '0,125 mm'],
        ['Geçiş (Drop-off) Sayısı:', transitions.length, 'Malzeme Yoğunluğu:', '1,58 g/cm³'],
      ].forEach(([l1, v1, l2, v2]) => {
        const r = wsCover.addRow([l1, v1, l2, v2]);
        r.height = 18;
        [1, 3].forEach(i => {
          r.getCell(i).font = S.labelFont;
          r.getCell(i).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
          r.getCell(i).border = S.border;
          r.getCell(i).alignment = S.leftAlign;
        });
        [2, 4].forEach(i => {
          r.getCell(i).font = S.valueFont;
          r.getCell(i).border = S.border;
          r.getCell(i).alignment = S.leftAlign;
        });
      });

      wsCover.addRow([]);

      const noteRow = wsCover.addRow(['⚠ NOT: Bu rapor TUSAŞ Laminat Optimizasyon Yazılımı tarafından otomatik olarak oluşturulmuştur. Üretim öncesi yetkili mühendis tarafından doğrulanmalıdır. Resmi onay için imzalı basılı kopyaya başvurunuz.']);
      wsCover.mergeCells('A' + wsCover.rowCount + ':D' + wsCover.rowCount);
      noteRow.height = 36;
      noteRow.getCell(1).font = { name: 'Calibri', size: 9, italic: true, color: { argb: 'FF92400E' } };
      noteRow.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFEF3C7' } };
      noteRow.getCell(1).alignment = S.wrapAlign;
      noteRow.getCell(1).border = { top: { style: 'thin', color: { argb: 'FFFBBF24' } }, left: { style: 'thin', color: { argb: 'FFFBBF24' } }, bottom: { style: 'thin', color: { argb: 'FFFBBF24' } }, right: { style: 'thin', color: { argb: 'FFFBBF24' } } };

      // ============================================================
      // SAYFA 2: GENEL ÖZET
      // ============================================================
      const wsDash = workbook.addWorksheet('Genel Özet', { views: [{ showGridLines: false }] });
      wsDash.getColumn('A').width = 36;
      wsDash.getColumn('B').width = 30;
      wsDash.getColumn('C').width = 18;
      wsDash.getColumn('D').width = 18;
      // Açı dağılımı için dinamik sütun genişlikleri (zone başına 2 sütun)
      for (let ci = 2; ci <= 1 + sortedZones.length * 2; ci++) {
        wsDash.getColumn(ci).width = ci === 2 ? 24 : 12;
      }

      addSheetTitle(wsDash, 'TUSAŞ — GENEL OPTİMİZASYON ÖZETİ', 'D');
      wsDash.addRow([]);

      addSectionHeader(wsDash, 'GENEL İSTATİSTİKLER', 'B');
      [
        ['Toplam Zone Sayısı:', sortedZones.length],
        ['Root Zone Kat Sayısı:', rootZone ? rootZone.ply_count : '-'],
        ['Maks. Laminat Kalınlığı (mm):', rootZone ? (rootZone.ply_count * 0.125).toFixed(3) : '-'],
        ['Ortalama Fitness Skoru:', avgFitness + ' / 100'],
        ['Rapor Tarihi / Saati:', todayStr + '  ' + today.toLocaleTimeString('tr-TR')],
        ['Doküman No:', docNo],
      ].forEach(([l, v]) => {
        const r = wsDash.addRow([l, v]);
        r.height = 18;
        r.getCell(1).font = S.labelFont;
        r.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
        r.getCell(1).border = S.border;
        r.getCell(2).font = S.valueFont;
        r.getCell(2).border = S.border;
      });

      wsDash.addRow([]);

      wsDash.addRow([]);

      // Kural Uyumu Özeti — GERÇEK VERİDEN
      addSectionHeader(wsDash, 'TASARIM KURALLARI UYUM ÖZETİ (ROOT ZONE)', 'D');
      const compHdr = wsDash.addRow(['Kural', 'Açıklama', 'Skor', 'Durum']);
      compHdr.height = 20;
      compHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      const ruleDesc = {
        R1: 'Simetri (orta düzlem)',
        R2: 'Denge (±45° eşit sayıda)',
        R3: 'Yüzde Kuralı (%8–67)',
        R4: 'Dış Katmanlar (±45°)',
        R5: 'Dağılım (varyans bazlı)',
        R6: 'Gruplandırma (maks 3 ardışık)',
        R7: 'Burkulma (±45° merkez uzaklık)',
        R8: 'Yanal Eğilme (90° merkez uzaklık)',
      };
      const rootPenalties = (rootZone && rootZone.penalties) ? rootZone.penalties : {};
      ['R1','R2','R3','R4','R5','R6','R7','R8'].forEach(rKey => {
        const rData = rootPenalties[rKey];
        let scoreStr = '-', score = 0, weight = 0;
        if (rData && typeof rData === 'object') {
          score = Number(rData.score) || 0;
          weight = Number(rData.weight) || 0;
          scoreStr = score.toFixed(2) + ' / ' + weight.toFixed(1);
        }
        const r = wsDash.addRow([rKey, ruleDesc[rKey] || '', scoreStr, '']);
        r.height = 18;
        r.getCell(1).font = S.labelFont; r.getCell(1).alignment = S.centerAlign; r.getCell(1).border = S.border;
        r.getCell(2).font = S.valueFont; r.getCell(2).alignment = S.leftAlign; r.getCell(2).border = S.border;
        r.getCell(3).font = { name: 'Calibri', size: 10 }; r.getCell(3).alignment = S.centerAlign; r.getCell(3).border = S.border;
        if (rData && typeof rData === 'object') {
          applyRuleStatus(r.getCell(4), score, weight);
        } else {
          r.getCell(4).value = '-'; r.getCell(4).border = S.border; r.getCell(4).alignment = S.centerAlign;
        }
      });

      const pieImageId = workbook.addImage({ base64: pieChartImage.split(',')[1], extension: 'png' });
      const chartImgWidth = Math.max(320, 80 + sortedZones.length * 80);
      wsDash.addImage(pieImageId, { tl: { col: 4.5, row: 1 }, ext: { width: chartImgWidth, height: 280 } });

      // ============================================================
      // SAYFA 3: ZONE DETAYLARI
      // ============================================================
      const wsZones = workbook.addWorksheet('Zone Detayları');

      const zHdr = ['Zone', 'Kat Sayısı', 'Kalınlık (mm)', 'Ağırlık (g/m²)', 'Fitness'];
      for (let i = 1; i <= maxLen; i++) zHdr.push('K' + i);
      zHdr.push('0°', '90°', '+45°', '-45°', 'Toplam');

      const zHdrRow = wsZones.addRow(zHdr);
      zHdrRow.height = 24;
      zHdrRow.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      sortedZones.forEach(zone => {
        const isRoot = zone.is_root;
        const name = 'Zone ' + (zone.index + 1) + (isRoot ? ' (Root)' : '');
        const thickness = ((zone.ply_count || 0) * 0.125).toFixed(3);
        const weightGm2 = Math.round((zone.ply_count || 0) * 0.125 * 1580);
        const fitness = typeof zone.fitness === 'number' ? zone.fitness.toFixed(2) : '';
        const rowData = [name, zone.ply_count ?? '', thickness, weightGm2, fitness];

        let presentRootSet = null;
        if (isRoot) {
          presentRootSet = new Set(rootBaseMap);
        } else {
          const rm = computeRootIndexMap(zone.index);
          if (rm && rm.length) presentRootSet = new Set(rm);
        }

        const plyValues = [];
        rootSeq.forEach((angle, idx) => {
          if (!isRoot && presentRootSet) plyValues.push(presentRootSet.has(idx) ? (angle + '\xb0') : 'X');
          else if (!isRoot) plyValues.push('');
          else plyValues.push(angle + '\xb0');
        });
        rowData.push(...plyValues);

        const counts = normalizeAngleCounts(zone.ply_counts);
        const total = Object.values(counts).reduce((s, v) => s + v, 0);
        rowData.push(counts['0'], counts['90'], counts['45'], counts['-45'], total);

        const dataRow = wsZones.addRow(rowData);
        dataRow.eachCell((cell, colNum) => {
          cell.border = S.border;
          cell.alignment = S.centerAlign;
          if (colNum > 5 && colNum <= 5 + maxLen) {
            const val = cell.value;
            if (val === '0\xb0')   { cell.fill = S.ply0Fill;   cell.font = S.ply0Font; }
            else if (val === '90\xb0')  { cell.fill = S.ply90Fill;  cell.font = S.ply90Font; }
            else if (val === '45\xb0')  { cell.fill = S.ply45Fill;  cell.font = S.ply45Font; }
            else if (val === '-45\xb0') { cell.fill = S.plyM45Fill; cell.font = S.plyM45Font; }
            else if (val === 'X') { cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF3F4F6' } }; cell.font = { name: 'Calibri', size: 8, color: { argb: 'FF9CA3AF' } }; }
          }
          if (colNum === 5 && typeof cell.value === 'string') {
            const fv = parseFloat(cell.value);
            if (!isNaN(fv)) {
              if (fv >= 95)      { cell.fill = S.passFill; cell.font = S.passFont; }
              else if (fv >= 90) { cell.fill = S.warnFill; cell.font = S.warnFont; }
              else               { cell.fill = S.failFill; cell.font = S.failFont; }
            }
          }
        });
      });

      wsZones.getColumn(1).width = 18; wsZones.getColumn(2).width = 12;
      wsZones.getColumn(3).width = 15; wsZones.getColumn(4).width = 15; wsZones.getColumn(5).width = 14;
      for (let i = 6; i <= 5 + maxLen; i++) wsZones.getColumn(i).width = 6.5;
      wsZones.getColumn(6 + maxLen).width = 7; wsZones.getColumn(7 + maxLen).width = 7;
      wsZones.getColumn(8 + maxLen).width = 7; wsZones.getColumn(9 + maxLen).width = 7;
      wsZones.getColumn(10 + maxLen).width = 8;

      // ============================================================
      // SAYFA 4: TASARIM KURALLARI (GERÇEK VERİDEN)
      // ============================================================
      const wsRules = workbook.addWorksheet('Tasarım Kuralları', { views: [{ showGridLines: false }] });

      addSheetTitle(wsRules, 'TUSAŞ TASARIM KURALLARI UYUMLULUK RAPORU', 'F');
      wsRules.addRow([]);

      const fullRuleDesc = {
        R1: ['R1 — Simetri',         'Laminat orta düzlem etrafında simetrik olmalı.',                          '18.0'],
        R2: ['R2 — Denge',           '+45° ve -45° kat sayıları eşit olmalı (kuplaj direnci için).',            '12.0'],
        R3: ['R3 — Yüzde Kuralı',    'Her yönelim açısı toplam katların %8–67\'si arasında olmalı.',           '13.0'],
        R4: ['R4 — Dış Katmanlar',   'İlk ve son 2 kat ±45° olmalı (darbe dayanımı için).',                    '12.0'],
        R5: ['R5 — Dağılım',         'Aynı açıdaki katlar dizilim boyunca eşit aralıklı dağıtılmalı.',         '14.0'],
        R6: ['R6 — Gruplandırma',    'Aynı yönelimden ardışık maksimum 3 kat olabilir.',                        '20.5'],
        R7: ['R7 — Burkulma',        '±45° katlar merkez düzlemden uzakta konumlanmalı.',                       '3.5'],
        R8: ['R8 — Yanal Eğilme',    '90° katlar merkez düzlemden uzakta konumlanmalı.',                        '7.0'],
      };

      const ruleColHdr = ['Kural ID', 'Açıklama', 'Max Puan'];
      sortedZones.forEach(z => {
        const label = 'Z' + (z.index + 1) + (z.is_root ? '(R)' : '');
        ruleColHdr.push(label + ' Skor');
        ruleColHdr.push(label + ' Durum');
      });
      const ruleHdrRow = wsRules.addRow(ruleColHdr);
      ruleHdrRow.height = 24;
      ruleHdrRow.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      ['R1','R2','R3','R4','R5','R6','R7','R8'].forEach(rKey => {
        const [shortName, desc, maxPts] = fullRuleDesc[rKey];
        const rowData = [rKey, desc, maxPts];
        sortedZones.forEach(zone => {
          const rData = (zone.penalties || {})[rKey];
          if (rData && typeof rData === 'object') {
            rowData.push(Number(rData.score).toFixed(2) + ' / ' + Number(rData.weight).toFixed(1));
            rowData.push('');
          } else {
            rowData.push('-'); rowData.push('-');
          }
        });
        const r = wsRules.addRow(rowData);
        r.height = 20;
        r.getCell(1).font = S.labelFont; r.getCell(1).alignment = S.centerAlign; r.getCell(1).border = S.border;
        r.getCell(2).font = S.valueFont; r.getCell(2).alignment = S.wrapAlign; r.getCell(2).border = S.border;
        r.getCell(3).font = { name: 'Calibri', size: 10, bold: true }; r.getCell(3).alignment = S.centerAlign; r.getCell(3).border = S.border;
        sortedZones.forEach((zone, zi) => {
          const sc = 4 + zi * 2;
          const st = 5 + zi * 2;
          r.getCell(sc).font = { name: 'Calibri', size: 10 }; r.getCell(sc).alignment = S.centerAlign; r.getCell(sc).border = S.border;
          const rData = (zone.penalties || {})[rKey];
          if (rData && typeof rData === 'object') {
            applyRuleStatus(r.getCell(st), Number(rData.score), Number(rData.weight));
          } else {
            r.getCell(st).value = '-'; r.getCell(st).border = S.border; r.getCell(st).alignment = S.centerAlign;
          }
        });
      });

      wsRules.addRow([]);

      // Zone bazında özet
      addSectionHeader(wsRules, 'ZONE BAZINDA UYUM ÖZETİ', 'G');
      const zsHdr = wsRules.addRow(['Zone', 'Toplam Skor', 'Fitness (%)', 'UYGUN', 'UYARI', 'AYKIRI', 'Genel Durum']);
      zsHdr.height = 22;
      zsHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });
      sortedZones.forEach(zone => {
        const penalties = zone.penalties || {};
        let passC = 0, warnC = 0, failC = 0;
        ['R1','R2','R3','R4','R5','R6','R7','R8'].forEach(rKey => {
          const rd = penalties[rKey];
          if (rd && typeof rd === 'object') {
            const pen = Number(rd.penalty) || 0;
            const ratio = Number(rd.weight) > 0 ? Number(rd.score) / Number(rd.weight) : 1;
            if (pen <= 0.001) passC++;
            else if (ratio >= 0.8) warnC++;
            else failC++;
          }
        });
        const fn = typeof zone.fitness === 'number' ? zone.fitness.toFixed(2) : '-';
        const r = wsRules.addRow(['Zone ' + (zone.index + 1) + (zone.is_root ? ' (Root)' : ''), fn, (parseFloat(fn) || 0).toFixed(1) + '%', passC, warnC, failC, '']);
        r.height = 18;
        r.eachCell((c, i) => { c.border = S.border; c.alignment = S.centerAlign; c.font = S.valueFont; });
        const sc = r.getCell(7);
        if (failC > 0)      { sc.value = '✗ AYKIRI'; sc.fill = S.failFill; sc.font = S.failFont; }
        else if (warnC > 0) { sc.value = '⚠ UYARI';  sc.fill = S.warnFill; sc.font = S.warnFont; }
        else                { sc.value = '✓ UYGUN';   sc.fill = S.passFill; sc.font = S.passFont; }
      });

      wsRules.addRow([]);

      // Penalty ihlal detayları
      addSectionHeader(wsRules, 'KURAL İHLAL DETAYLARI', 'F');
      const detHdr = wsRules.addRow(['Zone', 'Kural', 'Kazanılan', 'Max Puan', 'Kayıp Puan', 'Açıklama']);
      detHdr.height = 22;
      detHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });
      let hasViolation = false;
      sortedZones.forEach(zone => {
        ['R1','R2','R3','R4','R5','R6','R7','R8'].forEach(rKey => {
          const rd = (zone.penalties || {})[rKey];
          if (rd && typeof rd === 'object' && (Number(rd.penalty) || 0) > 0.001) {
            hasViolation = true;
            const reasonText = rd.reason || 'Kural ihlali tespit edildi.';
            const r = wsRules.addRow([
              'Zone ' + (zone.index + 1) + (zone.is_root ? ' (Root)' : ''),
              rKey,
              Number(rd.score).toFixed(2),
              Number(rd.weight).toFixed(1),
              Number(rd.penalty).toFixed(2),
              reasonText,
            ]);
            // Satır yüksekliğini metin uzunluğuna göre ayarla (her ~45 karakter = 1 satır ≈ 16px)
            const lineCount = Math.ceil(reasonText.length / 45);
            r.height = Math.max(22, lineCount * 16 + 8);
            r.eachCell((c, i) => {
              c.border = S.border;
              c.font = S.valueFont;
              if (i === 6) {
                c.alignment = { vertical: 'middle', horizontal: 'left', wrapText: true };
              } else {
                c.alignment = S.centerAlign;
              }
            });
            r.getCell(5).fill = S.failFill; r.getCell(5).font = S.failFont;
          }
        });
      });
      if (!hasViolation) {
        const nr = wsRules.addRow(['Tüm zone ve kurallarda ihlal sıfır. Laminat tasarım kurallarına tam uyumlu.']);
        wsRules.mergeCells('A' + wsRules.rowCount + ':F' + wsRules.rowCount);
        nr.height = 22; nr.getCell(1).fill = S.passFill; nr.getCell(1).font = S.passFont; nr.getCell(1).alignment = S.centerAlign;
      }

      wsRules.getColumn(1).width = 18; wsRules.getColumn(2).width = 52; wsRules.getColumn(3).width = 12;
      wsRules.getColumn(4).width = 12; wsRules.getColumn(5).width = 12; wsRules.getColumn(6).width = 48;
      sortedZones.forEach((_, i) => { wsRules.getColumn(4 + i * 2).width = 14; wsRules.getColumn(5 + i * 2).width = 12; });

      // ============================================================
      // SAYFA 5: DROP-OFF GEÇİŞ TABLOSU
      // ============================================================
      const wsDropoff = workbook.addWorksheet('Drop-off Geçişleri', { views: [{ showGridLines: false }] });
      wsDropoff.getColumn('A').width = 14;  // Seviye
      wsDropoff.getColumn('B').width = 40;  // Zone (girinti için geniş)
      wsDropoff.getColumn('C').width = 13;  // Kat Sayısı
      wsDropoff.getColumn('D').width = 18;  // Ebeveyn Zone
      wsDropoff.getColumn('E').width = 22;  // Geçiş Tipi
      wsDropoff.getColumn('F').width = 12;  // Kat Farkı
      wsDropoff.getColumn('G').width = 36;  // Bağlantılı Zone'lar
      wsDropoff.getColumn('H').width = 14;  // Fitness
      wsDropoff.getColumn('I').width = 44;  // Not

      addSheetTitle(wsDropoff, 'KAT GEÇİŞ VE SEYRELTME TABLOSU', 'I');
      wsDropoff.addRow([]);

      addSectionHeader(wsDropoff, 'GEÇİŞ ZİNCİRİ (KOMŞULUK BAZLI)', 'I');

      // Transitions verisinden gerçek ebeveyn-çocuk ağacını oluştur
      const chainZoneByIdx = new Map();
      sortedZones.forEach(z => chainZoneByIdx.set(z.index, z));

      // Her zone'un ebeveynini bul (transitions.to → transitions.from)
      const parentOf = new Map(); // childIndex → parentIndex
      const childrenOf = new Map(); // parentIndex → [childIndex, ...]
      (transitions || []).forEach(tr => {
        if (!tr) return;
        const fromIdx = Array.isArray(tr.from) ? tr.from[0] : tr.from;
        const toIdx = tr.to;
        parentOf.set(toIdx, fromIdx);
        if (!childrenOf.has(fromIdx)) childrenOf.set(fromIdx, []);
        childrenOf.get(fromIdx).push(toIdx);
      });

      // Kök zone'u bul (parentı olmayan)
      const treeRoot = sortedZones.find(z => !parentOf.has(z.index)) || rootZone;

      // DFS ile ağacı satır satır yaz (girinti ile)
      const chainHeaderRow = wsDropoff.addRow(['Girinti Seviyesi', 'Zone', 'Kat Sayısı', 'Ebeveyn Zone', 'Geçiş Tipi', 'Kat Farkı', 'Bağlantılı Zone\'lar', 'Fitness', 'Not']);
      chainHeaderRow.height = 22;
      chainHeaderRow.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      function writeTreeNode(zoneIdx, depth) {
        const z = chainZoneByIdx.get(zoneIdx);
        if (!z) return;
        const indent = '\u00a0\u00a0\u00a0\u00a0'.repeat(depth); // non-breaking spaces for indent
        const prefix = depth === 0 ? '\u25a0 ' : ('\u2514\u2500 '); // ■ for root, └─ for children
        const zLabel = indent + prefix + 'Zone ' + (z.index + 1) + (z.is_root ? ' (Root)' : '');

        const parentIdx = parentOf.get(zoneIdx);
        const parentZ = parentIdx !== undefined ? chainZoneByIdx.get(parentIdx) : null;
        const parentLabel = parentZ ? 'Zone ' + (parentZ.index + 1) + (parentZ.is_root ? ' (Root)' : '') : '—';

        // Bu node'a ait transition'ı bul
        const tr = (transitions || []).find(t => t && t.to === zoneIdx);
        const typeMap = { drop_off: 'Drop-off', angle_drop_off: 'Açı Bazlı Drop-off', merge: 'Birleştirme' };
        const trType = tr ? (typeMap[tr.type] || tr.type || '—') : (depth === 0 ? 'Kök Zone' : '—');
        const katFark = parentZ ? (parentZ.ply_count - z.ply_count) : '—';

        // Bağlantılı zone'ları bul (çocuklar + ebeveyn)
        const linkedParts = [];
        if (parentZ) linkedParts.push('\u2191 Zone ' + (parentZ.index + 1) + ' (' + parentZ.ply_count + ' kat)');
        const myChildren = childrenOf.get(zoneIdx) || [];
        myChildren.forEach(cIdx => {
          const cZ = chainZoneByIdx.get(cIdx);
          if (cZ) linkedParts.push('\u2193 Zone ' + (cZ.index + 1) + ' (' + cZ.ply_count + ' kat)');
        });
        const linkedStr = linkedParts.length > 0 ? linkedParts.join(', ') : '—';

        // Fitness skoru
        const fitnessStr = (z.fitness !== undefined && z.fitness !== null) ? z.fitness.toFixed(1) + ' / 100' : '—';

        // Detaylı not
        let note = '';
        if (depth === 0) {
          note = 'Master sequence — tüm zone\'ların tabanı (' + z.ply_count + ' kat)';
        } else if (katFark !== '—') {
          const droppedAngles = tr && tr.dropped_indices ? tr.dropped_indices.length : katFark;
          note = '-' + katFark + ' kat seyreltildi';
          if (tr && tr.dropped_indices && tr.dropped_indices.length > 0) {
            note += ' (pozisyon: ' + (tr.dropped_indices.length <= 6 ? tr.dropped_indices.join(', ') : tr.dropped_indices.slice(0, 6).join(', ') + '...') + ')';
          }
        }

        const r = wsDropoff.addRow([depth, zLabel, z.ply_count, parentLabel, trType, katFark !== '—' ? '-' + katFark : '—', linkedStr, fitnessStr, note]);
        r.height = 22;
        r.eachCell((c, i) => { c.border = S.border; c.font = S.valueFont; c.alignment = i === 2 || i === 7 || i === 9 ? S.leftAlign : S.centerAlign; });

        // Kök koyu mavi arka plan + beyaz/koyu mavi font
        if (depth === 0) {
          r.getCell(2).font = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FF1E3A8A' } };
          r.getCell(2).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
          r.getCell(3).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
          r.getCell(3).font = { name: 'Calibri', size: 10, bold: true, color: { argb: 'FF1E3A8A' } };
          r.getCell(8).fill = S.passFill; r.getCell(8).font = S.passFont;
        } else {
          // Derinliğe göre kademeli mavi tonlama (doğru ARGB formatı)
          const rVal = Math.max(0xEF - depth * 0x12, 0xB0);
          const gVal = Math.max(0xF6 - depth * 0x10, 0xC0);
          const rHex = rVal.toString(16).padStart(2, '0').toUpperCase();
          const gHex = gVal.toString(16).padStart(2, '0').toUpperCase();
          const bgColor = 'FF' + rHex + gHex + 'FF';
          r.getCell(2).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: bgColor } };
          r.getCell(2).font = { name: 'Calibri', size: 10, bold: false, color: { argb: 'FF1E3A8A' } };
          r.getCell(6).fill = S.failFill; r.getCell(6).font = S.failFont;
          // Fitness hücresini renklendir
          const fVal = z.fitness || 0;
          if (fVal >= 80) { r.getCell(8).fill = S.passFill; r.getCell(8).font = S.passFont; }
          else if (fVal >= 60) { r.getCell(8).fill = S.warnFill; r.getCell(8).font = S.warnFont; }
          else { r.getCell(8).fill = S.failFill; r.getCell(8).font = S.failFont; }
        }
        // Bağlantılı zone'lar hücresine hafif vurgu
        r.getCell(7).font = { name: 'Calibri', size: 9, color: { argb: 'FF374151' } };
        r.getCell(7).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF9FAFB' } };

        // Alt zone'ları işle
        const treeChildren = childrenOf.get(zoneIdx) || [];
        treeChildren.forEach(childIdx => writeTreeNode(childIdx, depth + 1));
      }

      if (treeRoot) {
        writeTreeNode(treeRoot.index, 0);
      } else {
        const noTree = wsDropoff.addRow(['Ağaç yapısı oluşturulamadı — transition verisi eksik.']);
        wsDropoff.mergeCells('A' + wsDropoff.rowCount + ':I' + wsDropoff.rowCount);
        noTree.height = 20; noTree.getCell(1).alignment = S.centerAlign;
      }

      wsDropoff.addRow([]);

      // ---- BAĞLANTILI ZONE DETAY TABLOSU ----
      addSectionHeader(wsDropoff, 'BAĞLANTILI ZONE HARİTASI', 'I');
      const linkHdr = wsDropoff.addRow(['Zone', 'Kat Sayısı', 'Ebeveyn', 'Çocuk Zone\'lar', 'Toplam Bağlantı', 'Yön (Ebeveyn→Çocuk)', 'Kat Farkları', 'Fitness', 'Durum']);
      linkHdr.height = 22;
      linkHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      sortedZones.forEach(z => {
        const zIdx = z.index;
        const pIdx = parentOf.get(zIdx);
        const pZ = pIdx !== undefined ? chainZoneByIdx.get(pIdx) : null;
        const parentName = pZ ? 'Zone ' + (pZ.index + 1) : '—';
        const myKids = childrenOf.get(zIdx) || [];
        const kidNames = myKids.map(cIdx => {
          const cZ = chainZoneByIdx.get(cIdx);
          return cZ ? 'Zone ' + (cZ.index + 1) + ' (' + cZ.ply_count + ' kat)' : 'Zone ?';
        });
        const kidStr = kidNames.length > 0 ? kidNames.join(', ') : '—';
        const totalLinks = (pZ ? 1 : 0) + myKids.length;
        const direction = pZ ? ('Zone ' + (pZ.index + 1) + ' \u2192 Zone ' + (z.index + 1) + (myKids.length > 0 ? ' \u2192 ' + myKids.map(c => 'Z' + (c + 1)).join(', ') : '')) : (myKids.length > 0 ? 'Zone ' + (z.index + 1) + ' \u2192 ' + myKids.map(c => 'Z' + (c + 1)).join(', ') : '—');
        const katDiffs = myKids.map(cIdx => {
          const cZ = chainZoneByIdx.get(cIdx);
          return cZ ? '-' + (z.ply_count - cZ.ply_count) : '?';
        });
        const katDiffStr = katDiffs.length > 0 ? katDiffs.join(', ') : '—';
        const fitnessStr = (z.fitness !== undefined && z.fitness !== null) ? z.fitness.toFixed(1) : '—';
        const isLeaf = myKids.length === 0 && pZ;
        const status = z.is_root ? 'Kök (Master)' : (isLeaf ? 'Yaprak Zone' : 'Ara Zone');

        const r = wsDropoff.addRow(['Zone ' + (z.index + 1), z.ply_count, parentName, kidStr, totalLinks, direction, katDiffStr, fitnessStr, status]);
        r.height = 20;
        r.eachCell((c, i) => { c.border = S.border; c.alignment = (i === 4 || i === 6 || i === 9) ? S.leftAlign : S.centerAlign; c.font = S.valueFont; });
        // Durum hücresi renklendirme
        if (z.is_root) { r.getCell(9).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFDBEAFE' } }; r.getCell(9).font = { name: 'Calibri', size: 10, bold: true, color: { argb: 'FF1E40AF' } }; }
        else if (isLeaf) { r.getCell(9).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF0FDF4' } }; r.getCell(9).font = { name: 'Calibri', size: 10, color: { argb: 'FF166534' } }; }
        else { r.getCell(9).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFBEB' } }; r.getCell(9).font = { name: 'Calibri', size: 10, color: { argb: 'FF92400E' } }; }
        // Zone adı kalın
        r.getCell(1).font = { name: 'Calibri', size: 10, bold: true, color: { argb: 'FF1E3A8A' } };
      });

      wsDropoff.addRow([]);

      addSectionHeader(wsDropoff, 'GEÇİŞ DETAYLARI', 'I');
      const dropHdr = wsDropoff.addRow(['Kaynak Zone', 'Hedef Zone', 'Geçiş Tipi', 'Kaynak Kat', 'Hedef Kat', 'Atılan Kat', 'Kat Farkı %', 'Atılan Pozisyonlar (Kaynak İndeks)', 'Açıklama']);
      dropHdr.height = 22;
      dropHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      if (transitions && transitions.length > 0) {
        const zByIdx = new Map();
        sortedZones.forEach(z => zByIdx.set(z.index, z));
        transitions.forEach(tr => {
          if (!tr) return;
          const fromIdx = Array.isArray(tr.from) ? tr.from[0] : tr.from;
          const fromZ = zByIdx.get(fromIdx);
          const toZ = zByIdx.get(tr.to);
          const fromName = fromZ ? 'Zone ' + (fromZ.index + 1) + (fromZ.is_root ? ' (Root)' : '') : 'Zone ?';
          const toName = toZ ? 'Zone ' + (toZ.index + 1) : 'Zone ?';
          const typeMap = { drop_off: 'Drop-off', angle_drop_off: 'Açı Bazlı Drop-off', merge: 'Birleştirme' };
          const typeName = typeMap[tr.type] || tr.type || 'Bilinmiyor';
          const dropped = tr.dropped_indices || [];
          const posStr = dropped.length > 14 ? dropped.slice(0, 14).join(', ') + ' ... (+' + (dropped.length - 14) + ' kat)' : (dropped.join(', ') || '-');
          const fromPly = fromZ ? fromZ.ply_count : 0;
          const toPly = toZ ? toZ.ply_count : 0;
          const diffPct = fromPly > 0 ? ((fromPly - toPly) / fromPly * 100).toFixed(1) + '%' : '—';
          const desc = 'Zone ' + (fromIdx + 1) + '→' + (tr.to + 1) + ': ' + dropped.length + ' kat atıldı (' + diffPct + ' seyreltme)';
          const r = wsDropoff.addRow([fromName, toName, typeName, fromZ ? fromZ.ply_count : '-', toZ ? toZ.ply_count : '-', dropped.length, diffPct, posStr, desc]);
          r.height = 22;
          r.eachCell((c, i) => { c.border = S.border; c.alignment = (i === 8 || i === 9) ? S.wrapAlign : S.centerAlign; c.font = S.valueFont; });
          r.getCell(6).fill = S.failFill; r.getCell(6).font = S.failFont;
          r.getCell(1).font = { name: 'Calibri', size: 10, bold: true, color: { argb: 'FF1E3A8A' } };
          r.getCell(2).font = { name: 'Calibri', size: 10, bold: true, color: { argb: 'FF7C3AED' } };
        });
      } else {
        const noTr = wsDropoff.addRow(['Geçiş verisi bulunamadı. Tek zone optimizasyonunda geçiş tablosu oluşturulmaz.']);
        wsDropoff.mergeCells('A' + wsDropoff.rowCount + ':I' + wsDropoff.rowCount);
        noTr.height = 22;
        noTr.getCell(1).font = { name: 'Calibri', size: 10, italic: true, color: { argb: 'FF6B7280' } };
        noTr.getCell(1).alignment = S.centerAlign;
      }

      // Ramp kontrolü
      const rampChecks = window._multiZoneRampChecks || [];
      if (rampChecks && rampChecks.length > 0) {
        wsDropoff.addRow([]);
        addSectionHeader(wsDropoff, 'RAMP (EĞİM) KISIT KONTROLÜ', 'I');
        const rampHdr = wsDropoff.addRow(['Zone A', 'Zone B', 'Kat Farkı', 'Gereken Ramp (mm)', 'Mevcut (mm)', 'Sonuç', 'Not']);
        rampHdr.height = 22;
        rampHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });
        rampChecks.forEach(rc => {
          const ok = rc.feasible !== false;
          const r = wsDropoff.addRow(['Zone ' + (rc.zone_a + 1), 'Zone ' + (rc.zone_b + 1), rc.ply_diff || '-', rc.required_ramp_mm || '-', rc.available_mm || '-', ok ? '✓ UYGUN' : '✗ AŞILDI', ok ? '' : 'Ramp kısıtı ihlal edildi!']);
          r.height = 18;
          r.eachCell((c, i) => { c.border = S.border; c.alignment = S.centerAlign; c.font = S.valueFont; });
          r.getCell(6).fill = ok ? S.passFill : S.failFill;
          r.getCell(6).font = ok ? S.passFont : S.failFont;
        });
      }

      // ============================================================
      // SAYFA 6: ÜRETİM TALİMATLARI
      // ============================================================
      const wsMfg = workbook.addWorksheet('Üretim Talimatları', { views: [{ showGridLines: false }] });
      wsMfg.getColumn('A').width = 32; wsMfg.getColumn('B').width = 28;
      wsMfg.getColumn('C').width = 16; wsMfg.getColumn('D').width = 40;

      addSheetTitle(wsMfg, 'ÜRETİM TALİMATLARI (KILAVUZ)', 'D');
      const mfgNote = wsMfg.addRow(['\u26a0 BU SAYFA YALNIZCA KILAVUZ NİTELİĞİNDEDİR. Resmi üretim belgesi olarak kullanılamaz. Onaylı mühendislik çizimlerine başvurunuz.']);
      wsMfg.mergeCells('A' + wsMfg.rowCount + ':D' + wsMfg.rowCount);
      mfgNote.height = 30;
      mfgNote.getCell(1).font = { name: 'Calibri', size: 9, italic: true, color: { argb: 'FF92400E' } };
      mfgNote.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFEF3C7' } };
      mfgNote.getCell(1).alignment = S.wrapAlign;
      wsMfg.addRow([]);

      addSectionHeader(wsMfg, '1. MALZEME ÖZELLİKLERİ', 'D');
      [
        ['Malzeme Tipi:', 'Karbon Fiber / Epoksi Prepreg (CFRP)'],
        ['Spesifikasyon:', 'AS4/8552 veya TAI onaylı eşdeğeri'],
        ['Kat Kalınlığı (Nominal):', '0,125 mm'],
        ['Lif Alan Ağırlığı:', '145 g/m\u00b2'],
        ['Reçine İçeriği:', '%33 \u00b12'],
        ['Yoğunluk:', '1,58 g/cm\u00b3'],
        ['Depolama Sıcaklığı:', '-18\u00b0C veya altı'],
        ['Raf Ömrü:', 'Malzeme sertifikasına göre'],
      ].forEach(([l, v]) => {
        const r = wsMfg.addRow([l, v]);
        r.height = 18;
        r.getCell(1).font = S.labelFont; r.getCell(1).border = S.border; r.getCell(1).alignment = S.leftAlign;
        r.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
        r.getCell(2).font = S.valueFont; r.getCell(2).border = S.border; r.getCell(2).alignment = S.leftAlign;
      });
      wsMfg.addRow([]);

      addSectionHeader(wsMfg, '2. YIĞILIM SIRASI (KALIP YÜZEYINDEN BAŞLA — ROOT ZONE)', 'D');
      const layupHdr = wsMfg.addRow(['Kat No', 'Açı', 'Kat Tipi', 'Kümülatif Kalınlık (mm)']);
      layupHdr.height = 20;
      layupHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });
      rootSeq.forEach((angle, i) => {
        const r = wsMfg.addRow([i + 1, angle + '\u00b0', 'Prepreg CFRP', ((i + 1) * 0.125).toFixed(3)]);
        r.height = 15;
        r.getCell(1).border = S.border; r.getCell(1).alignment = S.centerAlign; r.getCell(1).font = S.valueFont;
        const ac = r.getCell(2);
        ac.border = S.border; ac.alignment = S.centerAlign;
        if (angle === 0)    { ac.fill = S.ply0Fill;   ac.font = S.ply0Font; }
        else if (angle === 90)  { ac.fill = S.ply90Fill;  ac.font = S.ply90Font; }
        else if (angle === 45)  { ac.fill = S.ply45Fill;  ac.font = S.ply45Font; }
        else                    { ac.fill = S.plyM45Fill; ac.font = S.plyM45Font; }
        r.getCell(3).border = S.border; r.getCell(3).alignment = S.leftAlign; r.getCell(3).font = S.valueFont;
        r.getCell(4).border = S.border; r.getCell(4).alignment = S.centerAlign; r.getCell(4).font = S.valueFont;
      });
      wsMfg.addRow([]);

      addSectionHeader(wsMfg, '3. KÜRLEME ÇEVRİMİ (REFERATİF)', 'D');
      [
        ['Vakum Basıncı:', '1 bar (tam vakum)'],
        ['Otoklav Basıncı:', '6 bar'],
        ['Kürleme Sıcaklığı:', '180\u00b0C'],
        ['Bekleme Süresi:', '120 dakika'],
        ['Isıtma Hızı:', '2\u00b0C/dak'],
        ['Soğutma Hızı:', 'Maks. 3\u00b0C/dak'],
      ].forEach(([l, v]) => {
        const r = wsMfg.addRow([l, v]);
        r.height = 18;
        r.getCell(1).font = S.labelFont; r.getCell(1).border = S.border; r.getCell(1).alignment = S.leftAlign;
        r.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
        r.getCell(2).font = S.valueFont; r.getCell(2).border = S.border; r.getCell(2).alignment = S.leftAlign;
      });
      wsMfg.addRow([]);

      addSectionHeader(wsMfg, '4. KALİTE KONTROL GEREKSİNİMLERİ', 'D');
      const qcHdr = wsMfg.addRow(['Kontrol', 'Yöntem / Kriter', '', '']);
      qcHdr.height = 20;
      qcHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });
      [
        ['Görsel Muayene',          'Kırışık, boşluk veya kuru alan olmamalı'],
        ['Ultrasonik Muayene',      'C-tarama: boşluk ve ayrılma kontrolü'],
        ['Kalınlık Doğrulaması',    '\u00b10,2 mm tolerans'],
        ['Fiber Yönelimi',          'Kat başına \u00b15\u00b0 tolerans'],
        ['Ağırlık Kontrolü',        'Tasarım ağırlığının \u00b13% dahilinde'],
      ].forEach(([l, v]) => {
        const r = wsMfg.addRow([l, v]);
        r.height = 18;
        r.getCell(1).font = S.labelFont; r.getCell(1).border = S.border; r.getCell(1).alignment = S.leftAlign;
        r.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };
        r.getCell(2).font = S.valueFont; r.getCell(2).border = S.border; r.getCell(2).alignment = S.leftAlign;
      });

      // ============================================================
      // SAYFA 7: MALZEME ÖZELLİKLERİ
      // ============================================================
      const wsMat = workbook.addWorksheet('Malzeme Özellikleri', { views: [{ showGridLines: false }] });
      wsMat.getColumn('A').width = 42; wsMat.getColumn('B').width = 18;
      wsMat.getColumn('C').width = 14; wsMat.getColumn('D').width = 24;

      addSheetTitle(wsMat, 'MALZEME ÖZELLİKLERİ VERİTABANI', 'D');
      wsMat.addRow([]);

      const matHdr = wsMat.addRow(['Özellik', 'Değer', 'Birim', 'Test Standardı']);
      matHdr.height = 22;
      matHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      [
        ['Çekme Dayanımı (0\u00b0)',               '2280',  'MPa',    'ASTM D3039'],
        ['Çekme Modülü (0\u00b0)',                 '135',   'GPa',    'ASTM D3039'],
        ['Basma Dayanımı (0\u00b0)',               '1440',  'MPa',    'ASTM D6641'],
        ['Basma Modülü (0\u00b0)',                 '130',   'GPa',    'ASTM D6641'],
        ['Düzlem İçi Kayma Dayanımı',              '95',    'MPa',    'ASTM D3518'],
        ['Düzlem İçi Kayma Modülü',                '5,5',   'GPa',    'ASTM D3518'],
        ['Katmanlar Arası Kayma Dayanımı (ILSS)',  '140',   'MPa',    'ASTM D2344'],
        ['Poisson Oranı (\u03bd\u2081\u2082)',     '0,33',  '\u2014', 'ASTM D3039'],
        ['Yoğunluk',                               '1,58',  'g/cm\u00b3', 'ASTM D792'],
        ['Camsı Geçiş Sıcaklığı (Tg)',            '210',   '\u00b0C','ASTM D7028'],
        ['Nominal Kat Kalınlığı',                  '0,125', 'mm',     'Ölçüm'],
        ['Lif Hacim Oranı (Vf)',                   '60',    '%',      'Hesaplama'],
      ].forEach(([prop, val, unit, std]) => {
        const r = wsMat.addRow([prop, val, unit, std]);
        r.height = 18;
        r.eachCell(c => { c.border = S.border; c.alignment = S.leftAlign; c.font = S.valueFont; });
      });
      wsMat.addRow([]);

      addSectionHeader(wsMat, 'UYGULANABILIR STANDARTLAR VE REFERANSLAR', 'D');
      const stdHdr = wsMat.addRow(['Standart', 'Durum', 'Not', '']);
      stdHdr.height = 20;
      stdHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });
      [
        ['MIL-HDBK-17 (Kompozit Malzeme El Kitabı)',   'REFERANS',      'Temel tasarım rehberi'],
        ['ASTM Test Standartları (D3039 vb.)',          'REFERANS',      'Malzeme karakterizasyonu'],
        ['FAA AC 20-107B',                             'REFERANS',      'Havacılık sertifikasyon rehberi'],
        ['TAI-MAT-XXXXX',                              'TAI İÇ STANDART','Kullanılan malzeme spesifikasyonuna göre doldurulacak'],
        ['TAI-ENG-COMP-XXX',                           'TAI İÇ STANDART','Kompozit mühendislik prosedürü'],
      ].forEach(([std, status, note]) => {
        const r = wsMat.addRow([std, status, note, '']);
        r.height = 18;
        r.getCell(1).border = S.border; r.getCell(1).alignment = S.leftAlign; r.getCell(1).font = S.valueFont;
        r.getCell(2).border = S.border; r.getCell(2).alignment = S.centerAlign;
        if (status === 'REFERANS') { r.getCell(2).fill = S.passFill; r.getCell(2).font = S.passFont; }
        else { r.getCell(2).fill = S.warnFill; r.getCell(2).font = S.warnFont; }
        r.getCell(3).border = S.border; r.getCell(3).alignment = S.leftAlign;
        r.getCell(3).font = { name: 'Calibri', size: 9, italic: true, color: { argb: 'FF6B7280' } };
      });

      // ============================================================
      // SAYFA 8: REVİZYON GEÇMİŞİ
      // ============================================================
      const wsRev = workbook.addWorksheet('Revizyon Geçmişi', { views: [{ showGridLines: false }] });
      wsRev.getColumn('A').width = 10; wsRev.getColumn('B').width = 16;
      wsRev.getColumn('C').width = 52; wsRev.getColumn('D').width = 24; wsRev.getColumn('E').width = 24;

      addSheetTitle(wsRev, 'REVİZYON GEÇMİŞİ', 'E');
      wsRev.addRow([]);

      const revHdr = wsRev.addRow(['Rev', 'Tarih', 'Değişiklik Açıklaması', 'Hazırlayan', 'Onaylayan']);
      revHdr.height = 22;
      revHdr.eachCell(c => { c.fill = S.headerFill; c.font = S.headerFont; c.alignment = S.centerAlign; c.border = S.border; });

      const revA = wsRev.addRow(['A', todayStr, 'İlk Yayın — TUSAŞ Laminat Optimizasyon Yazılımı tarafından otomatik oluşturuldu.', '', '']);
      revA.height = 20;
      revA.eachCell(c => { c.border = S.border; c.alignment = S.leftAlign; c.font = S.valueFont; });
      revA.getCell(1).font = S.labelFont; revA.getCell(1).alignment = S.centerAlign;
      revA.getCell(3).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFF6FF' } };

      for (let i = 0; i < 8; i++) {
        const r = wsRev.addRow(['', '', '', '', '']);
        r.height = 22;
        r.eachCell(c => { c.border = S.border; });
      }

      // ===== İNDİR =====
      const buffer = await workbook.xlsx.writeBuffer();
      const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'TAI_COMP_OPT_RevA_' + todayISO + '.xlsx';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }


    // ==================== EXPORT PNG ====================
    function exportPNG() {
      if (!renderer) return;
      renderer.render(scene, camera);
      const url = renderer.domElement.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'composite_panel_3d.png';
      a.click();
    }

    // ==================== TEXT SPRITE ====================
    function createTextSprite(text, isRoot = false, isSmall = false) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 128;
      ctx.clearRect(0, 0, 512, 128);

      if (p3LightMode) {
        // === AÇIK TEMA — Mühendislik CAD stili (beyaz kutu, koyu lacivert çerçeve) ===
        // Arka plan
        ctx.fillStyle = isRoot ? 'rgba(255,255,255,0.97)' : 'rgba(248,250,252,0.95)';
        ctx.beginPath();
        ctx.roundRect(4, 4, 504, 120, 8);
        ctx.fill();
        // Çerçeve
        ctx.strokeStyle = isRoot ? '#1e3a8a' : '#475569';
        ctx.lineWidth = isRoot ? 5 : 3;
        ctx.beginPath();
        ctx.roundRect(4, 4, 504, 120, 8);
        ctx.stroke();
        // Sol renk bandı (TUSAŞ kimlik şeridi)
        ctx.fillStyle = isRoot ? '#1e3a8a' : '#64748b';
        ctx.beginPath();
        ctx.roundRect(4, 4, 14, 120, [8, 0, 0, 8]);
        ctx.fill();
        // Metin
        const fs = isSmall ? 26 : 30;
        ctx.font = `700 ${fs}px "Courier New", monospace`;
        ctx.fillStyle = isRoot ? '#1e3a8a' : '#1e293b';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 264, 64);
      } else {
        // === KOYU TEMA (orijinal) ===
        ctx.fillStyle = isRoot ? 'rgba(29, 78, 216, 0.9)' : 'rgba(30, 41, 59, 0.85)';
        ctx.beginPath();
        ctx.roundRect(4, 4, 504, 120, 10);
        ctx.fill();
        const fs = isSmall ? 26 : 32;
        ctx.font = `600 ${fs}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 256, 64);
      }

      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false }));
    }

    // ==================== LEGEND ====================
    function buildLegend(container) {
      if (!container) return;
      container.innerHTML = '';
      [
        { label: '0°', color: ANGLE_HEX['0'] },
        { label: '90°', color: ANGLE_HEX['90'] },
        { label: '+45°', color: ANGLE_HEX['45'] },
        { label: '-45°', color: ANGLE_HEX['-45'] },
      ].forEach(({ label, color }) => {
        const s = document.createElement('span');
        s.className = 'flex items-center gap-1';
        s.innerHTML = `<span class="w-3 h-3 rounded-sm inline-block" style="background:${color}"></span><span class="text-slate-700 font-medium">${label}</span>`;
        container.appendChild(s);
      });
    }

    // =====================================================================
    // ==================== PANEL 3D — ZONE MAP VIEW ====================
    // =====================================================================
    let p3Renderer, p3Camera, p3Scene, p3Controls, p3Container, p3TooltipEl;
    let p3ZoneGroup = null;
    let p3ZoneMeshes = [];  // {mesh, edges, zone, boundInfo}
    let p3Raycaster = new THREE.Raycaster();
    let p3Mouse = new THREE.Vector2();
    let p3Highlighted = null;
    let p3Rendering = false;
    let p3Wireframe = false;
    let p3WingMode = false;
    let p3LightMode = false;  // Açık/Koyu tema kontrolü
    let p3GridObj = null;     // Grid referansı (tema geçişi için)
    let p3ZonesData = null;
    let p3BoundsData = null;

    // ==================== WING GEOMETRY MATH ====================
    // Maps normalized Panel U,V (0..1) to Wing 3D Coordinates
    // U = Spanwise (0=Root, 1=Tip)
    // V = Chordwise (0=Leading Edge, 1=Trailing Edge)
    // ==================== TUSAŞ STANDARD WING GEOMETRY ====================
    // NACA 64-412: Modern transonic airfoil
    // Parameters optimized for F-16 style fighter aircraft
    function mapToWing(u, v) {
      // TUSAŞ F-16 Inspired Parameters
      const SPAN = 45;              // 45m wing span (scaled)
      const ROOT_CHORD = 18;        // 18m root chord
      const TAPER_RATIO = 0.22;     // Tip/Root ratio (realistic fighter)
      const SWEEP_ANGLE_DEG = 40;   // Leading edge sweep
      const DIHEDRAL_DEG = 0;       // Flat (modern fighter style)
      const TWIST_DEG = -3;         // Washout for stall control
      const THICKNESS_RATIO = 0.12; // 12% thickness (NACA 64-412)
      const CAMBER = 0.04;          // 4% camber for lift
      const CAMBER_POS = 0.4;       // Camber position at 40% chord

      // Span position (u: 0=root, 1=tip)
      const x_span = (u - 0.5) * SPAN;

      // Local chord length at this span position
      const chord = ROOT_CHORD * (1 - u * (1 - TAPER_RATIO));

      // Leading edge sweep offset
      const sweep_rad = SWEEP_ANGLE_DEG * Math.PI / 180;
      const le_offset = Math.abs(u * SPAN * Math.tan(sweep_rad));

      // Chordwise position (v: 0=LE, 1=TE)
      const v_clamped = Math.max(0, Math.min(1, v));

      // NACA 64-series thickness distribution (more efficient than 4-digit)
      // Optimized for transonic flow
      const x_c = v_clamped; // Normalized chord position
      let yt;

      if (x_c < 1.0) {
        // NACA 6-series approximation (smoother, less drag)
        yt = 5 * THICKNESS_RATIO * (
          0.2969 * Math.sqrt(x_c) -
          0.1260 * x_c -
          0.3516 * Math.pow(x_c, 2) +
          0.2843 * Math.pow(x_c, 3) -
          0.1036 * Math.pow(x_c, 4)  // Modified coefficient for 6-series
        );
      } else {
        yt = 0;
      }

      // Camber line (NACA 4-digit camber)
      let yc;
      const p = CAMBER_POS; // Position of maximum camber
      const m = CAMBER;     // Maximum camber

      if (x_c < p) {
        yc = m * (2 * p * x_c - Math.pow(x_c, 2)) / Math.pow(p, 2);
      } else {
        yc = m * ((1 - 2 * p) + 2 * p * x_c - Math.pow(x_c, 2)) / Math.pow(1 - p, 2);
      }

      // Upper surface (composite panel on top)
      const y_airfoil = chord * (yc + yt);

      // Dihedral (0° for F-16 style)
      const y_dihedral = Math.abs(x_span) * Math.tan(DIHEDRAL_DEG * Math.PI / 180);

      // Twist (washout) - rotate around quarter-chord
      const twist_rad = u * TWIST_DEG * Math.PI / 180;
      const qc = 0.25 * chord; // Quarter chord point

      // Twist rotation (simplified)
      const x_rel = x_c * chord - qc;
      const y_twisted = y_airfoil * Math.cos(twist_rad) + x_rel * Math.sin(twist_rad);
      const z_twisted = (x_c - 0.5) * chord + x_rel * (1 - Math.cos(twist_rad));

      // Winglet (optional, for tip)
      let winglet_offset = 0;
      if (u > 0.88) { // Last 12% of span
        const tip_factor = (u - 0.88) / 0.12;
        winglet_offset = tip_factor * 2.5; // Upward curve
      }

      // Final position
      const x_final = x_span;
      const y_final = y_dihedral + y_twisted + winglet_offset + 0.5; // Lift from ground
      const z_final = le_offset + z_twisted;

      return new THREE.Vector3(x_final, y_final, z_final);
    }

    // Create segmented mesh for Wing Mode
    // bounds: {x, z, w, h} normalized 0..1 relative to panel size
    function createCurvedZoneMesh(effW_units, effD_units, effCx, effCz, color, fiberTex, fullWidth, fullDepth) {
      // Convert center/size BACK to 0..1 UV space for mapping
      // effCx, effCz are in World Units relative to Panel Center
      // Panel Size was PANEL_WORLD_SIZE x (ratio)
      const bounds = p3BoundsData || [];
      // We need global normalization logic. 
      // In updatePanel3D, we computed pxScale. We can reverse it.
      // Normalized U = (WorldX - MinX) / TotalWidth
      // But efficient way: Just use the passed eff parameters and know global size.

      // Re-use logic from updatePanel3D to normalize:
      // We'll pass 'uMin, uMax, vMin, vMax' to this function instead of world coords for better mapping.
    }


    // ==================== STATS OVERLAY UPDATE (PANEL 3D) ====================
    // ==================== STATS OVERLAY UPDATE (PANEL 3D) ====================
    function updatePanel3DStats(zones) {
      const overlay = document.getElementById('p3-stats-overlay');
      if (!overlay) return;
      if (!zones || !zones.length) { overlay.classList.add('hidden'); return; }
      overlay.classList.remove('hidden');
      const validZones = zones.filter(z => z && z.sequence && z.sequence.length > 0);
      const maxPly = Math.max(0, ...validZones.map(z => z.ply_count));
      const thickness = (maxPly * PLY_THICKNESS_MM).toFixed(2);

      const p3ZoneEl = document.querySelector('#p3-stats-zones .font-bold');
      if (p3ZoneEl) p3ZoneEl.textContent = validZones.length;

      const p3PlyEl = document.querySelector('#p3-stats-ply .font-bold');
      if (p3PlyEl) p3PlyEl.textContent = maxPly;

      const p3ThickEl = document.querySelector('#p3-stats-thick .font-bold');
      if (p3ThickEl) p3ThickEl.textContent = thickness + ' mm';
    }

    // ==================== REFERENCE WING GHOST ====================
    // ==================== TUSAŞ REFERENCE WING WITH LOD ====================
    // Level of Detail system for performance optimization
    function createReferenceWing(scene) {
      const lod = new THREE.LOD();

      // LOD Level 0: High Detail (close view, <20 units)
      const highGeo = createWingGeometry(60, 30);
      const highMat = createWingMaterial(0.15);
      const highMesh = new THREE.Mesh(highGeo, highMat);
      highMesh.castShadow = true;
      highMesh.receiveShadow = true;
      lod.addLevel(highMesh, 0);

      // LOD Level 1: Medium Detail (mid view, 20-40 units)
      const midGeo = createWingGeometry(30, 15);
      const midMat = createWingMaterial(0.12);
      const midMesh = new THREE.Mesh(midGeo, midMat);
      lod.addLevel(midMesh, 20);

      // LOD Level 2: Low Detail (far view, >40 units)
      const lowGeo = createWingGeometry(15, 8);
      const lowMat = createWingMaterial(0.1);
      const lowMesh = new THREE.Mesh(lowGeo, lowMat);
      lod.addLevel(lowMesh, 40);

      scene.add(lod);
      return lod;
    }

    // Helper: Create wing geometry with specified segments
    function createWingGeometry(segU, segV) {
      const geo = new THREE.PlaneGeometry(1, 1, segU, segV);
      const pos = geo.attributes.position;

      for (let i = 0; i < pos.count; i++) {
        const u = pos.getX(i) + 0.5;
        const v = 1 - (pos.getY(i) + 0.5);
        const p = mapToWing(u, v);
        pos.setXYZ(i, p.x, p.y, p.z);
      }
      geo.computeVertexNormals();
      return geo;
    }

    // Helper: Create TUSAŞ standard wing material
    function createWingMaterial(opacity) {
      const mat = new THREE.MeshStandardMaterial({
        color: 0x2c3e50,        // Carbon fiber gray
        roughness: 0.3,
        metalness: 0.7,
        transparent: true,
        opacity: opacity,
        side: THREE.DoubleSide,
        wireframe: false
      });
      return mat;
    }

    // Geometry cache for performance
    const p3GeometryCache = {};

    function getBoxGeometry(w, h, d) {
      const key = `box_${w.toFixed(3)}_${h.toFixed(3)}_${d.toFixed(3)}`;
      if (!p3GeometryCache[key]) {
        p3GeometryCache[key] = new THREE.BoxGeometry(w, h, d);
      }
      return p3GeometryCache[key];
    }

    function initPanel3D(container) {
      p3Container = container;
      p3TooltipEl = document.getElementById('panel3d-tooltip');

      p3Renderer = new THREE.WebGLRenderer({
        antialias: true,  // Enable antialiasing for smoother edges
        alpha: false,
        preserveDrawingBuffer: true,
        powerPreference: "high-performance"
      });
      p3Renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      p3Renderer.setSize(container.clientWidth, container.clientHeight);
      p3Renderer.setClearColor(TECH_BG_COLOR, 1);
      p3Renderer.shadowMap.enabled = true;
      p3Renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      p3Renderer.toneMapping = THREE.NoToneMapping;
      container.appendChild(p3Renderer.domElement);

      // Stats.js FPS Monitor
      if (typeof Stats !== 'undefined') {
        window.p3Stats = new Stats();
        window.p3Stats.showPanel(0); // 0: fps, 1: ms, 2: mb
        window.p3Stats.dom.style.position = 'absolute';
        window.p3Stats.dom.style.top = '10px';
        window.p3Stats.dom.style.left = '10px';
        window.p3Stats.dom.style.zIndex = '100';
        container.appendChild(window.p3Stats.dom);
      }

      p3Scene = new THREE.Scene();
      p3Scene.background = new THREE.Color(TECH_BG_COLOR);
      p3Scene.fog = new THREE.FogExp2(TECH_BG_COLOR, 0.02);

      // Tech Grid (referansı sakla — tema geçişinde yeniden oluşturulur)
      p3GridObj = new THREE.GridHelper(60, 60, GRID_COLOR_2, GRID_COLOR_1);
      p3GridObj.position.y = -0.005;
      p3Scene.add(p3GridObj);

      // Environment Map
      const envMap = createEnvMap(p3Renderer);
      p3Scene.environment = envMap;
      p3Scene.environmentIntensity = 0.8;

      p3Camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 500);
      p3Camera.position.set(10, 8, 12);

      // Post-Processing
      window.p3Composer = new EffectComposer(p3Renderer);
      const renderPass = new RenderPass(p3Scene, p3Camera);
      window.p3Composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 1.5, 0.4, 0.85);
      // Optimized bloom parameters for better performance
      bloomPass.threshold = 0.95;  // Higher threshold = less bloom = better FPS
      bloomPass.strength = 0.25;    // Lower strength = subtle effect
      bloomPass.radius = 0.15;      // Smaller radius = faster
      window.p3Composer.addPass(bloomPass);

      const outputPass = new OutputPass();
      window.p3Composer.addPass(outputPass);

      p3Controls = new OrbitControls(p3Camera, p3Renderer.domElement);
      p3Controls.enableDamping = true;
      p3Controls.dampingFactor = 0.08;
      p3Controls.autoRotateSpeed = 2.0;
      p3Controls.minDistance = 2;
      p3Controls.maxDistance = 100;

      // Optimized Lighting (Balanced performance + quality)
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);  // Increased for better visibility
      p3Scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);  // Reduced intensity
      keyLight.position.set(10, 20, 10);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(1024, 1024);  // Reduced from 2048 for performance
      keyLight.shadow.camera.near = 0.5;
      keyLight.shadow.camera.far = 50;
      keyLight.shadow.camera.left = -15;
      keyLight.shadow.camera.right = 15;
      keyLight.shadow.camera.top = 15;
      keyLight.shadow.camera.bottom = -15;
      p3Scene.add(keyLight);

      // Removed fillLight and rimLight for performance (environment map provides ambient)

      // Ground shadow plane
      const groundGeo = new THREE.PlaneGeometry(60, 60);
      const groundMat = new THREE.ShadowMaterial({ opacity: 0.2 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.01;
      ground.receiveShadow = true;
      p3Scene.add(ground);

      p3ZoneGroup = new THREE.Group();
      p3Scene.add(p3ZoneGroup);

      // FPS Tracking
      let p3FrameCount = 0;
      let p3LastTime = performance.now();
      let p3CurrentFPS = 0;

      // Animate
      function animateP3() {
        requestAnimationFrame(animateP3);

        // Stats.js begin
        if (window.p3Stats) window.p3Stats.begin();

        p3Controls.update();
        window.p3Composer.render();

        // Stats.js end
        if (window.p3Stats) window.p3Stats.end();

        // FPS calculation
        p3FrameCount++;
        const now = performance.now();
        if (now >= p3LastTime + 1000) {
          p3CurrentFPS = Math.round((p3FrameCount * 1000) / (now - p3LastTime));
          p3FrameCount = 0;
          p3LastTime = now;

          // Update FPS display (if stats panel exists)
          const fpsEl = document.querySelector('#p3-stats-fps .font-bold');
          if (fpsEl) fpsEl.textContent = p3CurrentFPS;
        }
      }
      animateP3();

      // Resize
      const ro = new ResizeObserver(() => { resizePanel3D(); });
      ro.observe(container);

      // Hover
      container.addEventListener('pointermove', onP3PointerMove);

      // Camera preset buttons
      document.querySelectorAll('.panel3d-cam-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setP3CameraPreset(btn.dataset.p3cam);
          document.querySelectorAll('.panel3d-cam-btn').forEach(b => {
            // Keep existing styles or update to tech? Updating to tech.
            b.className = b === btn
              ? 'panel3d-cam-btn px-2 py-1 text-xs rounded bg-slate-800 text-white hover:bg-slate-700 transition'
              : 'panel3d-cam-btn px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition';
          });
        });
      });

      // Exploded slider
      const p3Slider = document.getElementById('panel3d-explode-slider');
      const p3SliderVal = document.getElementById('panel3d-explode-value');
      if (p3Slider) {
        p3Slider.addEventListener('input', () => {
          p3ExplodeFactor = parseInt(p3Slider.value) / 100;
          p3SliderVal.textContent = p3Slider.value + '%';
          applyP3Explode();
        });
      }

      // Export
      const expBtn = document.getElementById('export-panel3d-png');
      if (expBtn) {
        expBtn.addEventListener('click', () => {
          if (!window.p3Composer) return;
          window.p3Composer.render(); // Render effectively
          // Note: toDataURL needs preserveDrawingBuffer: true, which we set.
          // But Composer renders to a target usually. OutputPass renders to screen?
          // If OutputPass renders to screen (default), then canvas has the image.
          // We can just grab canvas.toDataURL.
          const url = p3Renderer.domElement.toDataURL('image/png');
          const a = document.createElement('a');
          a.href = url;
          a.download = 'panel_3d_zone_map.png';
          a.click();
        });
      }

      // ---- Auto-Rotate ----
      const autoRotBtn = document.getElementById('p3-autorotate-btn');
      if (autoRotBtn) {
        autoRotBtn.addEventListener('click', () => {
          p3Controls.autoRotate = !p3Controls.autoRotate;
          toggleBtnActive(autoRotBtn, p3Controls.autoRotate);
        });
      }

      // ---- Wireframe ----
      const wireBtn = document.getElementById('p3-wireframe-btn');
      if (wireBtn) {
        wireBtn.addEventListener('click', () => {
          p3Wireframe = !p3Wireframe;
          toggleBtnActive(wireBtn, p3Wireframe);
          p3ZoneMeshes.forEach(p => {
            const mat = p.mesh.material;
            if (Array.isArray(mat)) {
              mat.forEach(m => { m.wireframe = p3Wireframe; m.opacity = p3Wireframe ? 0.5 : 1; m.transparent = p3Wireframe; });
            } else {
              mat.wireframe = p3Wireframe;
              mat.opacity = p3Wireframe ? 0.5 : 1;
              mat.transparent = p3Wireframe;
            }
            if (p.edges) p.edges.visible = !p3Wireframe;
          });
        });
      }

      // ---- Fullscreen ----
      const fullBtn = document.getElementById('p3-fullscreen-btn');
      if (fullBtn) {
        fullBtn.addEventListener('click', () => {
          toggleFullscreen(document.getElementById('panel3d-pane'));
        });
      }

      // ---- Wing View Toggle ----
      const wingBtn = document.getElementById('p3-wing-mode-btn');
      if (wingBtn) {
        wingBtn.addEventListener('click', () => {
          p3WingMode = !p3WingMode;
          toggleBtnActive(wingBtn, p3WingMode);
          wingBtn.innerHTML = p3WingMode
            ? `<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/></svg> Duz`
            : `<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg> Wing`;
          // Re-render
          if (p3ZonesData && p3BoundsData) {
            updatePanel3D(p3ZonesData, p3BoundsData, _lastWeight, _lastRampChecks);
          }
        });
      }

      // ---- Tema Toggle (Açık / Koyu) ----
      const themeBtn = document.getElementById('p3-theme-btn');
      if (themeBtn) {
        themeBtn.addEventListener('click', () => {
          applyP3Theme(!p3LightMode);
        });
      }
    }

    // ==================== TEMA UYGULA ====================
    // TUSAŞ Mühendislik Açık Teması — Koyu/Açık geçiş
    function applyP3Theme(light) {
      p3LightMode = light;
      if (!p3Renderer || !p3Scene) return;

      const bg = light ? LIGHT_BG_COLOR : TECH_BG_COLOR;
      const g1 = light ? LIGHT_GRID_1 : GRID_COLOR_1;
      const g2 = light ? LIGHT_GRID_2 : GRID_COLOR_2;

      // Renderer & sahne arka planı
      p3Renderer.setClearColor(bg, 1);
      p3Scene.background = new THREE.Color(bg);
      p3Scene.fog = new THREE.FogExp2(bg, light ? 0.004 : 0.02);

      // Işıklandırma: açık temada daha güçlü ambient
      p3Scene.traverse(obj => {
        if (obj.isAmbientLight) obj.intensity = light ? 1.1 : 0.6;
        if (obj.isDirectionalLight) obj.intensity = light ? 1.0 : 1.2;
      });

      // Izgarayı yeniden oluştur
      if (p3GridObj) {
        p3Scene.remove(p3GridObj);
        p3GridObj.geometry.dispose();
        if (p3GridObj.material) p3GridObj.material.dispose();
      }
      p3GridObj = new THREE.GridHelper(60, 60, g2, g1);
      p3GridObj.position.y = -0.005;
      p3Scene.add(p3GridObj);

      // Bloom efekti: açık temada sıfır (parlama gerekmez)
      if (window.p3Composer) {
        const bloomPass = window.p3Composer.passes.find(p => p.isUnrealBloomPass);
        if (bloomPass) bloomPass.strength = light ? 0.0 : 0.25;
      }

      // Stats overlay güncelle
      const overlay = document.getElementById('p3-stats-overlay');
      if (overlay) {
        overlay.className = light
          ? 'absolute top-3 right-3 z-10 bg-white/95 backdrop-blur-md border border-slate-300 rounded-lg px-3 py-2 text-xs text-slate-700 shadow-lg'
          : 'absolute top-3 right-3 z-10 bg-slate-900/80 backdrop-blur-md border border-slate-700/50 rounded-lg px-3 py-2 text-xs text-slate-200 shadow-lg hidden';
        if (!overlay.classList.contains('hidden')) overlay.classList.remove('hidden');
        const header = overlay.querySelector('.font-semibold');
        if (header) {
          header.className = light
            ? 'font-semibold text-slate-800 mb-1 text-[11px] uppercase tracking-wide border-b border-slate-200 pb-1'
            : 'font-semibold text-white mb-1 text-[11px] uppercase tracking-wide border-b border-slate-700/50 pb-1';
        }
        // Değer spanları
        overlay.querySelectorAll('.font-mono').forEach(el => {
          if (el.classList.contains('text-cyan-400') || el.classList.contains('text-indigo-700')) {
            el.classList.remove('text-cyan-400', 'text-indigo-700');
            el.classList.add(light ? 'text-indigo-700' : 'text-cyan-400');
          }
          if (el.classList.contains('text-green-400') || el.classList.contains('text-emerald-700')) {
            el.classList.remove('text-green-400', 'text-emerald-700');
            el.classList.add(light ? 'text-emerald-700' : 'text-green-400');
          }
        });
        // Etiket spanları
        overlay.querySelectorAll('span.text-slate-400, span.text-slate-500').forEach(el => {
          el.classList.remove('text-slate-400', 'text-slate-500');
          el.classList.add(light ? 'text-slate-500' : 'text-slate-400');
        });
        // Alt çizgi
        const fpsRow = document.getElementById('p3-stats-fps');
        if (fpsRow) {
          fpsRow.className = light
            ? 'flex justify-between border-t border-slate-200 pt-1 mt-1'
            : 'flex justify-between border-t border-slate-700/50 pt-1 mt-1';
        }
      }

      // Tooltip güncelle
      const tooltip = document.getElementById('panel3d-tooltip');
      if (tooltip) {
        tooltip.className = light
          ? 'absolute pointer-events-none hidden z-10 bg-white/97 text-slate-800 text-xs rounded-lg px-3 py-2 shadow-xl border border-slate-200'
          : 'absolute pointer-events-none hidden z-10 bg-slate-900/90 text-white text-xs rounded-lg px-3 py-2 shadow-lg backdrop-blur border border-slate-700/50';
      }

      // Tema butonu görünümünü güncelle
      const btn = document.getElementById('p3-theme-btn');
      if (btn) {
        if (light) {
          btn.className = 'px-2 py-1 text-xs rounded bg-amber-100 text-amber-800 hover:bg-amber-200 transition flex items-center gap-1 ring-1 ring-amber-400';
          btn.innerHTML = `<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/>
          </svg> Koyu`;
        } else {
          btn.className = 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1';
          btn.innerHTML = `<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="5"/>
            <line x1="12" y1="1" x2="12" y2="3" stroke-linecap="round"/>
            <line x1="12" y1="21" x2="12" y2="23" stroke-linecap="round"/>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" stroke-linecap="round"/>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" stroke-linecap="round"/>
            <line x1="1" y1="12" x2="3" y2="12" stroke-linecap="round"/>
            <line x1="21" y1="12" x2="23" y2="12" stroke-linecap="round"/>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" stroke-linecap="round"/>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" stroke-linecap="round"/>
          </svg> Açık`;
        }
      }

      // 3D içeriği yeniden oluştur (text sprite'lar ve materyal dahil)
      if (p3ZonesData && p3BoundsData) {
        updatePanel3D(p3ZonesData, p3BoundsData, _lastWeight, _lastRampChecks);
      }
    }

    function resizePanel3D() {
      if (!p3Renderer || !p3Container) return;
      const w = p3Container.clientWidth;
      const h = p3Container.clientHeight;
      p3Renderer.setSize(w, h);
      p3Camera.aspect = w / h;
      p3Camera.updateProjectionMatrix();
      if (window.p3Composer) window.p3Composer.setSize(w, h);
    }

    // ==================== UPDATE PANEL 3D ====================
    // Referans: Tek duz panel, zone'lar ayni taban uzerinde, katmanlar zone
    // sinirlarinda drop-off ile bitiyor (merdiven gorunumu)
    function updatePanel3D(zones, bounds, weightInfo, rampChecks) {
      if (!p3ZoneGroup) return;
      p3ZonesData = zones;
      p3BoundsData = bounds;

      updatePanel3DStats(zones);

      // Clear
      while (p3ZoneGroup.children.length > 0) {
        const c = p3ZoneGroup.children[0];
        c.traverse(o => {
          if (o.geometry) o.geometry.dispose();
          if (o.material) {
            if (Array.isArray(o.material)) o.material.forEach(m => m.dispose());
            else o.material.dispose();
          }
        });
        p3ZoneGroup.remove(c);
      }
      p3ZoneMeshes = [];
      p3Highlighted = null;
      p3TooltipEl.classList.add('hidden');

      if (!zones || !zones.length) return;
      if (!bounds || !bounds.length) return;

      // ---- Piksel -> World donusumu ----
      const PANEL_WORLD_SIZE = 14.0;
      const allXs = bounds.flatMap(b => [b.x, b.x + b.w]);
      const allYs = bounds.flatMap(b => [b.y, b.y + b.h]);
      const bMinX = Math.min(...allXs), bMaxX = Math.max(...allXs);
      const bMinY = Math.min(...allYs), bMaxY = Math.max(...allYs);
      const bW = Math.max(1, bMaxX - bMinX);
      const bH = Math.max(1, bMaxY - bMinY);
      const pxScale = PANEL_WORLD_SIZE / Math.max(bW, bH);
      const bCx = (bMinX + bMaxX) / 2;
      const bCy = (bMinY + bMaxY) / 2;

      // If Wing Mode, add Reference Ghost
      if (p3WingMode) {
        createReferenceWing(p3ZoneGroup);
      }

      const panelGroup = new THREE.Group();
      panelGroup.castShadow = true;  // Single shadow for entire panel
      p3ZoneGroup.add(panelGroup);

      const validZones = zones.filter(z => z && z.sequence && z.sequence.length > 0);
      if (!validZones.length) return;

      // World bounds per zone
      const zoneWorld = bounds.map(b => ({
        x1: (b.x - bCx) * pxScale,
        z1: (b.y - bCy) * pxScale,
        x2: (b.x + b.w - bCx) * pxScale,
        z2: (b.y + b.h - bCy) * pxScale,
        cx: (b.x + b.w / 2 - bCx) * pxScale,
        cz: (b.y + b.h / 2 - bCy) * pxScale,
        ww: b.w * pxScale,
        wd: b.h * pxScale,
      }));

      // Ply sabitler
      const maxPly = Math.max(...validZones.map(z => z.ply_count));
      const PLY_H = 0.06;   // ince yatay katman
      const PLY_GAP = 0.008;
      const STAGGER_OFFSET = 0.045; // Her ply drop-off icin ramp mesafesi (world units)
      // Kucuk deger = yumusak egim, buyuk = agresif

      // Root zone (en kalin)'un sequence'i tum panelin baz dizilimi
      const sortedByPly = [...validZones].sort((a, b) => b.ply_count - a.ply_count);
      const rootSeq = sortedByPly[0].sequence;

      // Zone ply_count map (zone.index -> zone obj)
      const zoneMap = {};
      validZones.forEach(z => { zoneMap[z.index] = z; });

      // ---- Komsuluk hesapla (hangi zone hangi kenara komsu) ----
      const ADJACENCY_THRESHOLD = 0.3;
      const neighbors = {};
      validZones.forEach(z => { neighbors[z.index] = []; });

      for (let a = 0; a < validZones.length; a++) {
        for (let b = a + 1; b < validZones.length; b++) {
          const zA = validZones[a], zB = validZones[b];
          const wA = zoneWorld[zA.index], wB = zoneWorld[zB.index];
          if (!wA || !wB) continue;

          const vOverlap = Math.min(wA.z2, wB.z2) - Math.max(wA.z1, wB.z1);
          const hOverlap = Math.min(wA.x2, wB.x2) - Math.max(wA.x1, wB.x1);

          if (vOverlap > 0) {
            const gapRight = Math.abs(wA.x2 - wB.x1);
            const gapLeft = Math.abs(wB.x2 - wA.x1);
            if (gapRight < ADJACENCY_THRESHOLD) {
              neighbors[zA.index].push({ idx: zB.index, myEdge: 'right' });
              neighbors[zB.index].push({ idx: zA.index, myEdge: 'left' });
            } else if (gapLeft < ADJACENCY_THRESHOLD) {
              neighbors[zB.index].push({ idx: zA.index, myEdge: 'right' });
              neighbors[zA.index].push({ idx: zB.index, myEdge: 'left' });
            }
          }

          if (hOverlap > 0) {
            const gapBottom = Math.abs(wA.z2 - wB.z1);
            const gapTop = Math.abs(wB.z2 - wA.z1);
            if (gapBottom < ADJACENCY_THRESHOLD) {
              neighbors[zA.index].push({ idx: zB.index, myEdge: 'bottom' });
              neighbors[zB.index].push({ idx: zA.index, myEdge: 'top' });
            } else if (gapTop < ADJACENCY_THRESHOLD) {
              neighbors[zB.index].push({ idx: zA.index, myEdge: 'bottom' });
              neighbors[zA.index].push({ idx: zB.index, myEdge: 'top' });
            }
          }
        }
      }

      // ---- Her ply icin: ramp drop-off ile ciz ----
      // Mantik:
      //   - Ortak ply'lar (plyIdx < her iki zone'un ply_count) -> TAM GENISLIK, dokunma
      //   - Ekstra ply'lar (plyIdx >= komsu.ply_count) -> komsu kenara dogru TASARAK ramp yap
      //   - En alttaki drop ply (plyIdx == komsu.ply_count) komsuya en cok tasar
      //   - En ustteki drop ply (plyIdx == zone.ply_count-1) hic tasmaz (zone sinirinda biter)
      //   - Sonuc: yandan bakinca duz egimli ramp (ucak kanadi gibi)

      for (let plyIdx = 0; plyIdx < maxPly; plyIdx++) {
        const angle = rootSeq[plyIdx];
        const angleKey = String(angle);
        const color = ANGLE_COLORS[angleKey] || 0x94a3b8;
        const baseY = plyIdx * (PLY_H + PLY_GAP);

        validZones.forEach(zone => {
          if (plyIdx >= zone.ply_count) return; // bu zone'da bu ply yok
          const bIdx = zone.index;
          const zw = zoneWorld[bIdx];
          if (!zw) return;

          // Ramp hesabi: ekstra ply'lar komsu zone'a dogru tasararak ramp yapar
          // outset = komsu zone alanina dogru uzama (pozitif = disa dogru buyur)
          // inset  = zone sinirinden iceye daraltma (negatif yonde kucultme yok — sadece outset)
          let outLeft = 0, outRight = 0, outTop = 0, outBottom = 0;

          (neighbors[bIdx] || []).forEach(nb => {
            const nbZone = zoneMap[nb.idx];
            if (!nbZone) return;

            if (nbZone.ply_count > zone.ply_count) {
              // Komsu daha KALIN -- bu zone'daki tum ply'lar zaten komsuya tam
              // yakin; komsu zone'dan gelen ramp bu zone'un ustune binecek
              // Burada yapacak bir sey yok (komsu kendi outset'ini hesaplar)
              return;
            }

            if (plyIdx < nbZone.ply_count) {
              // Bu ply komsuda da var -> ortak katman, tam genislik, dokunma
              return;
            }

            // Bu ply komsuda YOK -> ekstra ply, ramp yap
            // dropPos: 0 = ilk drop ply (komsunun ustune en yakin), totalDrop-1 = en ust
            const totalDrop = zone.ply_count - nbZone.ply_count;
            const dropPos = plyIdx - nbZone.ply_count; // 0..totalDrop-1

            // En alttaki drop ply komsunun uzerine EN COK tasar (yumusak gecis)
            // En ustteki drop ply hic tasmaz (zone sinirlari icerisinde)
            // outset = (totalDrop - dropPos) * STAGGER_OFFSET
            //   dropPos=0           -> outset = totalDrop * OFFSET  (max tasma)
            //   dropPos=totalDrop-1 -> outset = 1 * OFFSET          (min tasma)
            const outset = (totalDrop - dropPos) * STAGGER_OFFSET;

            if (nb.myEdge === 'right') outRight = Math.max(outRight, outset);
            else if (nb.myEdge === 'left') outLeft = Math.max(outLeft, outset);
            else if (nb.myEdge === 'bottom') outBottom = Math.max(outBottom, outset);
            else if (nb.myEdge === 'top') outTop = Math.max(outTop, outset);
          });

          // Outset uygula -- ply komsu zone alanina dogru tasar
          // Ortak ply'lar (outset=0) -> tam zone boyutunda
          // Ekstra ply'lar -> komsu tarafa dogru biraz buyur
          const effX1 = zw.x1 - outLeft;
          const effX2 = zw.x2 + outRight;
          const effZ1 = zw.z1 - outTop;
          const effZ2 = zw.z2 + outBottom;
          const effW = Math.max(0.01, effX2 - effX1);
          const effD = Math.max(0.01, effZ2 - effZ1);
          const effCx = (effX1 + effX2) / 2;
          const effCz = (effZ1 + effZ2) / 2;

          let mesh, edges;

          if (p3WingMode) {
            // --- WING MODE GEOMETRY ---
            // Calculate Normalized U,V coords for this zone
            // effX1, effX2 are relative to bMinX...bMaxX
            // We need global bounds to normalize.
            // allXs, allYs calculated above...
            // actually we are already in World Coordinates centered at bCx

            // Recover 0..1 range:
            // WorldX = (u - 0.5) * PANEL_WORLD_SIZE * aspect... wait.
            // Let's rely on effX1 relative to global Min/Max
            // We know: pxScale = PANEL_WORLD_SIZE / max(bW, bH)
            // WorldX = (Px - Cx) * pxScale
            // Px = WorldX / pxScale + Cx
            // u = (Px - bMinX) / (bMaxX - bMinX)

            const rawX1 = effX1 / pxScale + bCx;
            const rawX2 = effX2 / pxScale + bCx;
            const rawY1 = effZ1 / pxScale + bCy; // Z in 3D is Y in 2D bounds
            const rawY2 = effZ2 / pxScale + bCy;

            const u1 = (rawX1 - bMinX) / bW;
            const u2 = (rawX2 - bMinX) / bW;
            const v1 = (rawY1 - bMinY) / bH;
            const v2 = (rawY2 - bMinY) / bH;

            // Create segmented geometry
            const segX = Math.max(2, Math.ceil((u2 - u1) * 20));
            const segY = Math.max(2, Math.ceil((v2 - v1) * 10));
            const geo = new THREE.PlaneGeometry(1, 1, segX, segY);
            const pos = geo.attributes.position;

            for (let i = 0; i < pos.count; i++) {
              const lx = pos.getX(i) + 0.5; // 0..1 local
              const ly = pos.getY(i) + 0.5; // 0..1 local (actually local Y maps to V)
              // Map local 0..1 to sub-zone u,v
              const u_world = u1 + lx * (u2 - u1);
              const v_world = v1 + (1 - ly) * (v2 - v1); // Flip Y/V direction if needed? 2D Y grows down?
              // In Three Plane, Y grows up. In Canvas, Y grows down.
              // v1 corresponds to rawY1 (MinY / Top). v2 to MaxY / Bottom.
              // Let's assume standard UV mapping.

              const p3 = mapToWing(u_world, v_world);
              // Apply slight offset based on ply index to avoid Z-fighting?
              // Or use thickness.
              // Radial offset along normal?
              // Simple hack: Lift Y slightly by plyIdx
              p3.y += plyIdx * 0.005;

              pos.setXYZ(i, p3.x, p3.y, p3.z);
            }
            geo.computeVertexNormals();

            const fiberTex = fiberTextures[angleKey] || null;

            // TUSAŞ Standard PBR Material for Composite
            const mat = new THREE.MeshStandardMaterial({
              color: color,
              side: THREE.DoubleSide,
              roughness: 0.35,           // Composite surface (semi-matte)
              metalness: 0.6,            // Carbon fiber metallic look
              emissive: color,
              emissiveIntensity: 0.03,   // Subtle self-illumination
              polygonOffset: true,
              polygonOffsetFactor: -1 * plyIdx,
              depthTest: true,
              envMapIntensity: 1.2       // Enhanced reflections
            });

            if (fiberTex) {
              mat.map = fiberTex;
              mat.map.needsUpdate = true;
              mat.map.anisotropy = p3Renderer.capabilities.getMaxAnisotropy();
            }

            mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            panelGroup.add(mesh);

            // Edges? Specialized edges for curved surface is hard with EdgesGeometry.
            // Skip edges or use wireframe helper
            // const edgesGeo = new THREE.WireframeGeometry(geo);
            // edges = new THREE.LineSegments(edgesGeo, new THREE.LineBasicMaterial({ color: 0x000000, opacity:0.1 }));
            // panelGroup.add(edges);
            edges = null; // skipping edges for wing mode for perf/clarity

            // Adjust camera for wing?
            // Maybe once?

          } else {
            // --- FLAT MODE (EXISTING) ---
            const geo = getBoxGeometry(effW, PLY_H, effD);  // Use cached geometry
            const fiberTex = fiberTextures[angleKey] || null;
            const mat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: p3LightMode ? 0.68 : 0.4,
              metalness: 0.0,
              emissive: color,
              emissiveIntensity: p3LightMode ? 0.0 : 0.05,
            });
            if (fiberTex) {
              mat.map = fiberTex;
              mat.map.needsUpdate = true;
              // Anisotropic filtering for better texture quality
              mat.map.anisotropy = p3Renderer.capabilities.getMaxAnisotropy();
            }

            mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(effCx, baseY + PLY_H / 2, effCz);
            mesh.castShadow = false;  // Disable individual ply shadows for performance
            mesh.receiveShadow = false;
            panelGroup.add(mesh);

            // Removed EdgesGeometry for performance - zone borders provide visual separation
            edges = null;
          }

          p3ZoneMeshes.push({
            mesh, edges, plyIdx, angle, zoneIndex: bIdx,
            baseY: baseY + PLY_H / 2,
            effH: PLY_H,
            origColor: color
          });
        });
      }

      // ---- Zone sinir cizgileri (panel ustunde kesikli gorsel) ----
      validZones.forEach(zone => {
        const bIdx = zone.index;
        const zw = zoneWorld[bIdx];
        if (!zw) return;
        const topY = zone.ply_count * (PLY_H + PLY_GAP) + 0.01;

        // Ustten zone siniri (tam kalinligin ustunde dikdortgen outline)
        const corners = [
          new THREE.Vector3(zw.x1, topY, zw.z1),
          new THREE.Vector3(zw.x2, topY, zw.z1),
          new THREE.Vector3(zw.x2, topY, zw.z2),
          new THREE.Vector3(zw.x1, topY, zw.z2),
          new THREE.Vector3(zw.x1, topY, zw.z1),
        ];
        const borderGeo = new THREE.BufferGeometry().setFromPoints(corners);
        const borderColor = p3LightMode
          ? (zone.is_root ? 0x1e3a8a : 0x475569)   // Açık tema: TUSAŞ lacivert / koyu gri
          : (zone.is_root ? 0x1e40af : 0x334155);   // Koyu tema: mavi / slate
        const borderMat = new THREE.LineBasicMaterial({ color: borderColor, linewidth: 2 });
        panelGroup.add(new THREE.Line(borderGeo, borderMat));

        // Dikey sinir cizgileri (zeminden tepeye 4 kose)
        [[zw.x1, zw.z1], [zw.x2, zw.z1], [zw.x2, zw.z2], [zw.x1, zw.z2]].forEach(([cx, cz]) => {
          const vGeo = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(cx, 0, cz),
            new THREE.Vector3(cx, topY, cz),
          ]);
          const vMat = new THREE.LineBasicMaterial({
            color: p3LightMode ? 0x64748b : 0x94a3b8,
            opacity: p3LightMode ? 0.55 : 0.3,
            transparent: true
          });
          panelGroup.add(new THREE.Line(vGeo, vMat));
        });

        // TUSAŞ Standard Zone Markings
        const b = bounds[bIdx];
        const zLabel = b.label || `ZONE ${bIdx + 1}`;
        const plyText = `${zone.ply_count} PLY`;
        const thicknessMM = (zone.ply_count * 0.125).toFixed(2);
        const fitnessText = zone.fitness ? ` | ${zone.fitness.toFixed(1)}/100` : '';
        const dropTree = window._view3d?._dropOffTree || {};
        const sourceIdx = dropTree[String(bIdx)];
        const sourceTag = (sourceIdx !== undefined && sourceIdx !== null && bounds[sourceIdx])
          ? ` < ${bounds[sourceIdx].label || ('Zone ' + (sourceIdx + 1))}`
          : '';
        const rootTag = zone.is_root ? ' [ROOT]' : sourceTag;

        // Main label with TUSAŞ branding
        const labelText = `${zLabel}${rootTag}\n${plyText} • ${thicknessMM}mm${fitnessText}`;
        const sp = createTextSprite(labelText, zone.is_root);
        sp.position.set(zw.cx, topY + 0.35, zw.cz);
        sp.scale.set(2.8, 0.65, 1);
        panelGroup.add(sp);

        // Technical Grid Overlay (optional, for high detail)
        if (p3WingMode && zone.is_root) {
          // Add subtle grid lines on root zone surface
          const gridHelper = new THREE.GridHelper(
            Math.max(zw.ww, zw.wd),
            8,
            0x3498db,  // TUSAŞ blue
            0x2c3e50   // Dark gray
          );
          gridHelper.rotation.x = Math.PI / 2;
          gridHelper.position.set(zw.cx, topY + 0.001, zw.cz);
          gridHelper.material.transparent = true;
          gridHelper.material.opacity = 0.15;
          panelGroup.add(gridHelper);
        }
      });

      // ---- Ramp ihlal cizgileri ----
      if (rampChecks) {
        rampChecks.forEach(r => {
          if (r.feasible) return;
          const zwA = zoneWorld[r.zone_a];
          const zwB = zoneWorld[r.zone_b];
          if (!zwA || !zwB) return;
          const topA = (zoneMap[r.zone_a]?.ply_count || 0) * (PLY_H + PLY_GAP);
          const topB = (zoneMap[r.zone_b]?.ply_count || 0) * (PLY_H + PLY_GAP);
          const p1 = new THREE.Vector3(zwA.cx, Math.max(topA, topB) + 0.1, zwA.cz);
          const p2 = new THREE.Vector3(zwB.cx, Math.max(topA, topB) + 0.1, zwB.cz);
          const lineGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
          const lineMat = new THREE.LineBasicMaterial({ color: 0xef4444 });
          panelGroup.add(new THREE.Line(lineGeo, lineMat));

          const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
          const warnSp = createTextSprite(`RAMP IHLAL: ${r.ply_diff} ply`, false, true);
          warnSp.position.set(mid.x, mid.y + 0.25, mid.z);
          warnSp.scale.set(1.8, 0.35, 1);
          panelGroup.add(warnSp);
        });
      }

      // ---- Drop-off hiyerarşi okları (yeşil) ----
      const dropTree3D = window._view3d?._dropOffTree || {};
      if (Object.keys(dropTree3D).length > 0) {
        Object.entries(dropTree3D).forEach(([childStr, parentIdx]) => {
          const childIdx = parseInt(childStr);
          const zwP = zoneWorld[parentIdx];
          const zwC = zoneWorld[childIdx];
          if (!zwP || !zwC) return;
          const topP = (zoneMap[parentIdx]?.ply_count || 0) * (PLY_H + PLY_GAP);
          const topC = (zoneMap[childIdx]?.ply_count || 0) * (PLY_H + PLY_GAP);
          const arrowY = Math.max(topP, topC) + 0.2;

          // Çizgi parent → child
          const p1 = new THREE.Vector3(zwP.cx, arrowY, zwP.cz);
          const p2 = new THREE.Vector3(zwC.cx, arrowY, zwC.cz);
          const arrowGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
          const arrowMat = new THREE.LineBasicMaterial({ color: 0x059669, linewidth: 2 });
          panelGroup.add(new THREE.Line(arrowGeo, arrowMat));

          // Ok ucu (cone) child ucunda
          const dir = new THREE.Vector3().subVectors(p2, p1);
          const len = dir.length();
          if (len > 0.01) {
            dir.normalize();
            const coneGeo = new THREE.ConeGeometry(0.1, 0.25, 8);
            const coneMat = new THREE.MeshBasicMaterial({ color: 0x059669 });
            const cone = new THREE.Mesh(coneGeo, coneMat);
            // Cone'u child ucuna yerleştir
            cone.position.copy(p2);
            // Cone'un yönünü ayarla (default Y+ yönünde, dir yönüne çevir)
            const up = new THREE.Vector3(0, 1, 0);
            const quat = new THREE.Quaternion().setFromUnitVectors(up, dir);
            cone.quaternion.copy(quat);
            panelGroup.add(cone);
          }

          // Orta noktaya etiket
          const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
          const pLabel = bounds[parentIdx]?.label || `Z${parentIdx+1}`;
          const cLabel = bounds[childIdx]?.label || `Z${childIdx+1}`;
          const trSp = createTextSprite(`${pLabel} → ${cLabel}`, false, true);
          trSp.position.set(mid.x, arrowY + 0.18, mid.z);
          trSp.scale.set(1.6, 0.3, 1);
          panelGroup.add(trSp);
        });
      }

      // ---- Eksen gostergeleri (X/Y/Z oklar) ----
      const axisLen = PANEL_WORLD_SIZE * 0.12;
      const axisOrigin = new THREE.Vector3(
        Math.min(...zoneWorld.map(z => z.x1)) - 1.0,
        0,
        Math.max(...zoneWorld.map(z => z.z2)) + 1.0
      );
      // X axis (kirmizi)
      const xGeo = new THREE.BufferGeometry().setFromPoints([axisOrigin, new THREE.Vector3(axisOrigin.x + axisLen, axisOrigin.y, axisOrigin.z)]);
      panelGroup.add(new THREE.Line(xGeo, new THREE.LineBasicMaterial({ color: 0xef4444 })));
      const xLabel = createTextSprite('X', false, true);
      xLabel.position.set(axisOrigin.x + axisLen + 0.3, axisOrigin.y, axisOrigin.z);
      xLabel.scale.set(0.6, 0.25, 1);
      panelGroup.add(xLabel);

      // Y axis (yesil, yukari)
      const yGeo = new THREE.BufferGeometry().setFromPoints([axisOrigin, new THREE.Vector3(axisOrigin.x, axisOrigin.y + axisLen, axisOrigin.z)]);
      panelGroup.add(new THREE.Line(yGeo, new THREE.LineBasicMaterial({ color: 0x22c55e })));
      const yLabel = createTextSprite('Y', false, true);
      yLabel.position.set(axisOrigin.x, axisOrigin.y + axisLen + 0.3, axisOrigin.z);
      yLabel.scale.set(0.6, 0.25, 1);
      panelGroup.add(yLabel);

      // Z axis (mavi, derinlik)
      const zGeo = new THREE.BufferGeometry().setFromPoints([axisOrigin, new THREE.Vector3(axisOrigin.x, axisOrigin.y, axisOrigin.z - axisLen)]);
      panelGroup.add(new THREE.Line(zGeo, new THREE.LineBasicMaterial({ color: 0x3b82f6 })));
      const zLabel = createTextSprite('Z', false, true);
      zLabel.position.set(axisOrigin.x, axisOrigin.y, axisOrigin.z - axisLen - 0.3);
      zLabel.scale.set(0.6, 0.25, 1);
      panelGroup.add(zLabel);

      p3ZoneGroup.add(panelGroup);
      frameP3Camera(panelGroup);
    }

    // ==================== PANEL 3D CAMERA FRAMING ====================
    function frameP3Camera(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      // Yatay panel icin izometrik gorunum (referans gorsel gibi)
      const maxDim = Math.max(size.x, size.z);  // X-Z yatay boyut
      const dist = maxDim * 1.2;

      p3Controls.target.copy(center);
      // Izometrik aci: yukari ve yana bak (30 derece gibi)
      p3Camera.position.set(
        center.x + dist * 0.5,
        center.y + dist * 0.6,
        center.z + dist * 0.5
      );
      p3Controls.update();
    }

    // ==================== PANEL 3D CAMERA PRESETS ====================
    function setP3CameraPreset(preset) {
      if (!p3ZoneGroup || p3ZoneGroup.children.length === 0) return;
      const box = new THREE.Box3().setFromObject(p3ZoneGroup);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);
      const d = Math.max(size.x, size.z) * 1.3;

      const presets = {
        iso: { pos: [center.x + d * 0.5, center.y + d * 0.6, center.z + d * 0.5], target: [center.x, center.y, center.z] },
        top: { pos: [center.x, center.y + d * 1.0, center.z + 0.01], target: [center.x, center.y, center.z] },
        front: { pos: [center.x, center.y + size.y * 2, center.z + d * 0.9], target: [center.x, center.y, center.z] },
        side: { pos: [center.x + d * 0.9, center.y + size.y * 2, center.z], target: [center.x, center.y, center.z] },
      };
      const p = presets[preset] || presets.iso;

      const startPos = p3Camera.position.clone();
      const startTarget = p3Controls.target.clone();
      const endPos = new THREE.Vector3(...p.pos);
      const endTarget = new THREE.Vector3(...p.target);
      const duration = 600;
      const startTime = performance.now();

      function animCam(now) {
        const t = Math.min((now - startTime) / duration, 1);
        const ease = t < 0.5 ? 2 * t * t : 1 - (-2 * t + 2) ** 2 / 2;
        p3Camera.position.lerpVectors(startPos, endPos, ease);
        p3Controls.target.lerpVectors(startTarget, endTarget, ease);
        p3Controls.update();
        if (t < 1) requestAnimationFrame(animCam);
      }
      requestAnimationFrame(animCam);
    }

    // ==================== PANEL 3D EXPLODED VIEW ====================
    function applyP3Explode() {
      const maxGapPerPly = 0.3;
      p3ZoneMeshes.forEach(({ mesh, edges, plyIdx, baseY }) => {
        const newY = baseY + plyIdx * maxGapPerPly * p3ExplodeFactor;
        mesh.position.y = newY;
        edges.position.y = newY;
      });
    }

    // ==================== PANEL 3D HOVER ====================
    function onP3PointerMove(e) {
      if (!p3Container || !p3Camera) return;
      const rect = p3Container.getBoundingClientRect();
      p3Mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      p3Mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      p3Raycaster.setFromCamera(p3Mouse, p3Camera);

      // Reset highlight
      if (p3Highlighted) {
        p3Highlighted.material.emissive.setHex(p3Highlighted.userData._origEmissive || 0x000000);
        p3Highlighted = null;
      }

      const meshes = p3ZoneMeshes.map(m => m.mesh);
      const hits = p3Raycaster.intersectObjects(meshes, false);

      if (hits.length > 0) {
        const hitMesh = hits[0].object;
        const info = p3ZoneMeshes.find(p => p.mesh === hitMesh);
        if (info) {
          if (!hitMesh.userData._origEmissive) {
            hitMesh.userData._origEmissive = hitMesh.material.emissive.getHex();
          }
          hitMesh.material.emissive.setHex(0x555555);
          p3Highlighted = hitMesh;

          const zone = p3ZonesData ? p3ZonesData.find(z => z && z.index === info.zoneIndex) : null;
          const zLabel = p3BoundsData && p3BoundsData[info.zoneIndex] ? (p3BoundsData[info.zoneIndex].label || `Zone ${info.zoneIndex + 1}`) : `Zone ${info.zoneIndex + 1}`;
          const angleLabel = ANGLE_LABELS[String(info.angle)] || info.angle + '°';
          const angleColor = ANGLE_HEX[String(info.angle)] || '#94a3b8';
          const posMM = ((info.plyIdx + 1) * PLY_THICKNESS_MM).toFixed(2);

          p3TooltipEl.innerHTML = `
            <div class="flex items-center justify-between mb-1 border-b border-slate-700 pb-1">
              <span class="font-bold text-white">${zLabel}</span>
              <span class="text-[10px] px-1.5 py-0.5 rounded text-slate-900 font-bold" style="background:${angleColor}">Layer ${info.plyIdx + 1} (${angleLabel})</span>
            </div>
            <div class="space-y-0.5">
               <div class="flex justify-between"><span class="text-slate-400">Konum:</span> <span>${posMM} mm</span></div>
               ${zone ? `<div class="flex justify-between"><span class="text-slate-400">Toplam:</span> <span>${zone.ply_count} ply</span></div>` : ''}
               ${zone ? `<div class="flex justify-between"><span class="text-slate-400">Score:</span> <span>${zone.fitness.toFixed(1)}</span></div>` : ''}
            </div>
          `;
          p3TooltipEl.classList.remove('hidden');
          p3TooltipEl.style.left = (e.clientX - rect.left + 12) + 'px';
          p3TooltipEl.style.top = (e.clientY - rect.top - 10) + 'px';
        }
        p3Container.style.cursor = 'pointer';
      } else {
        p3TooltipEl.classList.add('hidden');
        p3Container.style.cursor = 'grab';
      }
    }

    // ==================== CROSS-SECTION VIEW ====================
    const crossSectionView = {
      canvas: null,
      ctx: null,
      zones: [],
      selectedZoneIndex: 0,
      tooltipEl: null,
      plyHeight: 14, // pixels
      plySpacing: 1,
      padding: 40,

      init(zones) {
        this.zones = zones;
        this.canvas = document.getElementById('cross-section-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.tooltipEl = document.getElementById('cross-section-tooltip');

        // Zone selector
        const selector = document.getElementById('cross-section-zone-selector');
        selector.innerHTML = '';
        zones.forEach((zone, idx) => {
          if (zone && zone.sequence) {
            const opt = document.createElement('option');
            opt.value = idx;
            opt.textContent = `Zone ${zone.index + 1} (${zone.ply_count} ply)`;
            selector.appendChild(opt);
          }
        });

        selector.addEventListener('change', (e) => {
          this.selectedZoneIndex = parseInt(e.target.value);
          this.render();
        });

        // Mouse events
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseleave', () => this.hideTooltip());

        // Export buttons
        document.getElementById('cross-section-export-svg').addEventListener('click', () => this.exportSVG());
        document.getElementById('cross-section-export-png').addEventListener('click', () => this.exportPNG());

        // Show card
        document.getElementById('cross-section-card').classList.remove('hidden');

        this.render();
      },

      render() {
        const zone = this.zones[this.selectedZoneIndex];
        if (!zone || !zone.sequence) return;

        const sequence = zone.sequence;
        const plyCount = sequence.length;

        // Canvas dimensions
        const canvasWidth = this.canvas.clientWidth || 600;
        const canvasHeight = plyCount * (this.plyHeight + this.plySpacing) + this.padding * 2;

        this.canvas.width = canvasWidth;
        this.canvas.height = canvasHeight;

        const ctx = this.ctx;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Background
        ctx.fillStyle = '#f8fafc';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // Draw plies (from bottom to top)
        const plyWidth = canvasWidth - this.padding * 2;
        for (let i = 0; i < plyCount; i++) {
          const plyIdx = plyCount - 1 - i; // Reverse (bottom layer first)
          const angle = sequence[plyIdx];
          const y = this.padding + i * (this.plyHeight + this.plySpacing);

          this.drawPly(ctx, plyIdx, angle, y, plyWidth);
        }

        // Update stats
        const totalThickness = (plyCount * 0.125).toFixed(2);
        document.getElementById('cross-section-total').textContent = `${plyCount} ply`;
        document.getElementById('cross-section-thickness').textContent = `${totalThickness} mm`;
      },

      drawPly(ctx, plyIdx, angle, y, width) {
        const x = this.padding;
        const angleKey = String(angle);
        const color = ANGLE_HEX[angleKey] || '#94a3b8';

        // Ply rectangle
        ctx.fillStyle = color;
        ctx.fillRect(x, y, width, this.plyHeight);

        // Border
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x, y, width, this.plyHeight);

        // Label
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const label = `Ply ${plyIdx + 1}: ${angle}°`;
        ctx.fillText(label, x + 5, y + this.plyHeight / 2);

        // Thickness label (right side)
        ctx.textAlign = 'right';
        ctx.fillText('0.125mm', x + width - 5, y + this.plyHeight / 2);
      },

      onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseY = e.clientY - rect.top;

        const zone = this.zones[this.selectedZoneIndex];
        if (!zone || !zone.sequence) return;

        const plyCount = zone.sequence.length;

        // Find which ply was hovered
        for (let i = 0; i < plyCount; i++) {
          const y = this.padding + i * (this.plyHeight + this.plySpacing);
          if (mouseY >= y && mouseY <= y + this.plyHeight) {
            const plyIdx = plyCount - 1 - i;
            const angle = zone.sequence[plyIdx];
            const thickness = ((plyIdx + 1) * 0.125).toFixed(2);

            this.showTooltip(e.clientX, e.clientY, {
              plyIdx: plyIdx + 1,
              angle,
              thickness,
              position: `${plyIdx + 1}/${plyCount}`
            });
            return;
          }
        }

        this.hideTooltip();
      },

      showTooltip(x, y, data) {
        this.tooltipEl.innerHTML = `
          <div class="font-bold mb-1">Ply ${data.plyIdx}</div>
          <div>Angle: <span class="text-cyan-400">${data.angle}°</span></div>
          <div>Position: <span class="text-yellow-400">${data.position}</span></div>
          <div>Cumulative: <span class="text-emerald-400">${data.thickness} mm</span></div>
        `;
        this.tooltipEl.style.left = (x + 10) + 'px';
        this.tooltipEl.style.top = (y + 10) + 'px';
        this.tooltipEl.classList.remove('hidden');
      },

      hideTooltip() {
        this.tooltipEl.classList.add('hidden');
      },

      exportSVG() {
        // Canvas to SVG conversion (simplified)
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", this.canvas.width);
        svg.setAttribute("height", this.canvas.height);
        svg.setAttribute("xmlns", svgNS);

        // Background
        const bg = document.createElementNS(svgNS, "rect");
        bg.setAttribute("width", "100%");
        bg.setAttribute("height", "100%");
        bg.setAttribute("fill", "#f8fafc");
        svg.appendChild(bg);

        const zone = this.zones[this.selectedZoneIndex];
        if (!zone) return;

        const sequence = zone.sequence;
        const plyCount = sequence.length;
        const plyWidth = this.canvas.width - this.padding * 2;

        for (let i = 0; i < plyCount; i++) {
          const plyIdx = plyCount - 1 - i;
          const angle = sequence[plyIdx];
          const y = this.padding + i * (this.plyHeight + this.plySpacing);
          const color = ANGLE_HEX[String(angle)] || '#94a3b8';

          const rect = document.createElementNS(svgNS, "rect");
          rect.setAttribute("x", this.padding);
          rect.setAttribute("y", y);
          rect.setAttribute("width", plyWidth);
          rect.setAttribute("height", this.plyHeight);
          rect.setAttribute("fill", color);
          rect.setAttribute("stroke", "#1e293b");
          rect.setAttribute("stroke-width", "0.5");
          svg.appendChild(rect);

          const text = document.createElementNS(svgNS, "text");
          text.setAttribute("x", this.padding + 5);
          text.setAttribute("y", y + this.plyHeight / 2 + 3);
          text.setAttribute("fill", "#ffffff");
          text.setAttribute("font-size", "10");
          text.setAttribute("font-family", "monospace");
          text.textContent = `Ply ${plyIdx + 1}: ${angle}°`;
          svg.appendChild(text);
        }

        const svgData = new XMLSerializer().serializeToString(svg);
        const blob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cross-section-zone${zone.index + 1}.svg`;
        a.click();
        URL.revokeObjectURL(url);
      },

      exportPNG() {
        const link = document.createElement('a');
        link.download = `cross-section-zone${this.zones[this.selectedZoneIndex].index + 1}.png`;
        link.href = this.canvas.toDataURL('image/png');
        link.click();
      }
    };

    // ==================== PLY COVERAGE MAP ====================
    const plyCoverageMap = {
      container: null,
      zones: [],
      maxPly: 0,

      init(zones) {
        this.zones = zones.filter(z => z && z.sequence);
        if (!this.zones.length) return;

        this.container = document.getElementById('ply-coverage-container');
        this.maxPly = Math.max(...this.zones.map(z => z.ply_count));

        // Show card
        document.getElementById('ply-coverage-card').classList.remove('hidden');

        this.render();
      },

      render() {
        this.container.innerHTML = '';

        // Create grid
        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = `120px repeat(${this.maxPly}, 16px)`;
        grid.style.gap = '2px';
        grid.style.alignItems = 'center';

        // Header row
        const headerLabel = document.createElement('div');
        headerLabel.textContent = 'Zone / Ply';
        headerLabel.className = 'text-xs font-bold text-slate-700 sticky left-0 bg-slate-50 z-10';
        grid.appendChild(headerLabel);

        for (let p = 1; p <= this.maxPly; p++) {
          const cell = document.createElement('div');
          cell.textContent = p;
          cell.className = 'text-[9px] text-center text-slate-500 font-mono';
          cell.title = `Ply ${p}`;
          grid.appendChild(cell);
        }

        // Zone rows
        this.zones.forEach((zone, zIdx) => {
          // Zone label
          const label = document.createElement('div');
          label.textContent = `Zone ${zone.index + 1} (${zone.ply_count})`;
          label.className = 'text-xs font-semibold text-slate-800 sticky left-0 bg-slate-50 z-10';
          grid.appendChild(label);

          // Ply cells
          for (let p = 1; p <= this.maxPly; p++) {
            const cell = document.createElement('div');
            cell.className = 'w-4 h-4 rounded cursor-pointer transition-all hover:scale-125';
            cell.dataset.zone = zIdx;
            cell.dataset.ply = p - 1;

            if (p <= zone.ply_count) {
              const angle = zone.sequence[p - 1];
              const angleColor = ANGLE_HEX[String(angle)] || '#94a3b8';
              cell.style.backgroundColor = angleColor;
              cell.title = `Zone ${zone.index + 1}, Ply ${p}: ${angle}°`;
            } else {
              cell.style.backgroundColor = '#e2e8f0';
              cell.title = `Zone ${zone.index + 1}, Ply ${p}: Dropped`;
            }

            cell.addEventListener('click', () => this.highlightColumn(p - 1));

            grid.appendChild(cell);
          }
        });

        this.container.appendChild(grid);
      },

      highlightColumn(plyIdx) {
        const cells = this.container.querySelectorAll(`[data-ply="${plyIdx}"]`);
        cells.forEach(cell => {
          cell.style.boxShadow = '0 0 0 2px #3b82f6';
          cell.style.transform = 'scale(1.2)';
          setTimeout(() => {
            cell.style.boxShadow = '';
            cell.style.transform = '';
          }, 1500);
        });
      }
    };

    // ==================== FIBER ORIENTATION OVERLAY ====================
    const fiberOrientationOverlay = {
      lineGroups: [],
      visible: false,
      button: null,

      init() {
        // Create toggle button in stacking view
        const stackingPane = document.getElementById('stacking-pane');
        if (!stackingPane) return;

        const btnContainer = stackingPane.querySelector('.flex.gap-1');
        if (!btnContainer) return;

        this.button = document.createElement('button');
        this.button.id = 'fiber-orientation-btn';
        this.button.className = 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-700 hover:bg-slate-300 transition flex items-center gap-1';
        this.button.title = 'Fiber Orientation Overlay';
        this.button.innerHTML = `
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z"/>
          </svg>
          Fiber
        `;
        this.button.addEventListener('click', () => this.toggle());
        btnContainer.appendChild(this.button);
      },

      generate(plyMeshes) {
        // Clear existing
        this.lineGroups.forEach(group => {
          if (group.parent) group.parent.remove(group);
          group.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
        });
        this.lineGroups = [];

        if (!scene) return;

        // Generate fiber lines for each ply
        plyMeshes.forEach(ply => {
          if (!ply.instancedMesh) return;

          const angle = ply.angle;
          const lineGroup = this.createLines(angle, ply.baseY, ply.zCenter);
          if (lineGroup) {
            lineGroup.visible = this.visible;
            scene.add(lineGroup);
            this.lineGroups.push(lineGroup);
          }
        });
      },

      createLines(angle, y, z) {
        const points = [];
        const lineCount = 8;
        const spacing = PLY_WIDTH / (lineCount + 1);
        const lineMat = new THREE.LineBasicMaterial({
          color: 0xffffff,
          opacity: 0.4,
          transparent: true,
          linewidth: 1
        });

        if (angle === 0) {
          // Horizontal lines
          for (let i = 0; i < lineCount; i++) {
            const zOffset = (i - lineCount / 2) * spacing * 0.3;
            points.push(
              new THREE.Vector3(-PLY_WIDTH / 2, y, z + zOffset),
              new THREE.Vector3(PLY_WIDTH / 2, y, z + zOffset)
            );
          }
        } else if (angle === 90) {
          // Vertical lines (in Z direction)
          for (let i = 0; i < lineCount; i++) {
            const xOffset = (i - lineCount / 2) * spacing * 0.8;
            points.push(
              new THREE.Vector3(xOffset, y, z - PLY_WIDTH / 4),
              new THREE.Vector3(xOffset, y, z + PLY_WIDTH / 4)
            );
          }
        } else if (angle === 45) {
          // Diagonal /
          for (let i = 0; i < lineCount; i++) {
            const offset = (i - lineCount / 2) * spacing * 0.5;
            points.push(
              new THREE.Vector3(-PLY_WIDTH / 2 + offset, y, z - PLY_WIDTH / 4),
              new THREE.Vector3(PLY_WIDTH / 2 + offset, y, z + PLY_WIDTH / 4)
            );
          }
        } else if (angle === -45) {
          // Diagonal \
          for (let i = 0; i < lineCount; i++) {
            const offset = (i - lineCount / 2) * spacing * 0.5;
            points.push(
              new THREE.Vector3(-PLY_WIDTH / 2 + offset, y, z + PLY_WIDTH / 4),
              new THREE.Vector3(PLY_WIDTH / 2 + offset, y, z - PLY_WIDTH / 4)
            );
          }
        }

        if (points.length === 0) return null;

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const lineSegments = new THREE.LineSegments(geometry, lineMat);
        return lineSegments;
      },

      toggle() {
        this.visible = !this.visible;
        this.lineGroups.forEach(group => {
          group.visible = this.visible;
        });

        if (this.button) {
          toggleBtnActive(this.button, this.visible);
        }
      }
    };

    // ==================== EXPOSE TO GLOBAL ====================
    window._view3d = {
      init: initView3D,
      update: update3DStackingView,
      legend: buildLegend,
      initialized: false,
      // Panel 3D
      initPanel3D: initPanel3D,
      updatePanel3D: updatePanel3D,
      resizePanel3D: resizePanel3D,
      panel3dInitialized: false,
    };

    // ==================== CONTROL PANEL TOGGLE ====================
    (function () {
      const controlPanel = document.getElementById('control-panel');
      const toggleBtn = document.getElementById('panel-toggle-btn');
      const openBtn = document.getElementById('panel-open-btn');
      let isPanelOpen = true;

      function togglePanel() {
        isPanelOpen = !isPanelOpen;

        if (isPanelOpen) {
          // Panel açık
          controlPanel.style.marginLeft = '0';
          controlPanel.style.width = '20rem'; // w-80 = 20rem
          openBtn.classList.add('hidden');
          toggleBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7" /></svg>';
        } else {
          // Panel kapalı
          controlPanel.style.marginLeft = '-20rem';
          controlPanel.style.width = '20rem';
          openBtn.classList.remove('hidden');
          toggleBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7" /></svg>';
        }
      }

      toggleBtn.addEventListener('click', togglePanel);
      openBtn.addEventListener('click', togglePanel);
    })();

    // ==================== FULLSCREEN VIEW SWITCHER ====================
    (function () {
      const toP3Btn = document.getElementById('stacking-to-p3-btn');
      const toStackingBtn = document.getElementById('p3-to-stacking-btn');

      function switchView(targetPaneId) {
        // Tab geçişi (Görünüm değiştirme)
        // document.querySelector ile data-tab attribute'una sahip butonu buluyoruz.
        // Bu butonlar index.html'de tanımlı: data-tab="stacking-pane" veya "panel3d-pane"
        const targetTabBtn = document.querySelector(`button[data-tab="${targetPaneId}"]`);

        if (targetTabBtn) {
          targetTabBtn.click();
        } else {
          console.warn("Hedef tab butonu bulunamadı:", targetPaneId);
        }

        // Eğer Fullscreen ise: hedef container'ı da fullscreen yap
        if (document.fullscreenElement) {
          const targetPane = document.getElementById(targetPaneId);
          if (targetPane) {
            // Element değişimi için doğrudan requestFullscreen deniyoruz
            targetPane.requestFullscreen().catch(err => {
              console.warn("Fullscreen switch failed, trying exit+enter", err);
              document.exitFullscreen().then(() => {
                setTimeout(() => {
                  if (targetPane) targetPane.requestFullscreen();
                }, 100);
              });
            });
          }
        }
      }

      if (toP3Btn) {
        toP3Btn.addEventListener('click', (e) => {
          e.stopPropagation(); // Buton tıklaması başka şeyleri tetiklemesin
          switchView('panel3d-pane');
        });
      }
      if (toStackingBtn) {
        toStackingBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          switchView('stacking-pane');
        });
      }
    })();
  </script>
</body>

</html>